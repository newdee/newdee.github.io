<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阁子</title>
  <icon>https://www.gravatar.com/avatar/439d9d368b6faa511da2ceb4232343a2</icon>
  <subtitle>dfine&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dfine.tech/"/>
  <updated>2022-05-19T05:14:53.329Z</updated>
  <id>http://dfine.tech/</id>
  
  <author>
    <name>dfine</name>
    <email>service@define.tech</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小工具(三)</title>
    <link href="http://dfine.tech/posts/a64e7c3f/"/>
    <id>http://dfine.tech/posts/a64e7c3f/</id>
    <published>2020-08-10T11:57:25.000Z</published>
    <updated>2022-05-19T05:14:53.329Z</updated>
    
    <content type="html"><![CDATA[<p>竟然真的有后续！！！(Again)</p><a id="more"></a><h3 id="花里胡哨的命令行监视器bashtop"><a href="#花里胡哨的命令行监视器bashtop" class="headerlink" title="花里胡哨的命令行监视器bashtop"></a>花里胡哨的命令行监视器bashtop</h3><p>作用基本上就跟top差不多，不过视觉效果还不错。对比一下，<br>top命令:<br><img src="https://fastly.jsdelivr.net/gh/newdee/BlogImage/20200812160003.png" width="500" height="500"> </p><p><a href="https://github.com/aristocratos/bashtop" rel="external nofollow noopener noreferrer" target="_blank">bashtop</a>命令:<br><img src="https://fastly.jsdelivr.net/gh/newdee/BlogImage/20200812160404.png" width="500" height="500"> </p><p>其中，最上面是CPU资源使用情况，左侧是内存和网络资源使用情况，右边是和top一样的进程状态，可以使用方向键来选择进程，或者翻页键来翻页，按f可以filter需要找的进程。<br>在选中进程之后，可以使用回车键查看该进程详细信息，t和k健可以terminate或者kill进程，i可以中断进程(interrupt)。<br>按q退出，按ESC可以跳回主界面，如果不清楚命令或者快捷键，可以选择HELP查看，总之使用方法比top简单不少。<br>缺点，就是感觉没有top出来的快，可能是因为要在terminal上绘图。  </p><h3 id="文件格式转换工具xxd"><a href="#文件格式转换工具xxd" class="headerlink" title="文件格式转换工具xxd"></a>文件格式转换工具xxd</h3><p>xxd是linux上比较老的文件格式转换工具了，经常使用vim的在打开二进制文件的时候输入的<code>!xxd</code>就是这个命令，一般作用是将文件转为十六进制。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line">       xxd [options] [infile [outfile]]</div><div class="line">    <span class="keyword">or</span></div><div class="line">       xxd -r [-s [-]<span class="built_in">offset</span>] [-c cols] [-ps] [infile [outfile]]</div><div class="line">Options:</div><div class="line">    -<span class="keyword">a</span>          toggle autoskip: A single <span class="string">'*'</span> replaces nul-<span class="keyword">lines</span>. Default off.</div><div class="line">    -b          binary digit dump (incompatible <span class="keyword">with</span> -ps,-i,-r). Default hex.</div><div class="line">    -C          capitalize <span class="built_in">variable</span> names <span class="keyword">in</span> C <span class="built_in">include</span> <span class="built_in">file</span> style (-i).</div><div class="line">    -c cols     <span class="built_in">format</span> &lt;cols&gt; octets per <span class="built_in">line</span>. Default <span class="number">16</span> (-i: <span class="number">12</span>, -ps: <span class="number">30</span>).</div><div class="line">    -E          show <span class="keyword">characters</span> <span class="keyword">in</span> EBCDIC. Default ASCII.</div><div class="line">    -e          little-endian dump (incompatible <span class="keyword">with</span> -ps,-i,-r).</div><div class="line">    -g          <span class="built_in">number</span> <span class="keyword">of</span> octets per group <span class="keyword">in</span> <span class="keyword">normal</span> output. Default <span class="number">2</span> (-e: <span class="number">4</span>).</div><div class="line">    -h          print this summary.</div><div class="line">    -i          output <span class="keyword">in</span> C <span class="built_in">include</span> <span class="built_in">file</span> style.</div><div class="line">    -l <span class="built_in">len</span>      <span class="built_in">stop</span> <span class="keyword">after</span> &lt;<span class="built_in">len</span>&gt; octets.</div><div class="line">    -o off      <span class="built_in">add</span> &lt;off&gt; <span class="built_in">to</span> <span class="keyword">the</span> displayed <span class="built_in">file</span> position.</div><div class="line">    -ps         output <span class="keyword">in</span> postscript plain hexdump style.</div><div class="line">    -r          reverse operation: <span class="built_in">convert</span> (<span class="keyword">or</span> patch) hexdump <span class="keyword">into</span> binary.</div><div class="line">    -r -s off   revert <span class="keyword">with</span> &lt;off&gt; added <span class="built_in">to</span> <span class="built_in">file</span> positions found <span class="keyword">in</span> hexdump.</div><div class="line">    -s [+][-]<span class="built_in">seek</span>  <span class="built_in">start</span> <span class="keyword">at</span> &lt;<span class="built_in">seek</span>&gt; <span class="keyword">bytes</span> <span class="built_in">abs</span>. (<span class="keyword">or</span> +: <span class="built_in">rel</span>.) infile <span class="built_in">offset</span>.</div><div class="line">    -u          use <span class="built_in">upper</span> <span class="keyword">case</span> hex letters.</div><div class="line">    -v          show <span class="built_in">version</span>: <span class="string">"xxd V1.10 27oct98 by Juergen Weigert"</span>.</div></pre></td></tr></table></figure></p><h4 id="文件转十六进制"><a href="#文件转十六进制" class="headerlink" title="文件转十六进制"></a>文件转十六进制</h4><p>最简单的方式是<code>xxd file</code>,会在终端输出转换后该文件的十六进制内容，使用重定向或者管道可以写到文件或作用于其他输入。<br>如果文件比较大，可能转换比较慢，而且很多并不是我们需要的话，可以使用<code>-s</code>或者<code>-l</code>参数。<br><code>-s</code>参数如上所示，“start at <seek> bytes abs”，从指定位置开始转换。<br><code>-l</code>参数则是指定要转换内容的长度。  </seek></p><h4 id="二进制文件的比较"><a href="#二进制文件的比较" class="headerlink" title="二进制文件的比较"></a>二进制文件的比较</h4><p>如果要比较两个二进制文件内容是否一致，可以借助于<code>xxd</code>命令。<br>例如，需要比较两个原始的yuv格式视频文件是否一致，比如两种方式通过h264解码出来的文件，平常的<code>diff</code>命令是无法完成的，可以先利用xxd命令转成十六进制后再进行比较。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xxd <span class="selector-tag">a</span><span class="selector-class">.yuv</span> &gt; <span class="selector-tag">a</span>.hex</div><div class="line">xxd <span class="selector-tag">b</span><span class="selector-class">.yuv</span> &gt; <span class="selector-tag">b</span>.hex</div><div class="line">diff <span class="selector-tag">a</span><span class="selector-class">.hex</span> <span class="selector-tag">b</span>.hex</div></pre></td></tr></table></figure></p><p>之所以举这个例子，是因为yuv是原始视频数据，比如一个1920x1080的h264编码后的视频大小只有8M多，但是其对应的解码后的yuv大小则可能有1.1G多，而使用xxd转成十六进制文件之后，体积可以达到4.5G，直接用<code>diff</code>命令比较费时，而且用vim打开还容易卡死。而通常只需要比较其中一部分可以判断出解码的文件是否正常，这时候就可以在<code>xxd</code>命令转换的时候加上<code>-l</code>或者<code>-s</code>参数，指定比较的文件位置和长度，可以很快的得到结果。  </p><p>当然，比较方式也不是绝对的，对于视频文件，使用<code>ffmpeg</code>也可以查看许多详细信息。  </p><h3 id="应用代理工具proxychains"><a href="#应用代理工具proxychains" class="headerlink" title="应用代理工具proxychains"></a>应用代理工具proxychains</h3><p>这个其实很早以前打算说的，不过忘记了。作用有点像chrome里的SwitchyOmega之类的扩展程序，不同的是，SwitchyOmega是针对特定网页选择本地的代理端口和协议，proxychains是针对某个命令或者应用选择本地代理端口和协议。<br>安装方法比较简单，ubuntu下直接使用apt命令可以安装:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt <span class="keyword">install</span> proxychains</div></pre></td></tr></table></figure></p><p>安装好之后，配置文件放在<code>/etc</code>目录下的<code>proxychains.conf</code>文件，修改里面的协议和端口即可。<br>使用方式是直接在命令前加上<code>proxychains</code>,这样只对该命令代理，不影响其他应用。<br>比如使用ubuntu的<code>snap</code>命令下载软件时，通常国内会比较慢，如果有代理，则可以使用:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxychains sudo snap <span class="keyword">install</span> xxx</div></pre></td></tr></table></figure></p><p>其实很多工具也不是啥新鲜玩意，不过有时候确实挺实用的，不过仅仅对工具而言，没有任何性质，怎么用在于个人。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;竟然真的有后续！！！(Again)&lt;/p&gt;
    
    </summary>
    
      <category term="Share" scheme="http://dfine.tech/categories/Share/"/>
    
    
      <category term="bashtop" scheme="http://dfine.tech/tags/bashtop/"/>
    
      <category term="xxd" scheme="http://dfine.tech/tags/xxd/"/>
    
      <category term="proxychains" scheme="http://dfine.tech/tags/proxychains/"/>
    
  </entry>
  
  <entry>
    <title>相机小述</title>
    <link href="http://dfine.tech/posts/79707c4f/"/>
    <id>http://dfine.tech/posts/79707c4f/</id>
    <published>2020-07-19T11:38:16.000Z</published>
    <updated>2022-05-19T05:14:29.253Z</updated>
    
    <content type="html"><![CDATA[<p>看了看，好像自己确实是太懒了，不过虽然这样，说的时候还是要把锅甩给疫情的，想起以前接触相机这么久了，不如就还记得的一点东西，介绍一下，水一点东西，混一次提交。<br>不过不知道有没有帮助，不是介绍什么拍摄三要素（快门、光圈、感光度）的控制，也不是什么九宫格拍摄法之类的，说实话，那些五花八门的拍摄方法我也不太熟悉,就讲讲相机结构。<br><a id="more"></a></p><h3 id="传感器类型"><a href="#传感器类型" class="headerlink" title="传感器类型"></a>传感器类型</h3><p>图像传感器主要有两种，线阵和面阵，平时看到的线阵相机和面阵相机就是因为用的Sensor类型不同。<br>线阵Sensor以CCD为主，一行的数据可以到几K甚至几十K，但是高度叧有几个像素，行频很高，可以到每秒几万行，适合做非常高精度、宽画幅的扫描。<br>面阵Sensor，包含CCD和CMOS，单行数据宽度远小于线阵，优点是成像快，一次可以成像很多行，即单次扫描的像素高度比线阵高很多。另外开发简单，成像快，不用进行每行数据的拼接。而且价格便宜不少，这个大概是应用更广泛的决定性条件。</p><h3 id="快门类型"><a href="#快门类型" class="headerlink" title="快门类型"></a>快门类型</h3><h4 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h4><p>CMOS传感器的大致结构如图，由于其感光方式不同，因此有两种类型快门。</p><center><br><img src="https://fastly.jsdelivr.net/gh/newdee/BlogImage/20200801204640.png" width="300" height="300"><br></center><h5 id="Rolling-Shutter（滚动快门）"><a href="#Rolling-Shutter（滚动快门）" class="headerlink" title="Rolling Shutter（滚动快门）"></a>Rolling Shutter（滚动快门）</h5><p>滚动快门在感光时是逐行进行的，从第一行开始，一边曝光一边输出图像，一直滚动到最后一行,模数转换器则是逐行共用。这样，实际上每一行曝光的时间点会不一样，时间上存在一个位移，这样导致每行图像会有一些位移偏差，特别是当对象是高速运动物体时更明显，会导致图像的扭曲变形。这种变形和平时拍摄运动物体的拖影不一样，拖影是由于拍摄物体运动速度太快，而且曝光时间设置太长造成，会带有一些图像模糊。滚动快门的变形是每行时间上的不同步拍摄而造成的变形，图像清晰度不会受到影响。  </p><h5 id="Global-Shutter（全局快门）"><a href="#Global-Shutter（全局快门）" class="headerlink" title="Global Shutter（全局快门）"></a>Global Shutter（全局快门）</h5><p>为了改善这种变形，则可以在每个像素处增加采样保持单元或者模数转换器。增加采样保持单元可以短暂保存得到的模拟数据，再等待模数转换器进行逐行转换，转换期间可以继续进行拍摄。而这种方案会浪费比较多的CMOS面积来摆放这些用来短暂保存的像素，使得填充系数降低，而且采样保持单元还引入了新的噪声源。因此在每个像素处增加模数转换器则是一种新的方案(如索尼做的)，每个像素采集到了就可以直接转换，不用等待，实现真正意义上的全局快门。  </p><h4 id="CCD"><a href="#CCD" class="headerlink" title="CCD"></a>CCD</h4><p>CCD(电荷耦合器件)的结构大致如图，其结构决定了CCD具有“免费全局快门”的优点，所有像素在同一时刻曝光，所有像素同时移入传输寄存器，曝光完成后，每个像素被串行传输到单个模数转换器中，因此其传输帧率受限于单个像素数字化速率和传感器中的像素数量。  </p><center><br><img src="https://fastly.jsdelivr.net/gh/newdee/BlogImage/20200801203620.png" width="500" height="500"><br></center><h3 id="光学尺寸"><a href="#光学尺寸" class="headerlink" title="光学尺寸"></a>光学尺寸</h3><p>光学尺寸是指其感光区域的大小，通常高分辨率的面阵相机或者线阵相机的相机芯片尺寸要大于低分辨率的，其尺寸没有特定标准，是有其分辨率和像素大小决定的。从理论上讲，可以有无数种类型，只要价格到位。尺寸通常用感光元件的对角线来表示，单位是英寸，不过由于历史原因，这里的1英寸是16mm，不是25.4mm。常见的有1/4”、1/3”、1/2.5”、1/2.3”、1/2”、2/3”、1”、1.1”等。<br>介绍光学尺寸的原因是，通常为相机选择镜头的时候要考虑到，镜头靶面尺寸要配合其光学尺寸。  </p><h3 id="靶面尺寸"><a href="#靶面尺寸" class="headerlink" title="靶面尺寸"></a>靶面尺寸</h3><p>靶面尺寸，或者靶面直径，单位也是英寸，理想情况下，1/2”的镜头应该安装在1/2”的光学芯片上，这样可以尽可能的利用靶面，但是如果安装在2/3”的芯片上，由于感光区域大于感光范围，那么感光区域中无法感光的部分则会在最终的图像中出现暗角或者晕影。不过如果采用2/3”的 镜头匹配1/2”的芯片，则可以完全利用光学尺寸，实际上使用大的镜头可以形成更大的靶面，图像从中心到边缘的锐化可以保持一致，但这种情况下，很大一部分罢免无法使用，造成浪费。图像的大小是有光学尺寸决定的，而镜头越大，则价格越贵，如果想节约点，对于比较小的光学尺寸，还是选择较小的镜头。</p><h3 id="镜头接口"><a href="#镜头接口" class="headerlink" title="镜头接口"></a>镜头接口</h3><p>镜头接口是连接镜头和相机的接口，有螺纹接口和卡口两类。比较常见的C口、CS口等都是螺纹接口。<br>最常见的C口和CS口的工业相机，接口实际上比较相似，也有其转换环，因为它们的接口直径、螺纹间距都一样，只是<a href="https://zh.wikipedia.org/wiki/%E6%B3%95%E5%85%B0%E8%B7%9D" rel="external nofollow noopener noreferrer" target="_blank">法兰距</a>不同。C接口的法兰距是17.526mm，CS接口的法兰距为12.5mm。因此所谓转接环，就是一个5mm左右的垫圈了。<br>此外，螺纹接口还有M12、M45、M58等，具体规格在需要的时候查询即可，这里不在赘述。<br>至于卡口相机，平常见到的单反基本上都是卡口，如尼康的F口或者佳能的EF口，这俩外观上也不容易区分，不过F口的法兰距比EF口的要长。  </p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E8%BE%A8%E7%8E%87#%E6%95%B0%E7%A0%81%E7%9B%B8%E6%9C%BA%E5%88%86%E8%BE%A8%E7%8E%87" rel="external nofollow noopener noreferrer" target="_blank">分辨率</a>，泛指量测或显示系统对细节的分辨能力。相机制造商一般直接用像素数目表示分辨率，实际上这是分辨率上限。<br>因为这种情况，是当镜头能够解析像素大小时候才成立。只有使用高分辨率镜头，才能最终得到高分辨率图像。<br>镜头的分辨率通常通过每毫米线对数衡量，表示每毫米中可以相互分离的行的数量。每毫米线对数越多，分辨率越高，镜头质量越好。镜头分辨率确定了可以解析的像素大小，方便起见，一般情况下直接指定镜头可以解析的百万像素数，当镜头分辨率可以完全解析感光元件的所有像素点时，则可以获得最高分辨率。<br>表示镜头分辨率性能的指标有MTF曲线（调制传递函数），描述了镜头从图像中心到边缘的分辨率性能，通常可以找制造商要到这些曲线。  </p><h3 id="焦距"><a href="#焦距" class="headerlink" title="焦距"></a>焦距</h3><p>焦距是镜头光学中心和焦点之间的距离，通常长焦镜头适合拍远景，但视场小；短焦适合拍广角，常用的鱼眼或者微距镜头就是。  </p><h3 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h3><p>光圈的参数通常用F Number来表示，是焦距与光圈直径的比值，表示光圈全开时的宽度。<br>光圈的选择直接影响的是进光量，最终影响的是图像质量和亮度。F值越高，则光圈越小，最终感光元件获得的进光量越少，反之亦然。通常可以根据光源亮度调整。  </p><p>减小光圈，可以减少相机光晕效果，景深越大，不过光圈太小，容易产生衍射模糊。  </p><h3 id="帧存和缓存"><a href="#帧存和缓存" class="headerlink" title="帧存和缓存"></a>帧存和缓存</h3><p>带帧存功能的相机，是指该相机内部具有保存一帧完整图像的能力，当传输带宽不够或者不稳定时，由于缓存了整个图像帧，所以仍然可以断点续传之后重建图像。<br>带缓存功能的相机，是指该相机内部具有缓存一部分图像数据的能力，但是无法缓存一整个帧，当传输带宽不够或者不稳定时候，有可能造成缓存溢出，最后无法重建图像从而造成丢帧等问题。<br>平常见到的工业相机一般都是带缓存的，不一定有帧存，在结构和价格上也有区别。只带缓存的相机结构简单，价格便宜。  </p><p>此外，还有一些简单的参数，如相机图像的帧率FPS，图像的亮度、饱和度、对比度等等，由于比较常见，顾名思义，就不继续赘述。<br>先偷个懒，改天想到了啥，再续狗尾。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了看，好像自己确实是太懒了，不过虽然这样，说的时候还是要把锅甩给疫情的，想起以前接触相机这么久了，不如就还记得的一点东西，介绍一下，水一点东西，混一次提交。&lt;br&gt;不过不知道有没有帮助，不是介绍什么拍摄三要素（快门、光圈、感光度）的控制，也不是什么九宫格拍摄法之类的，说实话，那些五花八门的拍摄方法我也不太熟悉,就讲讲相机结构。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://dfine.tech/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Cameras" scheme="http://dfine.tech/tags/Cameras/"/>
    
  </entry>
  
  <entry>
    <title>四元数与旋转矩阵</title>
    <link href="http://dfine.tech/posts/dc13723b/"/>
    <id>http://dfine.tech/posts/dc13723b/</id>
    <published>2020-01-08T08:08:57.000Z</published>
    <updated>2022-05-19T05:14:43.925Z</updated>
    
    <content type="html"><![CDATA[<p>在计算物体旋转时，如相机标定中的旋转矩阵R，通常都是以三维矩阵表示，三个自由度分别是绕三个坐标轴的旋转角度，但在Unity中，或者像<a href="https://github.com/colmap/colmap" rel="external nofollow noopener noreferrer" target="_blank">colmap</a>中,都是以四元数(Quaternion)来表示三维旋转的。实际上是复平面向量与实数域矩阵的一个转换关系，这里推导一下。  </p><a id="more"></a><h3 id="二维情况"><a href="#二维情况" class="headerlink" title="二维情况"></a>二维情况</h3><p>一维数轴上的复数对应于一个二维实数空间，比如一个二维空间坐标为 $(x,y)$ 的复数表示为 $x + yi$ 。<br>给定两个复数 $z1 = a + bi$, $z2 = c +di$, 其乘积可以表示为:<br>$$ z1z2 = (a+bi)(c+di) = (ac-bd)+(ad+bc)i $$<br>对于向量$z2$,与$z1$的乘积可以表示为矩阵形式，即：<br>$$<br>\begin{bmatrix}<br>a &amp; -b \\<br>b &amp; a \\<br>\end{bmatrix}<br>\cdot z2<br>$$<br>如果将$z2$也看做一个变换表示成矩阵形式，则<br>$$<br>z1z2 =<br>\begin{bmatrix}<br>a &amp; -b \\<br>b &amp; a \\<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>c &amp; -d \\<br>d &amp; a \\<br>\end{bmatrix}<br>$$</p><p>此时满足交换律。  </p><h4 id="二维旋转"><a href="#二维旋转" class="headerlink" title="二维旋转"></a>二维旋转</h4><p>设向量模长为1，即$\sqrt[2]{a^2 + b ^2} =1$，则$a = cos\theta, b=sin\theta$, 则对一个向量$\vec{v}=x+yi$,其乘积为$\vec{v} \dot z = (xcos\theta -ysin\theta) +(xsin\theta +ycos\theta)i$,</p><img src="https://fastly.jsdelivr.net/gh/newdee/BlogImage/20200108171154.jpg" width="500" height="500"><p>设向量$\vec{v}$的模为r，则$\vec{v}\cdot \vec{z} = r(cos\theta_1cos\theta_2 -sin\theta_1sin\theta_2)+r(cos\theta_1sin\theta_1 + sin\theta_1cos\theta_2)i = rcos(\theta_1 +\theta_2) +rsin(\theta_1 + \theta_2) i $<br>可以看出，一个单位的二维向量，或一维复数，可以表示成一个旋转变换，即逆时针旋转$\theta$角。</p><p>所以二维的旋转矩阵可以很直观的求得:<br>$$<br>\begin{bmatrix}<br>cos\theta &amp; -sin\theta \\<br>sin\theta &amp; cos\theta \\<br>\end{bmatrix}<br>$$</p><h4 id="极坐标形式"><a href="#极坐标形式" class="headerlink" title="极坐标形式"></a>极坐标形式</h4><p>其实将复数表示成极坐标形式，欧拉公式将三角函数和复平面关联起来，于是可以很直接的将$ e^{i\theta} = cos\theta + isin\theta$带入，角度旋转即$$ e^{i\theta_1} * e^{i\theta_2} = e^{i(\theta_1 + \theta_2)}$$</p><h3 id="三维情况"><a href="#三维情况" class="headerlink" title="三维情况"></a>三维情况</h3><p>先看向量的旋转: 将向量$\vec{v}$绕旋转轴$\vec{u}$旋转$\theta$角。<br>将$\vec{v}$分解成两个正交向量的和，分别是平行于$\vec{u}$和垂直于$\vec{u}$的向量，记为$\vec{v_{||}}$和$\vec{v_\bot}$,平行的向量旋转不变，因此只需要考虑垂直向量即可。<br>对于$\vec{v_{||}}$，其实就是在$\vec{u}$上的正交投影，因此有$\vec{v_{||}} = \frac{\vec{u}\cdot \vec{v}}{||\vec{u}||^2} \vec{u}$,设$\vec{u}$为单位向量，则可以表示为$\vec{v_{||}} = (\vec{u}\cdot \vec{v})\vec{u}$ 。<br>所以，$$\vec{v_\bot} = \vec{v} - \vec{v_{||}} =  \vec{v} -  (\vec{u}\cdot \vec{v})\vec{u}$$<br>因为$\vec{v_\bot}$和$\vec{u}$垂直，所以旋转可以转化成二维平面的旋转，构造一个向量$\vec{w} = \vec{u} \times \vec{v}$,如图所示，<br><img src="https://fastly.jsdelivr.net/gh/newdee/BlogImage/20200108180326.jpg" width="500" height="500"></p><p>所以旋转后的向量为$$\begin{aligned} \vec{v_\bot}^\prime &amp; = \vec{v_\bot}cos\theta + \vec{w}sin\theta \\ &amp; = \vec{v_\bot}cos\theta + \vec{u} \times \vec{v_\bot} sin\theta \end{aligned}$$<br>最后旋转后的向量为 $$ \begin{aligned} \vec{v}^\prime &amp; = \vec{v_{||}} + \vec{v_\bot}^\prime \\ &amp; =  \vec{v_{||}} + \vec{v_\bot}cos\theta + \vec{u} \times \vec{v_\bot} sin\theta \\ &amp; = (\vec{u}\cdot \vec{v})\vec{u} + \vec{v_\bot}cos\theta + \vec{u} \times \vec{v_\bot} sin\theta  \\ &amp; = (\vec{u}\cdot \vec{v})\vec{u} +  (\vec{v} - (\vec{u}\cdot \vec{v})\vec{u} )cos\theta + \vec{u} \times (\vec{v} - (\vec{u}\cdot \vec{v})\vec{u}) sin\theta \\ &amp; = \vec{v}cos\theta +(1-cos\theta)(\vec{u}\cdot \vec{v})\vec{u} +(\vec{u}\times \vec{v}))sin\theta \end{aligned}$$</p><h4 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h4><p>四元数可以看做一个四元向量，或是有三个虚部的复数，如$q = a + bi+cj+dk$,也可以写成矩阵形式，<br>$$\vec{q} =<br>\begin{bmatrix}<br>a \\<br>b \\<br>c \\<br>d \\<br>\end{bmatrix}<br>$$</p><p>如三维坐标轴的顺序，复数相乘有，<br>$$ij =k \\<br>jk =i \\<br>ki =j$$<br>令$q1 = a + bi+cj+dk$, $q2 = e + fi+gj+hk$<br>则左乘$q1$可以为<br>$$<br>\begin{aligned}<br>q1q2 &amp; = ae + a f i + agj + ahk + \\<br>&amp; bei − b f + bgk − bhj + \\<br>&amp; cej − c f k − cg + chi + \\<br>&amp; dek + d f j − dgi − dh \\<br>&amp; = ( ae − b f − cg − dh )+ \\<br>&amp; ( be + a f − dg + ch ) i \\<br>&amp; ( ce + d f + ag − bh ) j \\<br>&amp; ( de − c f + bg + ah ) k<br>\end{aligned}<br>$$</p><p>矩阵形式可以写成，<br>$$q1q2 =<br>\begin{bmatrix}<br>a &amp;  -b &amp; -c &amp; -d \\<br>b &amp;  a  &amp; -d &amp; c \\<br>c &amp;  d  &amp; a  &amp; -b \\<br>d &amp;  -c &amp; b  &amp; a<br>\end{bmatrix}<br>\begin{bmatrix}<br>e \\<br>f \\<br>g \\<br>h \\<br>\end{bmatrix}<br>$$<br>四元数向量不满足交换律，右乘会有一些区别。  </p><h4 id="Grasmann积"><a href="#Grasmann积" class="headerlink" title="Graßmann积"></a>Graßmann积</h4><p>将四元数的虚部表示成一个向量，即$ q1 = [a,\vec{v}]$，$q2 = [e, \vec{u}]$，其中，$\vec{v} = bi+cj+dk$，$\vec{u} = fi+gj+hk$。<br>则左乘$q1$可以化简成<br>$$q1q2 = [ ae − \vec{v} \cdot  \vec{u} , a\vec{u} + e\vec{v} + \vec{v} \times  \vec{u} ]$$<br>这个结果也被称为 Graßmann 积。<br>这样，当a和e为零时，两者乘积可以写成，<br>$$ q1q2 = [− \vec{v} \cdot  \vec{u}, \vec{v} \times  \vec{u} ]$$<br>同纯虚数的说法，这时q1和q2叫纯四元数。  </p><h4 id="共轭性质"><a href="#共轭性质" class="headerlink" title="共轭性质"></a>共轭性质</h4><p>与二元虚数类似，四元数的共轭也是将虚部方向取反，即 $q^* = a - bi - cj - dk$,则  </p><p>$$<br>\begin{aligned}<br>qq^* &amp; = [s,\vec{v}] \cdot [s,-\vec{v}] \\<br> &amp; = [s^2 - \vec{v} \cdot (-\vec{v}), s(-\vec{v}) + s\vec{v} + \vec{v}\times(-\vec{v})] \\<br>&amp; = [s^2 + \vec{v} \cdot \vec{v}, \vec{0}] \\<br>\end{aligned}<br>$$</p><p>实部平方与虚部平方和，即该向量的模的平方,最后虚部为零，所以  </p><p>$$<br>\begin{aligned}<br>qq^* &amp; = [s^2 + \vec{v} \cdot \vec{v}, \vec{0}] \\<br>&amp; = s^2 + |\vec{v}|^2 \\<br>&amp; = a^2 + b^2 + c^2 +d^2 \\<br>\end{aligned}<br>$$</p><p>由于q与其共轭的积最后是个标量，为其模长，所以该乘法是满足交换律的。即$qq^* = q^*q = |q|^2$。<br>这样，<br>$$<br>q^*q  =  |q|^2   \\<br>\frac{q^*}{|q|^2}q =1<br>$$<br>则可以发现$q^{-1} = \frac{q^*}{|q|^2}$ 满足$q^{-1}q = qq^{-1} =1$,即为该四元数的逆。  </p><p>而单位四元数的逆即为其共轭四元数。  </p><h4 id="三维旋转"><a href="#三维旋转" class="headerlink" title="三维旋转"></a>三维旋转</h4><p>旋转轴$\vec{u}$不妨设为单位向量，与之前的旋转类似，<br>$$ \vec{v’} = \vec{v’_{||}} +\vec{v’_\bot} = \vec{v_{||}} +\vec{v’_\bot}<br>$$<br>之前计算过正交与旋转轴的向量旋转得到的结果，$$\vec{v’_\bot} = \vec{v_\bot}cos\theta + (\vec{u}\times \vec{v_\bot})sin\theta$$<br>设u,v都是纯四元数，即$u = [0,\vec{u}]$,$v = [0,\vec{v}]$,两个纯四元数的Graßmann积为$$uv_\bot = [− \vec{v_\bot} \cdot  \vec{u}, \vec{v_\bot} \times  \vec{u} ] = [ 0, \vec{v_\bot} \times  \vec{u} ] = \vec{v_\bot} \times  \vec{u} $$<br>也是一个纯四元数。<br>所以，<br>$$<br>\begin{aligned}<br>v’_\bot &amp; = v_\bot cos\theta + (u v_\bot)sin\theta \\<br>&amp; = (cos\theta + usin\theta)v_\bot<br>\end{aligned}<br>$$<br>令四元数$q = (cos\theta + usin\theta)v_\bot$，则$ v’_\bot = qv_\bot$<br>所以对于垂直于旋转轴的向量，旋转$\theta$角度之后的向量可以用四元数的乘法来获得， 用向量表示为$q = [cos\theta, \vec{u}sin\theta]$<br>由于$\vec{u}$是单位向量，所以$$||q|| = cos^2\theta + ||\vec{u}||^2 sin^2\theta =1 $$<br>同样的表示方式，$qqv_\bot = q(qv_\bot)$几何上表示旋转两次，因此有$qqv_\bot =  (cos2\theta + usin2\theta)v_\bot $<br>所以最后旋转之后的四元数，<br>$$\begin{aligned}<br>v’ &amp; = v’_{||} + v’_\bot \\<br>&amp;  = v_{||} + qv_\bot  \\<br>&amp;  = pp^{-1}v_{||} + ppv_\bot \\<br>&amp;  = pp^*v_{||} + ppv_\bot<br>\end{aligned}<br>$$<br>其中，$p = [cos(\frac{\theta}{2}),\vec{u}sin(\frac{\theta}{2})]$,是旋转半角的单位向量，因此$q=p^2$。</p><p>交换性质：<br>由之前的Graßmann积，上式中，将q写成向量形式，$q = [\alpha, \beta\vec{u}]$<br>$$  \begin{aligned}<br>qv_{||} &amp; = [\alpha, \beta \vec{u}] \cdot [0,\vec{v}_{||}]  \\<br>&amp; = [-\beta \vec{u} \cdot \vec{v}_{||} , \alpha \vec{v}_{||} + \beta \vec{u} \times \vec{v}_{||}] \\<br>&amp; = [-\beta \vec{u} \cdot \vec{v}_{||} , \alpha \vec{v}_{||}] \\<br>\end{aligned}<br>$$<br>右乘，<br>$$  \begin{aligned}<br>v_{||}q &amp; = [0,\vec{v}_{||}] \cdot [\alpha, \beta \vec{u}] \cdot   \\<br>&amp; = [-\beta \vec{u} \cdot \vec{v}_{||} , \alpha  \vec{v} +\vec{u} \times \vec{v}_{||}] \\<br>&amp; = [-\beta \vec{u} \cdot \vec{v}_{||} , \alpha \vec{v} ] \\<br>&amp; = qv_{||}<br>\end{aligned}<br>$$</p><p>再看垂直部分，<br>$$  \begin{aligned}<br>qv_\bot &amp; = [\alpha, \beta \vec{u}] \cdot [0,\vec{v}_{}]  \\<br>&amp; = [-\beta \vec{u} \cdot \vec{v}_\bot , \alpha \vec{v}_\bot + \beta \vec{u} \times \vec{v}_\bot] \\<br>&amp; = [0, \alpha \vec{v}_\bot + \beta \vec{u} \times \vec{v}_\bot] \\<br>\end{aligned}<br>$$</p><p>右乘共轭，<br>$$  \begin{aligned}<br>v_\bot q^* &amp; = [0,\vec{v}_\bot] \cdot [\alpha, -\beta \vec{u}] \cdot   \\<br>&amp; = [-\beta \vec{u} \cdot \vec{v}_\bot , \alpha \vec{v}_\bot + \beta \vec{u} \times \vec{v}_\bot] \\<br>&amp; = [0, \alpha \vec{v}_\bot + \beta \vec{u} \times \vec{v}_\bot] \\<br>&amp; = qv_\bot<br>\end{aligned}<br>$$</p><p>所以旋转之后的结果可以化简为<br>$$\begin{aligned}<br>v’ &amp;  = pp^*v_{||} + ppv_\bot \\<br>&amp; = pv_{||}p^*  + pv_\bot p^* \\<br>&amp; = p(v_{||} + v_\bot) p^* \\<br>&amp; = pvp^*<br>\end{aligned}<br>$$</p><p>实际上，从计算过程可以看出，对于平行分量，乘$pp^*$，实际上是没有变化，对于垂直分量，乘$pp$,旋转了$\frac{\theta}{2} + \frac{\theta}{2} = \theta$角度。因此可以用旋转半角的四元数乘法来表示绕单位向量$\vec{u}$的旋转。  </p><h4 id="矩阵形式"><a href="#矩阵形式" class="headerlink" title="矩阵形式"></a>矩阵形式</h4><p>单位向量$p= [cos(\frac{\theta}{2}), \vec{u}sin(\frac{\theta}{2})]$,以通用四元数方式表示为$p = a + bi + cj + dk$<br>其中$a=cos(\frac{\theta}{2}), b=u_x sin(\frac{\theta}{2}),c=u_y sin(\frac{\theta}{2}),  b=u_z sin(\frac{\theta}{2})$<br>写成矩阵形式，之前说了四元数的矩阵形式左乘和右乘有点区别，左乘矩阵为<br>$$L=<br>\begin{bmatrix}<br>a &amp;  -b &amp; -c &amp; -d \\<br>b &amp;  a  &amp; -d &amp; c \\<br>c &amp;  d  &amp; a  &amp; -b \\<br>d &amp;  -c &amp; b  &amp; a<br>\end{bmatrix}<br>$$</p><p>右乘的矩阵等同于左乘矩阵<br>$$R = \begin{bmatrix}<br>a &amp;  -b &amp; -c &amp; -d \\<br>b &amp;  a  &amp; -d &amp; -c \\<br>c &amp;  -d  &amp; a  &amp; b \\<br>d &amp;  c &amp; -b  &amp; a<br>\end{bmatrix}<br>$$</p><p>所以有，</p><p>$$<br>\begin{aligned}<br>qvq^* &amp; = L(q)R(q^*)v \\<br>&amp; =<br>\begin{bmatrix}<br>a &amp;  -b &amp; -c &amp; -d \\<br>b &amp;  a  &amp; -d &amp; c \\<br>c &amp;  d  &amp; a  &amp; -b \\<br>d &amp;  -c &amp; b  &amp; a  \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>a &amp;  b &amp; c &amp; d \\<br>-b &amp;  a  &amp; -d &amp; c \\<br>-c &amp;  d  &amp; a  &amp; -b \\<br>-d &amp;  -c &amp; b  &amp; a  \\<br>\end{bmatrix}<br>v \\<br>&amp; =<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp;  1-2c^2-2d^2 &amp; 2bc-2ad &amp; 2ac+2bd \\<br>0 &amp;  2bc+2ad  &amp; 1-2b^2-2d^2 &amp; 2cd -2ab \\<br>0 &amp;  2bd-2ac  &amp; 2ab+2cd  &amp; 1-2b^2-2c^2 \\<br>\end{bmatrix}<br>v \\<br>\end{aligned}<br>$$</p><p>矩阵最外圈不会有任何影响，所以可以得出向量$\vec{v}$绕单位向量旋转轴$\vec{u}$旋转的三维矩阵变换，即</p><p>$$\vec{v’} =<br>\begin{bmatrix}<br>1-2c^2-2d^2 &amp; 2bc-2ad &amp; 2ac+2bd \\<br>2bc+2ad  &amp; 1-2b^2-2d^2 &amp; 2cd -2ab \\<br>2bd-2ac  &amp; 2ab+2cd  &amp; 1-2b^2-2c^2 \\<br>\end{bmatrix}<br>\vec{v}<br>$$</p><p>其中$a=cos(\frac{\theta}{2}), b=u_x sin(\frac{\theta}{2}),c=u_y sin(\frac{\theta}{2}),  b=u_z sin(\frac{\theta}{2})$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算物体旋转时，如相机标定中的旋转矩阵R，通常都是以三维矩阵表示，三个自由度分别是绕三个坐标轴的旋转角度，但在Unity中，或者像&lt;a href=&quot;https://github.com/colmap/colmap&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;colmap&lt;/a&gt;中,都是以四元数(Quaternion)来表示三维旋转的。实际上是复平面向量与实数域矩阵的一个转换关系，这里推导一下。  &lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://dfine.tech/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Quaternion" scheme="http://dfine.tech/tags/Quaternion/"/>
    
      <category term="Mathpix" scheme="http://dfine.tech/tags/Mathpix/"/>
    
      <category term="Pi-hole" scheme="http://dfine.tech/tags/Pi-hole/"/>
    
  </entry>
  
  <entry>
    <title>小工具(二)</title>
    <link href="http://dfine.tech/posts/d8bd5c14/"/>
    <id>http://dfine.tech/posts/d8bd5c14/</id>
    <published>2019-12-15T17:57:25.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>竟然真的有后续！！！</p><a id="more"></a><h3 id="选中区和剪贴板工具XClip"><a href="#选中区和剪贴板工具XClip" class="headerlink" title="选中区和剪贴板工具XClip"></a>选中区和剪贴板工具XClip</h3><p>XClip工具可以非常方便的操作，清空剪贴板，高效的复制粘贴等，直接从<code>apt</code>商店就可以直接安装(测试所用Ubuntu环境)。  </p><h4 id="输出选中区和剪贴板内容"><a href="#输出选中区和剪贴板内容" class="headerlink" title="输出选中区和剪贴板内容"></a>输出选中区和剪贴板内容</h4><p>选中区是指用鼠标选中区域的内容，在Ubuntu下有个快捷的复制粘贴方式就是利用选中区，通常鼠标中键是粘贴选中区内容。用xclip输出选中区内容命令:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">xclip -o</span></div></pre></td></tr></table></figure><p>如果要读取系统剪贴板的内容，可以加个参数:  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">xclip</span> -<span class="keyword">selection </span>clipboard -o</div></pre></td></tr></table></figure><p>或者简写为:  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">xclip</span> -<span class="keyword">sel </span>c -o</div></pre></td></tr></table></figure><p>输出到文件</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xclip -o &gt; <span class="built_in">file</span></div><div class="line">xclip -sel c -o &gt;<span class="built_in">file</span></div></pre></td></tr></table></figure><h4 id="读入到选中区和剪贴板"><a href="#读入到选中区和剪贴板" class="headerlink" title="读入到选中区和剪贴板"></a>读入到选中区和剪贴板</h4><p>平时用鼠标和<code>Ctrl C\V</code>或者<code>Ctrl Shift C\V</code>即可完成一般的复制粘贴，但有大量文字时，满满的移动鼠标就显得比较繁琐，利用<code>xlip</code>可以不借助鼠标比较方便的实现。  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xclip -<span class="selector-tag">i</span> file</div><div class="line">xclip -sel -c -<span class="selector-tag">i</span> file</div></pre></td></tr></table></figure><p>其他几种形式:  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">echo</span> <span class="string">"Hello Dog"</span> | xclip</div><div class="line"><span class="keyword">echo</span> <span class="string">"Hello Dog"</span> | xclip -sel <span class="keyword">c</span></div><div class="line">xclip &lt; <span class="keyword">file</span></div><div class="line">xclip -sel <span class="keyword">c</span> &lt; <span class="keyword">file</span></div><div class="line">xclip  <span class="keyword">file</span></div><div class="line">xclip -sel <span class="keyword">c</span>  <span class="keyword">file</span></div></pre></td></tr></table></figure><h3 id="图像转LaTeX工具Mathpix"><a href="#图像转LaTeX工具Mathpix" class="headerlink" title="图像转LaTeX工具Mathpix"></a>图像转LaTeX工具Mathpix</h3><p>可以将包含公式的图像直接转化为LaTeX语法。  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo snap <span class="keyword">install</span> mathpix-snipping-tool</div></pre></td></tr></table></figure><p>可以使用键盘快捷键 Ctrl+Alt+M 开始使用 Mathpix 截图,它会立即将图中公式转换为 LaTeX 语法并保存在剪贴板中。</p><p><img src="https://i.loli.net/2019/12/27/MsJof5VGjWBqHXA.png" alt="snip_sync_new.png"></p><p>然而现在开始收费了，免费版的一个月只能用50次。  </p><h3 id="广告拦截工具Pi-hole"><a href="#广告拦截工具Pi-hole" class="headerlink" title="广告拦截工具Pi-hole"></a>广告拦截工具Pi-hole</h3><p>与传统的浏览器广告拦截插件不同，声称是通过个人Linux硬件进行全网广告拦截，通过DNS污染实现，具体仓库<a href="https://github.com/pi-hole/pi-hole" rel="external nofollow noopener noreferrer" target="_blank">在此</a>。  </p><p><img src="https://pi-hole.github.io/graphics/Screenshots/blacklist-cli.gif" alt=""></p><p>安装方式很多，最直接就是curl直接拉脚本运行:  </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL <span class="string">https:</span><span class="comment">//install.pi-hole.net | bash</span></div></pre></td></tr></table></figure><p>安装完成后可以配置路由器来使所有的经过动态主机分配协议(DHCP)的主机使用Pi-hole作为其DNS服务器，来确保该网络所有的主机都可以进行广告拦截。配制方法<a href="https://discourse.pi-hole.net/t/how-do-i-configure-my-devices-to-use-pi-hole-as-their-dns-server/245" rel="external nofollow noopener noreferrer" target="_blank">在此</a>。</p><p>如果路由器不支持DNS设置，可以禁用DHCP后，使用Pi-hole的内置DHCP服务器。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;竟然真的有后续！！！&lt;/p&gt;
    
    </summary>
    
      <category term="Share" scheme="http://dfine.tech/categories/Share/"/>
    
    
      <category term="Mathpix" scheme="http://dfine.tech/tags/Mathpix/"/>
    
      <category term="Pi-hole" scheme="http://dfine.tech/tags/Pi-hole/"/>
    
      <category term="Xclip" scheme="http://dfine.tech/tags/Xclip/"/>
    
  </entry>
  
  <entry>
    <title>私有办公服务搭建</title>
    <link href="http://dfine.tech/posts/8c1f2c30/"/>
    <id>http://dfine.tech/posts/8c1f2c30/</id>
    <published>2019-12-13T05:47:12.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于Microsoft Office通常体积臃肿，而且只在Windows下能用。虽然LibOffice开源且免费，适用于各个平台，但碍于接触到的多是Microsoft Office的文档，打开时经常格式很乱，于是考虑搭建一种服务，可以在浏览器中处理文档，类似于Google Docs或者Office Online.  </p><a id="more"></a><h3 id="Office服务搭建"><a href="#Office服务搭建" class="headerlink" title="Office服务搭建"></a>Office服务搭建</h3><p>目前已经有比较优秀的<a href="http://www.dzzoffice.com/" rel="external nofollow noopener noreferrer" target="_blank">DzzOffice</a>了,而且开源，仓库地址<a href="https://github.com/zyx0814/dzzoffice" rel="external nofollow noopener noreferrer" target="_blank">在此</a>，可以<a href="http://demo.dzz.cc/" rel="external nofollow noopener noreferrer" target="_blank">在此</a>处查看演示。<br>可以自己搭建一个，另外该仓库也提供了Docker部署版本。克隆仓库之后直接使用<code>docker-compose up -d</code>即可部署。  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/zyx0814/dzzoffice.git</div><div class="line"><span class="keyword">cd</span> dzzoffice</div><div class="line">git checkout docker </div><div class="line">chmod <span class="number">777</span> -R data dzz config</div><div class="line">docker-compose <span class="keyword">up</span></div></pre></td></tr></table></figure><p>不过目前编译，会出现一些问题:</p><h4 id="Build-php-error"><a href="#Build-php-error" class="headerlink" title="Build php error:"></a>Build php error:</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ERROR: </span>http://dl-cdn.alpinelinux.org/alpine/v3.4/main: temporary error (try again later)`</div></pre></td></tr></table></figure><p>原因主要在两个方面： 一是本机Docker的DNS设置：  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim <span class="regexp">/etc/</span>docker<span class="regexp">/deamon.json</span></div></pre></td></tr></table></figure><p>将DNS修改正确；<br>另一个问题是alpine镜像的DNS问题，测试一下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">run</span> -it  --<span class="keyword">rm</span> php:7.1.0-fpm-alpine  <span class="keyword">sh</span> -c <span class="string">" ping dl-cdn.alpinelinux.org"</span></div></pre></td></tr></table></figure></p><p>显示<code>bad address</code>.</p><p>在php的Dockerfile中加一行，然后重启服务</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">run</span><span class="bash"> -it  --rm php:7.1.0-fpm-alpine  sh -c <span class="string">"echo nameserver 8.8.8.8 &gt; /etc/resolv.conf &amp;&amp; ping dl-cdn.alpinelinux.org"</span></span></div><div class="line"><span class="bash">sudo systemctl daemon-reload</span></div><div class="line"><span class="bash">sudo systemctl restart docker</span></div></pre></td></tr></table></figure><h4 id="Php-compose-error"><a href="#Php-compose-error" class="headerlink" title="Php compose error:"></a>Php compose error:</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">composer <span class="built_in">global</span> <span class="built_in">require</span> --<span class="literal">no</span>-progress <span class="string">"fxp/composer-asset-plugin:~1.2"</span></div><div class="line"></div><div class="line">[RuntimeException]</div><div class="line">No composer.json present <span class="keyword">in</span> the current directory, <span class="keyword">this</span> may be the cause <span class="keyword">of</span> the following exception.   </div><div class="line"></div><div class="line">[Composer<span class="string">\Downloader\TransportException]</span>   </div><div class="line"> Content-Length mismatch, received <span class="number">549815</span> bytes out <span class="keyword">of</span> the expected <span class="number">1180102</span></div></pre></td></tr></table></figure><p>同样修改Dockerfile，安装完<code>compose</code>之后，添加一行：  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer config -g repo<span class="selector-class">.packagist</span> composer https:<span class="comment">//packagist.phpcomposer.com</span></div></pre></td></tr></table></figure><h4 id="Build-pma-error"><a href="#Build-pma-error" class="headerlink" title="Build pma error:"></a>Build pma error:</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/bin/bash apk <span class="keyword">not</span> found</div></pre></td></tr></table></figure><p>可能是镜像更新了，里面用的ubuntu amd64环境，是<code>apt-get</code>安装，修改pma的Dockerfile，指定一个稍老的版本即可。  </p><p>至此，服务搭建成功。  </p><h3 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h3><p>数据库用户名和密码在部署环境之前，可以在<code>docker-compose.yml</code>中配置，然后在浏览器中打开<code>localhost</code>开始进行配置。  </p><p><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20191216111955.png" alt=""></p><p>登录之后，需要进行配置，添加应用，比如office，如添加onlyoffice，可以先装一个onlyoffice的服务:  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -<span class="selector-tag">i</span> -t -d --name onlyoffice -<span class="selector-tag">p</span> <span class="number">8000</span>:<span class="number">80</span> onlyoffice/documentserver</div></pre></td></tr></table></figure><p>然后在应用库中添加onlyoffice，设置api地址，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="regexp">//</span>YOUR_SERVER_ADDRESS:<span class="number">8000</span><span class="regexp">/web-apps/</span>apps<span class="regexp">/api/</span>documents<span class="regexp">/api.js</span></div></pre></td></tr></table></figure><p>然后就可以编辑文档了。  </p><p><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20191216112411.png" alt=""></p><h3 id="绘图服务部署"><a href="#绘图服务部署" class="headerlink" title="绘图服务部署"></a>绘图服务部署</h3><p>类似如Visio的工具，目前体验比较好的有<a href="https://draw.io" rel="external nofollow noopener noreferrer" target="_blank">DrawIO</a>，也是开源的，可以直接部署到自己的服务器上，在浏览器中绘图，快速轻便,易于分享。  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it --rm --name=<span class="string">"draw"</span> -<span class="selector-tag">p</span> <span class="number">8080</span>:<span class="number">8080</span> -<span class="selector-tag">p</span> <span class="number">8443</span>:<span class="number">8443</span> jgraph/draw.io</div></pre></td></tr></table></figure><p>在浏览器中打开指定端口地址即可开始绘制。<br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20191213141900.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鉴于Microsoft Office通常体积臃肿，而且只在Windows下能用。虽然LibOffice开源且免费，适用于各个平台，但碍于接触到的多是Microsoft Office的文档，打开时经常格式很乱，于是考虑搭建一种服务，可以在浏览器中处理文档，类似于Google Docs或者Office Online.  &lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="http://dfine.tech/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Docker" scheme="http://dfine.tech/tags/Docker/"/>
    
      <category term="Office" scheme="http://dfine.tech/tags/Office/"/>
    
      <category term="DzzOffice" scheme="http://dfine.tech/tags/DzzOffice/"/>
    
      <category term="DrawIO" scheme="http://dfine.tech/tags/DrawIO/"/>
    
  </entry>
  
  <entry>
    <title>小工具(一)</title>
    <link href="http://dfine.tech/posts/778cc776/"/>
    <id>http://dfine.tech/posts/778cc776/</id>
    <published>2019-08-18T17:57:25.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>太久没回来了，其实很多次想写但是无法静下心来，思绪如开始停更的三月里乱飞的柳絮，总感觉经历了很多，但却没有力气吐出一个字。终于处暑，昔时聚在一起的人们也已经走得差不多了，终于也想起了，该随便写点什么了。  </p><a id="more"></a><p>就推荐一些小工具吧，这段时间发现的，感觉挺有意思的。以后也不知道会不会继续，先假设是个连续剧吧，写完拖更的那种。    </p><h1 id="FlashCards"><a href="#FlashCards" class="headerlink" title="FlashCards"></a>FlashCards</h1><p>一个类似单词卡的小工具，也可以用来放代码，示例仓库<a href="https://github.com/jwasham/computer-science-flash-cards" rel="external nofollow noopener noreferrer" target="_blank">FlashCards</a><br>方法很简单，直接用Docker启动，可以放在自己的电脑上，也可以放在自己的服务器上，挂一个端口，然后可以Web端远程访问。另外，单词数据可以直接上传Github仓库，环境不需要。<br>这样随时随地，就是一个私人的Note？<br>搭好之后访问大概是这样:<br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190825211746.png" alt=""><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190825211917.png" alt=""></p><h1 id="终端美化LSD"><a href="#终端美化LSD" class="headerlink" title="终端美化LSD"></a>终端美化LSD</h1><p>主要功能是将Linux下的<code>ls</code>命令输出结果美化一下，不同的文件类型会有不同的图标，不过目前颜色还不支持修改。大概效果如下:<br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190825212556.png" alt=""></p><p>仓库地址<a href="https://github.com/Peltoche/lsd" rel="external nofollow noopener noreferrer" target="_blank">在此</a>。<br>不过需要安装<a href="https://github.com/ryanoasis/nerd-fonts/blob/master/readme.md" rel="external nofollow noopener noreferrer" target="_blank">NerdFonts</a>  </p><h1 id="Tree2dotx"><a href="#Tree2dotx" class="headerlink" title="Tree2dotx"></a>Tree2dotx</h1><p>就是将树形结构描述转化为DOT描述。 DOT语言是一种文本图形描述语言，可用于画有向无向图、流程图，语法比较简单，网上一搜就有，这里不做介绍。<br>比如将当前目录下的文件转成关系图，使用tree2dotx<a href="https://raw.githubusercontent.com/tinyclub/linux-0.11-lab/master/tools/tree2dotx" rel="external nofollow noopener noreferrer" target="_blank">工具</a>,命令为：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tree | tree2dotx &gt; <span class="keyword">out</span>.<span class="built_in">dot</span></div></pre></td></tr></table></figure></p><h1 id="Graphviz"><a href="#Graphviz" class="headerlink" title="Graphviz"></a>Graphviz</h1><p>Graphviz(Graph Visualization Software)是一个由AT&amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形,官网<a href="https://www.graphviz.org/" rel="external nofollow noopener noreferrer" target="_blank">在这</a>,可以从DOT文件生成图像，常见的有png/gif/svg等。<br>如果将之前的树形目录保存为关系图，只需要继续将上面的命令重定向即可。  </p><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tree | <span class="type">tree2dotx</span> | <span class="type">dot</span> -Tpng -o list.png</div></pre></td></tr></table></figure><p>保存为<code>list.png</code>文件，大致就是这个样子:  </p><p><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190825214302.png" alt=""></p><h1 id="Gprof"><a href="#Gprof" class="headerlink" title="Gprof"></a>Gprof</h1><p>一个代码性能分析工具，结合Gdb可以很方便的分析所写的代码。<br>主要方式是在使用gdb编译时加上<code>-pg</code>参数，然后正常运行程序，最后会出现一个<code>gmon.out</code>的文件，里面就是各个函数的信息。<br>结合Graphviz，可以得到函数关系调用图。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gprof -b ./<span class="keyword">test</span> gmon.<span class="keyword">out</span> | gprof2dot | dot -Tpng -o <span class="keyword">test</span>.png</div></pre></td></tr></table></figure></p><p>其中<code>gprof2dot</code>工具可以通过pip安装。<br>最后结果如下:  </p><p><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190825215411.png" alt=""><br>里面有各个函数调用次数、运行时间等情况，保存为svg也可以在浏览器中看。  </p><p>EMMMM, To be continued…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;太久没回来了，其实很多次想写但是无法静下心来，思绪如开始停更的三月里乱飞的柳絮，总感觉经历了很多，但却没有力气吐出一个字。终于处暑，昔时聚在一起的人们也已经走得差不多了，终于也想起了，该随便写点什么了。  &lt;/p&gt;
    
    </summary>
    
      <category term="Share" scheme="http://dfine.tech/categories/Share/"/>
    
    
      <category term="flashcards" scheme="http://dfine.tech/tags/flashcards/"/>
    
      <category term="lsd" scheme="http://dfine.tech/tags/lsd/"/>
    
      <category term="tree2dotx" scheme="http://dfine.tech/tags/tree2dotx/"/>
    
      <category term="graphviz" scheme="http://dfine.tech/tags/graphviz/"/>
    
      <category term="gprof" scheme="http://dfine.tech/tags/gprof/"/>
    
  </entry>
  
  <entry>
    <title>图床搭建</title>
    <link href="http://dfine.tech/posts/f7ade587/"/>
    <id>http://dfine.tech/posts/f7ade587/</id>
    <published>2019-03-26T15:48:00.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>周末回来发现博客里的图片全成了码云的个性403了，原来是因为很多公共的图床存活不了多少年，而且当图不再使用时，不便于回收，所以在图床选择这方面，纠结了很久。后来Github认为在其上传图片获取外链并不算滥用，但是Github在国内的速度比较慢，对于背景图来说，就是肉眼可见的卡了。好在当时发现了Coding和码云，于是在码云(Gitee)上用其Issue页上传图片做图床。<br>然而不幸的是，大概他们是觉得滥用了，于是被防盗链了。<br><a id="more"></a></p><h3 id="图床搭建"><a href="#图床搭建" class="headerlink" title="图床搭建"></a>图床搭建</h3><p>然后又像以前一样，对比了很多现有的图床，依然没找到能安心存放的地方。于是想到手里还有VPS，便打算搭建一个了。<br>最开始是一个同学送的天翼云，估计是办宽带送的，结果发现80和443端口全被封了，问客服说要备案才行，想着备案就备案吧，然而当看到备案要填的资料时，立马放弃了。<br>另一个就是Vultr上的，国外的云主机商相比于国内，条件限制宽了不少，不用动不动就实名或者备案，虽不会发表什么不当言论，但吃相看着令人难受。<br>现有图床挺多的，目前打算用一个开源的<a href="https://github.com/electerious/Lychee" rel="external nofollow noopener noreferrer" target="_blank">荔枝图床</a>,有现成的Docker镜像，界面比较美观，官网<a href="https://lychee.electerious.com/" rel="external nofollow noopener noreferrer" target="_blank">在这</a>。  </p><h4 id="Docker环境安装"><a href="#Docker环境安装" class="headerlink" title="Docker环境安装"></a>Docker环境安装</h4><p>其实云主机还好，如果觉得官方的Docker下载太慢，也有Daocloud的CDN加速的镜像，直接一条命令就可以完成:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL http<span class="variable">s:</span>//<span class="built_in">get</span>.daocloud.io/docker | <span class="keyword">sh</span></div></pre></td></tr></table></figure></p><p>等安装完成之后，就可以拉取镜像了，<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">docker</span> pull kdelfour/lychee-docke</div></pre></td></tr></table></figure></p><p>或者直接试运行，看看效果:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> -d -p <span class="number">80</span>:<span class="number">80</span> kdelfour/lychee-docke</div></pre></td></tr></table></figure></p><p>这时，在本地浏览器输入云主机的IP，就可以看到一个基本的界面了。<br>完整的命令是：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it -d -p <span class="number">80</span><span class="symbol">:</span><span class="number">80</span> -v /your-path/uploads/<span class="symbol">:/uploads/</span> -v /your-path/data/<span class="symbol">:/data/</span> -v /your-path/mysql/<span class="symbol">:/mysql/</span> kdelfour/lychee-docker</div></pre></td></tr></table></figure></p><p>分别挂载上传图片的<code>uploads</code>文件夹、<code>data</code>文件夹和数据库储存的<code>mysql</code>文件夹，并映射80端口。<br>这时候再登陆该地址，会提示要初始化一些配置，可以用官方提供的配置：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">url : localhost</div><div class="line">database name : lychee</div><div class="line">user name : lychee</div><div class="line">user password : lychee</div></pre></td></tr></table></figure></p><p>然后就是创建用户名和密码了，创建成功，图床已经初步建成。</p><p>但是现在直接做图床，看到的链接都是丑陋的IP和http字段组成的地址，干干巴巴，麻麻赖赖的，一点都不圆润。<br>所以接下来就要盘它了。一方面是IP更换为域名，另一方面是HTTP更换为更为安全的HTTPS。</p><h4 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h4><p>为IP申请一个域名，然后配置DNS，将域名直接以A类指向云主机IP即可。过一段时间应该就可以在本地看到域名解析生效：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">dig <span class="variable">$YourUrl</span></span></div></pre></td></tr></table></figure></p><p>然后直接在浏览器输入域名即可访问。</p><h3 id="HTTPS支持"><a href="#HTTPS支持" class="headerlink" title="HTTPS支持"></a>HTTPS支持</h3><p>要将HTTP转为HTTPS主要有两个步骤，一个是申请证书，一个是安装证书。</p><h4 id="SSL证书申请"><a href="#SSL证书申请" class="headerlink" title="SSL证书申请"></a>SSL证书申请</h4><p>偶然发现了<a href="https://freessl.cn/" rel="external nofollow noopener noreferrer" target="_blank">FreeSSL</a>这个网站，申请证书是真的方便，还有一个支持各大平台的客户端<a href="https://keymanager.org/" rel="external nofollow noopener noreferrer" target="_blank">KeyManager</a>，可以直接在里面申请Let’s Encrypt证书或者TrustAsia证书，一般前者半年，后者一年，因为比较懒，所以选后者。<br>在里面申请证书后，会有两种方法验证，一种是DNS验证，另一种是文件验证。<br>对于DNS验证，它会给你一串字符，让你到DNS解析设置里添加一个TXT解析，并粘贴为该字串。但是验证结果是香港和美国通过了，大陆总是验证失败，提示CNAME超时。因此选择文件验证了。<br>要将文件放在网站中进行验证，需要将其拷进Docker中，或者直接Docker容器中拷出来。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker cp <span class="variable">$YourContainer</span><span class="symbol">:/var/www/lychee/</span> www/lychee/</div></pre></td></tr></table></figure></p><p>然后将SSL验证文件放入该文件夹中重新挂载:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it -d -p <span class="number">80</span><span class="symbol">:</span><span class="number">80</span>  -v /root/images/uploads/<span class="symbol">:/uploads/</span> -v www/lychee/<span class="symbol">:/var/www/lychee/</span>  -v data/<span class="symbol">:/data/</span> -v mysql/<span class="symbol">:/mysql/</span> kdelfour/lychee-docker</div></pre></td></tr></table></figure></p><p>然后就可以验证成功了，之后可以生成证书并下载Nginx证书。</p><h4 id="Nginx配置修改"><a href="#Nginx配置修改" class="headerlink" title="Nginx配置修改"></a>Nginx配置修改</h4><p>接下来就是容器配置了，将HTTP转换为HTTPS。  </p><h5 id="SSL证书安装"><a href="#SSL证书安装" class="headerlink" title="SSL证书安装"></a>SSL证书安装</h5><p>首先将生成的证书放到网站的某个目录中，一个公钥和一个私钥。然后修改Docker容器的Nginx配置文件，也可以将其从容器中拷贝出来，再作修改：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp <span class="variable">$YourContainer</span><span class="symbol">:/etc/nginx/</span> nginx/</div></pre></td></tr></table></figure></p><p>然后进入<code>nginx/sites-enabled</code>目录，修改<code>lychee</code>文件。<br>加入HTTPS的端口以及SSL证书的地址：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">listen</span> <span class="number">443</span> ssl;</div><div class="line">     <span class="attribute">server_name</span> localhost;</div><div class="line">     <span class="attribute">keepalive_timeout</span>       <span class="number">70</span>;</div><div class="line"></div><div class="line">     <span class="attribute">ssl</span> <span class="literal">on</span>;</div><div class="line">     <span class="attribute">ssl_certificate</span> /etc/nginx/sslkey/server.pem;</div><div class="line">     <span class="attribute">ssl_certificate_key</span> /etc/nginx/sslkey/key.key;</div><div class="line">     <span class="attribute">ssl_protocols</span>   TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</div><div class="line">     <span class="attribute">ssl_ciphers</span>     HIGH:!aNULL:!MD5;</div></pre></td></tr></table></figure></p><h5 id="HTTP跳转"><a href="#HTTP跳转" class="headerlink" title="HTTP跳转"></a>HTTP跳转</h5><p>当使用HTTP访问时，直接跳转到HTTPS，有很多方法，这里使用497的错误码实现跳转：<br>在Nginx的Server配置中加上  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error_page<span class="number">497</span>https:<span class="regexp">//</span><span class="variable">$YourSite</span><span class="regexp">/</span></div></pre></td></tr></table></figure><p>然后重新挂载容器，此时需要指定HTTPS协议的443端口，以及Nginx配置文件目录：  </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it -d -p <span class="number">80</span><span class="symbol">:</span><span class="number">80</span> -p <span class="number">443</span><span class="symbol">:</span><span class="number">443</span> -v nginx/<span class="symbol">:/etc/nginx/</span>  -v uploads/<span class="symbol">:/uploads/</span> -v www/lychee/<span class="symbol">:/var/www/lychee/</span>  -v data/<span class="symbol">:/data/</span> -v mysql/<span class="symbol">:/mysql/</span> kdelfour/lychee-docker</div></pre></td></tr></table></figure><p>此时即可正常访问图床，示例如下：<br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190326234236.png" alt="imgcloud"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末回来发现博客里的图片全成了码云的个性403了，原来是因为很多公共的图床存活不了多少年，而且当图不再使用时，不便于回收，所以在图床选择这方面，纠结了很久。后来Github认为在其上传图片获取外链并不算滥用，但是Github在国内的速度比较慢，对于背景图来说，就是肉眼可见的卡了。好在当时发现了Coding和码云，于是在码云(Gitee)上用其Issue页上传图片做图床。&lt;br&gt;然而不幸的是，大概他们是觉得滥用了，于是被防盗链了。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://dfine.tech/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Blog" scheme="http://dfine.tech/tags/Blog/"/>
    
      <category term="图床" scheme="http://dfine.tech/tags/%E5%9B%BE%E5%BA%8A/"/>
    
      <category term="HTTPS" scheme="http://dfine.tech/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Git基本用法</title>
    <link href="http://dfine.tech/posts/29103606/"/>
    <id>http://dfine.tech/posts/29103606/</id>
    <published>2019-03-21T14:01:44.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>目前版本控制系统比较流行的就是SVN和Git了，相比较而言，Git有分布式的优势，对网络依赖性更低，但SVN简单，这一条就有很强的生存能力了。用Git已经好几年了，不过很长一段时间只是在用<code>clone pull add commit push</code>这些类<code>Ctrl+C/V</code>的命令(Office中)，连操作Head指针实现<code>Ctrl+Z/Y</code>都没怎么用，想起去年收到了Leancloud的<code>10X</code>程序员笔记本，里面附页还写着几行Git命令，突然觉得有些陌生了。  </p><a id="more"></a><p>也只是突然想到，回忆一下，当是补上多年前未肯作的笔记了。  </p><h3 id="基本文件操作"><a href="#基本文件操作" class="headerlink" title="基本文件操作"></a>基本文件操作</h3><h4 id="检查文件状态"><a href="#检查文件状态" class="headerlink" title="检查文件状态"></a>检查文件状态</h4><p>Git检查文件状态可以使用<code>git status</code>,可以看到已经提交的修改和未提交的修改:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">On branch master</div><div class="line">Your branch <span class="keyword">is</span> <span class="keyword">up</span> <span class="keyword">to</span> date with <span class="string">'origin/master'</span>.</div><div class="line"></div><div class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</div><div class="line"></div><div class="line">modified:   <span class="keyword">source</span>/_drafts/git.md</div><div class="line">modified:   <span class="keyword">source</span>/talks/<span class="built_in">index</span>.md</div><div class="line"></div><div class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</div><div class="line"></div><div class="line">modified:   <span class="keyword">source</span>/_drafts/git.md</div></pre></td></tr></table></figure></p><p>使用<code>git diff</code>可以查看尚未暂存的文件的修改:  </p><figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@@ -1,4 +1,26 @@</span></div><div class="line">...</div><div class="line"><span class="addition">+Git检查文件状态可以使用`git status`,可以看到已经提交的修改和未提交的修改:  </span></div><div class="line"><span class="addition">+On branch master</span></div><div class="line"><span class="addition">+Your branch is up to date with 'origin/master'.</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+Changes to be committed:</span></div><div class="line"><span class="addition">+  (use "git reset HEAD &lt;file&gt;..." to unstage)</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+       modified:   source/_drafts/git.md</span></div><div class="line"><span class="addition">+       modified:   source/talks/index.md</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+Changes not staged for commit:</span></div><div class="line"><span class="addition">+  (use "git add &lt;file&gt;..." to update what will be committed)</span></div><div class="line"><span class="addition">+  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+       modified:   source/_drafts/git.md</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+使用`git diff`可以勘察尚未暂存的文件的修改:  </span></div><div class="line">\ No newline at end of file</div></pre></td></tr></table></figure><p>另外加上<code>--cached</code>或者<code>--staged</code>(新版支持)参数，可以直接查看已暂存的和上次提交时的差异。<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">git diff --staged</div><div class="line">diff --git a/source/_drafts/git.md b/source/_drafts/git.md</div><div class="line"><span class="keyword">index</span> b220f55b..ce996f92 <span class="number">100644</span></div><div class="line">--- a/source/_drafts/git.md</div><div class="line">+++ b/source/_drafts/git.md</div><div class="line">@@ <span class="number">-1</span> +<span class="number">1</span>,<span class="number">4</span> @@</div><div class="line">-<span class="built_in">title</span>: Git用法</div><div class="line">+<span class="built_in">title</span>: Git基本用法</div><div class="line">+</div><div class="line">+目前版本控制系统比较流行的就是SVN和Git了，相比较而言，Git有分布式的优势，对网络依赖性更低，但SVN简单，这一条就有很强的生存能力了。用Git已经好几年了，不过很长一段时间只是在用<span class="symbol">`clone pull add commit push`</span>这些类<span class="symbol">`Ctrl+C/V`</span>的命令(Office中)，连操作Head</div><div class="line">指针实现<span class="symbol">`Ctrl+Z/Y`</span>都没怎么用，想起去年收到了Leancloud的<span class="symbol">`10X`</span>程序员笔记本，里面附页还写着几行Git命令</div><div class="line">+#</div><div class="line">\ No newline at <span class="keyword">end</span> of file</div><div class="line">diff --git a/source/talks/<span class="keyword">index</span>.md b/source/talks/<span class="keyword">index</span>.md</div><div class="line"><span class="keyword">index</span> d13db982.<span class="number">.63515</span>f47 <span class="number">100644</span></div></pre></td></tr></table></figure></p><h4 id="基本文件操作-1"><a href="#基本文件操作-1" class="headerlink" title="基本文件操作"></a>基本文件操作</h4><p>除去系统自带的<code>mv</code>或者<code>rm</code>命令，Git也有自己的<code>git mv</code>和<code>git rm</code>命令，在Git仓库中，后者不仅仅是对文件做了前者的操作，也在工作目录中做了前者的操作。<br>如<code>git rm</code>在删除文件后，也从跟踪文件清单中删除了该文件(使用<code>--cached</code>只是从暂存区中删除，使用<code>-f</code>同时也删除文件)，以后不会再跟踪该文件，而<code>rm</code>命令的操作记录依然会被记录在跟踪文件清单中。<br>一个简单的例子，先创建一个文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch <span class="built_in">test</span></div></pre></td></tr></table></figure></p><p>此时未放入暂存区，直接删除就可以，Git也不会记录，但是如果Git已经跟踪了该文件，则直接删除状态为:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">add</span> test </div><div class="line">rm test</div><div class="line">git status</div><div class="line"></div><div class="line">On branch master</div><div class="line">Your branch <span class="keyword">is</span> <span class="keyword">up</span> <span class="keyword">to</span> date with <span class="string">'origin/master'</span>.</div><div class="line"></div><div class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</div><div class="line">  </div><div class="line">modified:   <span class="keyword">source</span>/_drafts/git.md</div><div class="line"><span class="keyword">new</span> <span class="keyword">file</span>:   test</div><div class="line"></div><div class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></div><div class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</div><div class="line"></div><div class="line">modified:   <span class="keyword">source</span>/_drafts/git.md</div><div class="line">deleted:    test</div></pre></td></tr></table></figure></p><p>如果使用<code>git rm test</code>，可以看到:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">git rm test</div><div class="line">git status</div><div class="line"></div><div class="line">On branch master</div><div class="line">Your branch <span class="keyword">is</span> <span class="keyword">up</span> <span class="keyword">to</span> date with <span class="string">'origin/master'</span>.</div><div class="line"></div><div class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</div><div class="line"></div><div class="line">modified:   <span class="keyword">source</span>/_drafts/git.md</div><div class="line"></div><div class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</div><div class="line"></div><div class="line">modified:   <span class="keyword">source</span>/_drafts/git.md</div></pre></td></tr></table></figure></p><p>可以看到，<code>test</code>文件的记录已经被删除了。<br>同样，<code>git mv</code>也是一样的类型，<code>git mv file1 file2</code>相当于:<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mv file1 file2</div><div class="line">git rm file1</div><div class="line">git <span class="keyword">add</span><span class="bash"> file2</span></div></pre></td></tr></table></figure></p><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p>查看每次的提交历史可以直接使用<code>git log</code>，可以看到每次的提交记录。另外，加上<code>-p</code>参数可以展开每次提交的内容差异，加上<code>-{d}</code>可以指定显示最近次数的差异，如<code>-2</code>显示最近两次提交的差异。加上<code>--since</code>或者<code>--until</code>可以限制时间查询，如可以用<code>git long --since=2.weeks</code>显示最近两周的修改。加上<code>--word-diff</code>可以进行单词层面的对比，加上<code>--graph</code>以<code>ASCII</code>图形表示的分支合并历史。如果只想看每次提交的简略信息，可以加上<code>-stat</code>参数。另外，可以使用<code>--pretty</code>指定展示提交历史的格式，如用<code>oneline</code>将每个提交放在一行显示(<code>--pretty</code>常用参数有<code>oneline，short，full，fuller和format(后跟指定格式)</code>)。</p><h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><h5 id="仅修改提交信息"><a href="#仅修改提交信息" class="headerlink" title="仅修改提交信息"></a>仅修改提交信息</h5><p>如果提交信息写错了，或者有些文件漏掉了未添加到暂存区，可以使用<code>amend</code>指令重新提交:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">commit</span> -m <span class="string">"add test"</span></div><div class="line">git <span class="keyword">add</span> <span class="keyword">test</span></div><div class="line">git <span class="keyword">commit</span> <span class="comment">--amend</span></div></pre></td></tr></table></figure></p><p>这样就完成了提交信息的修改。  </p><h5 id="取消暂存区文件"><a href="#取消暂存区文件" class="headerlink" title="取消暂存区文件"></a>取消暂存区文件</h5><p>如果想取消暂存区的某个文件的暂存，有两种方法。一是上面的<code>git rm --cached</code>直接将文件从暂存区中删除，实际文件不受影响。另外一个是<code>HEAD</code>指针的操作。<br><code>HEAD</code>可以理解为指向当前分支的指针，指向该分支最近一次的调用，操作<code>HEAD</code>指针即可实现版本回退等操作。<br>这里直接使用<code>reset</code>命令，将某个文件重置到最近一次提交时的状态:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">reset</span> <span class="keyword">HEAD</span> <span class="keyword">test</span></div></pre></td></tr></table></figure></p><p>因为上次<code>test</code>未暂存，所以相当于从暂存区中取消该文件。  </p><h5 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h5><p>使用<code>git checkout -- file</code>可以撤销上次提交以来，对某个文件的所有修改，本质上是拷贝了上次提交时的该文件来覆盖它，因此对该文件做的任何修改都会消失。该命令需要谨慎使用，最好的方式是通过分支的保存进度来恢复。<br>Git中所有已经提交的东西基本上都是可以恢复的，但未暂存的就不属于Git恢复的范畴了。  </p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>Git主要是在本地修改好了再推送到远程仓库，实际上对远程仓库的操作比较少，就一些基本的推拉行为。  </p><ol><li>查看远程仓库。<br>直接使用<code>git remote</code>即可查看当前的远程仓库，加上<code>-v</code>选项可以以详细模式查看。  </li><li>添加远程仓库。<br>直接使用<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>，将仓库名和地址添加即可。  </li><li>从远程仓库抓取数据。<br>有两种需求，一种是只从远程仓库拉取数据，但并不合并到当前分支，可以使用<code>git fetch &lt;remotename&gt;</code>命令。<br>另外，使用<code>git clone</code>获取的远程仓库会自动归于<code>origin</code>名下。<br>另一种，需求是自动抓取并合并到当前分支，可以使用<code>git pull</code>命令。  </li><li>推送数据到远程仓库。<br>基本操作，<code>git push &lt;remotename&gt; &lt;branch&gt;</code>。  </li><li><p>查看远程仓库信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote <span class="keyword">show</span> &lt;remote-<span class="keyword">name</span>&gt;</div></pre></td></tr></table></figure></li><li><p>远程仓库的删除和重命名。</p></li></ol><ul><li>删除远程仓库:  <code>git remote rm &lt;remotename&gt;</code></li><li>重命名远程仓库： <code>git remote rename &lt;orignname&gt; &lt;newname&gt;</code></li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>Git可以给历史中的某个提交打上标签，以示其重要性，如<code>v1.0</code>等。</p><h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h4><p>列出已有标签，可以直接使用<code>git tag</code>命令，加上<code>-l</code>参数可以过滤选项。如  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">tag</span> <span class="title">-l</span> 'v1.<span class="number">0.1</span>*'</div></pre></td></tr></table></figure><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>标签分为轻量标签和附注标签，轻量标签如其名轻量，只是一个特定提交的引用，本质上是将提交校验和存储到一个文件中，没有保存其他任何信息，因此创建也比较简单。附注标签则是Git数据库中的一个完整对象，是可以被校验的。附注标签通常包含打标签者的姓名、邮件地址、日期、标签信息等，并可以使用GPG(GNU Privacy Guard)签名及验证。</p><ul><li>创建附注标签: 最简单的方式是使用<code>tag</code>的<code>-a</code>选项:  </li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">1</span> -m <span class="string">"new test version"</span></div></pre></td></tr></table></figure><p>查看标签:<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">tag</span> <span class="title"></span></div><div class="line"><span class="title">v1</span>.<span class="number">0</span></div><div class="line">v1.<span class="number">1</span></div></pre></td></tr></table></figure></p><p>其中，<code>-m</code>是存储在标签中的信息，是必填内容。使用<code>git show</code>也可以看到标签信息与对应的提交信息。  </p><ul><li>创建轻量标签: 轻量标签的创建不需要任何选项，直接提供标签名字即可。  </li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">tag</span> <span class="title">v1</span>.<span class="number">11</span></div></pre></td></tr></table></figure><p>查看标签:<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">tag</span></div><div class="line">v1.<span class="number">0</span></div><div class="line">v1.<span class="number">1</span></div><div class="line">v1.<span class="number">11</span></div></pre></td></tr></table></figure></p><p>此时用<code>git show</code>只能看到标签的提交信息，没有额外信息。  </p><h4 id="后期上标签"><a href="#后期上标签" class="headerlink" title="后期上标签"></a>后期上标签</h4><p>也可以对过去的提交上标签，使用<code>git log --pretty=oneline</code>时可以看到每次提交的校验和，如某次校验和是<code>e0c29751bf13be3df3b5030cc589685752bd9fb6</code>,则可以通过该校验和给该次提交打上标签:<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">tag</span> <span class="title">-a</span> v0.<span class="number">8</span> e0c2975</div></pre></td></tr></table></figure></p><p>实际只需要部分校验和即可。  </p><h4 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h4><p>通常情况，<code>git push</code>并不会将标签推送到服务器上，需要通过显示命令才能分享标签到远程仓库。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> &lt;tagname&gt;</div></pre></td></tr></table></figure></p><p>如果要一次性推送所有本地新增标签到服务器上，则可以使用<code>--tags</code>参数:<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</div></pre></td></tr></table></figure></p><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><p>删除本地仓库的标签，可以使用:<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">tag</span> <span class="title">-d</span> <span class="tag">&lt;tagname&gt;</span></div></pre></td></tr></table></figure></p><p>如果要同时删除远程标签，则需要使用<code>git push &lt;remotename&gt; :refs/tags/&lt;tagname&gt;</code>来更新远程仓库标签。  </p><h4 id="标签检出"><a href="#标签检出" class="headerlink" title="标签检出"></a>标签检出</h4><p>可以使用<code>git checkout</code>命令查看某个标签指向的文件版本。但会使仓库处于头指针分离(“detacthed HEAD”)的状态：在”头指针分离“状态下，如果做了某些更改然后提交他们，标签不会发生变化，但新的提交不属于任何分支，也无法访问，除非确切的提交哈希。所以如果要进行更改，通常需要创建一个新分支:<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout -b <span class="keyword">new</span><span class="type">version</span> v1<span class="number">.12</span> </div><div class="line">Switched to a <span class="keyword">new</span> <span class="type">branch</span> <span class="string">'newversion'</span></div></pre></td></tr></table></figure></p><p>如果继续对<code>newversion</code>分支做改动，该分支的提交指针会继续向前移动，就不是原来的<code>v1.12</code>标签了。  </p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>Git好用很大原因是其极具优势的分支模型，使得分支处理方式更为轻量。<br>在使用<code>git commit</code>新建一个提交对象前，Git会先计算每一个子目录的校验和，然后在Git仓库将这些目录保存为一个Tree对象，然后就可以创造一个提交对象，并包含了指向这个Tree对象的指针。Git使用blob类型的对象存储此次保存的快照。<br>关于Git的树结构，可以用Git官方仓库中的一张图说明:<br><img src="https://git-scm.com/book/en/v2/images/commit-and-tree.png" alt=""><br>这是首次提交后的结构图，此时Git仓库中有五个对象(五个校验和)，最右侧的是三个存储文件快照的blob对象，中间是记录目录结构和blob对象索引的树对象，最左侧是包含指向书对象的指针和所有提交信息的提交对象。<br>此时因为是第一次提交，相当于祖先提交，提交对象中没有父对象，但之后的所有提交对象中，都会多一个父对象指针，指向上次提交。<br><img src="https://git-scm.com/book/en/v2/images/commits-and-parents.png" alt=""><br>Git分支在本质上是一个指向最新提交对象的指针，每次提交操作之后，指针都会更新到最新提交。  </p><blockquote><p>分支就是某个提交对象往回看的历史。  </p></blockquote><p>使用<code>git branch</code>可以列出所有的分支，加上<code>--merged</code>或<code>--no-merged</code>可以显示已合并或未合并的分支。  </p><h4 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h4><p>Git使用<code>master</code>作为默认的分支名，如果要创建分支，可以使用<code>branch</code>选项。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">git</span> <span class="keyword">branch </span>&lt;<span class="keyword">branchname&gt;</span></div></pre></td></tr></table></figure></p><p>但此时只是新建了一个分支，并未将当前工作分支切换过去。Git确定当前工作的分支是使用<code>HEAD</code>指针，HEAD指针指向哪个分支，当前就在哪个分支工作。<br><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt=""><br>也可以使用<code>git log -decorate</code>命令查看各个分支当前所指的对象。   </p><h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p>切换分支即修改<code>HEAD</code>指针指向，可以使用<code>chenkout</code>命令实现。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout <span class="tag">&lt;<span class="name">branchname</span>&gt;</span></div></pre></td></tr></table></figure></p><p>在每次提交后，<code>HEAD</code>指针会随着当前分支一起向前移动以保证以后分支能正确切换回来。<br>或者直接使用命令:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -<span class="selector-tag">b</span> &lt;branchname&gt;</div></pre></td></tr></table></figure></p><p>可以在新建分支的同时切换到该分支，<code>-b</code>可以理解为<code>branch</code>，相当于:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">git</span> <span class="keyword">branch </span>&lt;<span class="keyword">branchname&gt;</span></div><div class="line"><span class="keyword">git </span>checkout &lt;<span class="keyword">branchname&gt;</span></div></pre></td></tr></table></figure></p><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>在某个分支上进行操作，使得该分支指针向前移动后，如果要将该分支合并到其他分支，则可以切换到其他分支进行<code>merge</code>操作:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge <span class="tag">&lt;<span class="name">branchname</span>&gt;</span></div></pre></td></tr></table></figure></p><p>当两个分支没有需要解决的分歧时，可以直接合并。  </p><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>当分支不再使用时，可以删除:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-d &lt;<span class="keyword">branchname&gt;</span></div></pre></td></tr></table></figure></p><p>对于未合并的分支，直接删除会失败，可以使用<code>-D</code>强制删除。  </p><h4 id="冲突合并"><a href="#冲突合并" class="headerlink" title="冲突合并"></a>冲突合并</h4><p>如果合并的两个分支，并不是直接祖先关系，两个分支在其共同祖先分支上都做了修改，如果修改没有冲突，如修改的都是不同的文件，则Git会自动新建一个提交，将共同祖先分支以及两个要合并的分支共同合并建立一个新的提交。此时Git会自行决定选取哪个提交作为最优的共同祖先。<br>但是如果两个不同分支都对同一个文件做了修改，在合并时就会引起冲突，因为Git不知道到底该对这个文件做如何操作。此时Git会先暂停下来，等待用户解决冲突。这种情况在平时也经常会遇到，如在本地对某个远程仓库做了修改，但是远程仓库在此之前已经在另一台电脑上做了<code>push</code>操作，这时使用<code>pull</code>操作就会自动抓取并合并到当前分支，如果存在冲突，<code>pull</code>时就会提示哪个文件修改冲突，并等待用户解决。此时，可以使用<code>git status</code>查看状态。<br>解决冲突后可以重新使用<code>git add</code>将其标记为冲突已解决。  </p><h4 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h4><p><strong>远程引用</strong>是指向远程仓库的指针，包括分支、标签等，可以通过<code>git ls-remote &lt;remotename&gt;</code>查看远程引用的完整列表，或者通过<code>git remote show &lt;remote&gt;</code>查看远程分支的更多信息。<br><strong>远程跟踪</strong>则是指向远程分支状态的引用，只有当与远程仓库通信时，它们会自动移动。用户无法手动修改其状态。<br>可以使用<code>git fetch</code>命令将远程仓库中的内容拉取到本地，同事远程跟踪会更新到新的远程分支状态。当本地与远程的工作出现分叉之后，合并到本地分支时，依然会考虑是否有冲突的问题，解决方式和其他冲突分支合并一样。  </p><h5 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h5><p>使用<code>git push</code>将本地分支推送到远端:<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> test</div></pre></td></tr></table></figure></p><p>等价于<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">push</span> origin <span class="keyword">test</span>:<span class="keyword">test</span></div></pre></td></tr></table></figure></p><p>Git会自动将<code>test</code>名字展开为<code>refs/heads/test:refs/heads/test</code>。  </p><h5 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h5><p>使用<code>checkout</code>可以实现对分支的跟踪：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout --<span class="built_in">track</span> <span class="built_in">origin</span>/test</div></pre></td></tr></table></figure></p><p>通常可以新建一个本地分支来跟踪拉取的远程分支:<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b <span class="built_in">sf</span> <span class="built_in">origin</span>/test</div></pre></td></tr></table></figure></p><p>也可以使用<code>-u</code>或<code>--set-upstream-to</code>选项来直接设置已有的本地分支来跟踪拉取的远程分支:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-u origin/test</div></pre></td></tr></table></figure></p><p>另外，可以使用<code>git branch -vv</code>命令查看设置的所有跟踪分支。  </p><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><p>可以使用<code>git fetch</code>拉取分支后再使用<code>git merge</code>合并到本地分支，也可以直接使用<code>git pull</code>拉取并合并到本地分支。但是有时候<code>git pull</code>会显得有些佛性，难以理解，最简单的方式是<code>fetch</code>与<code>merge</code>的组合。  </p><h5 id="删除分支-1"><a href="#删除分支-1" class="headerlink" title="删除分支"></a>删除分支</h5><p>删除远程分支可以使用:<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> --<span class="built_in">delete</span> test</div></pre></td></tr></table></figure></p><p>或者直接将空分支推送到远端覆盖远端分支即可：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin <span class="symbol">:&lt;remotebranch&gt;</span></div></pre></td></tr></table></figure></p><h4 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h4><p>这个是个有趣的用法，自从有了变基，<code>Github</code>就变成了<code>Gayhub</code> (逃 <img class="github-emoji" style="display:inline;vertical-align:bottom;padding:0px;border:0px solid rgba(0, 0, 0, 0);border-bottom:4px solid rgba(221, 221, 221, 0)" title="stuck_out_tongue_winking_eye" alt="stuck_out_tongue_winking_eye" src="https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8" height="20" width="20"> )。<br>啊呸！当然不是这个原因。<br>变基是一种整合分支的方法，通常整合分支有两种方法：合并和变基。<br>合并(<code>merge</code>)之前已经经常用到了，主要就是将一个分支合并到另一个上。而变基(<code>rebase</code>)则是将一个分支里提交的修改在另一个分支上重放一边，也就是走别人的路，让别人说去吧。<br>一个基本的例子如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout bra<span class="symbol">nch1</span></div><div class="line">git rebase bra<span class="symbol">nch2</span></div></pre></td></tr></table></figure></p><p>此时，Git会先找到这两个分支的分叉点（即最近共同祖先），然后从分叉点开始，将<code>branch1</code>所经历的操作，给<code>branch2</code>也体验一下。然后回到<code>branch2</code>,进行一次快进合并：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout bra<span class="symbol">nch2</span></div><div class="line">git merge bra<span class="symbol">nch1</span></div></pre></td></tr></table></figure></p><p>其实就这个例子来看，变基和合并没有任何区别，但这样可以保证在向远程分支推送时保持提交历史的简洁。<br>另外，变基可以放到其他分支进行，并不一定非得依据分化之前的分支。可以从一个特性分支里再分出一个特性分支，然后跳过前面的特性分支，将后者与主分支进行变基，可以使用<code>--onto</code>选项。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebash --onto <span class="keyword">master</span> <span class="title">branch1</span> branch2</div></pre></td></tr></table></figure></p><p>即取出<code>branch2</code>分支，找到<code>branch1</code>和<code>branch2</code>的分离点，然后在<code>master</code>分支上重放其共同祖先之后的修改。<br>然后就可以将变基后的分支快进合并到<code>master</code>分支上:<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout <span class="literal">master</span></div><div class="line">git merge branch2</div></pre></td></tr></table></figure></p><p>剩下的也可以将<code>branch1</code>合并到<code>master</code>中:<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase <span class="keyword">master</span> <span class="title">branch1</span></div></pre></td></tr></table></figure></p><p>然后快进合并<code>master</code>分支:<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout <span class="literal">master</span></div><div class="line">git merge branch1</div></pre></td></tr></table></figure></p><p>之后就可以删除无用的分支了。  </p><h5 id="变基风险"><a href="#变基风险" class="headerlink" title="变基风险"></a>变基风险</h5><p>因为人人都可以编辑，所以一旦分支中的对象提交发布到公共仓库，就千万不要对该分支进行变基，不然其他人不得不重新将手里的工作和你的提交进行整合，接下来你也要重新拉取他们的提交进行整合，引入太多不必要的麻烦。<br>总之用官方一句加粗的话说:  </p><blockquote><p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p></blockquote><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>和Linux的<code>alias</code>命令一样的意思，也是方便在git中快速操作。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git<span class="built_in"> config </span>--global alias.co checkout</div><div class="line">$ git<span class="built_in"> config </span>--global alias.br branch</div><div class="line">$ git<span class="built_in"> config </span>--global alias.ci commit</div><div class="line">$ git<span class="built_in"> config </span>--global alias.st status</div></pre></td></tr></table></figure></p><p>设置别名后，通过 <code>git co</code>即可实现<code>git checkout</code>命令。  </p><h4 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h4><p>当不想提交现在的工作状态，又想切换到别的分支进行工作，可以先将当前状态出藏起来。储藏(Stash)可以获取工作目录的中间状态——也就是修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。<br>使用<code>git stash list</code>可以查看当前储藏的列表。<br>如果之后要恢复储藏的状态，可以使用：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash <span class="built_in">apply</span></div></pre></td></tr></table></figure></p><p>Git则会默认恢复最近一次的储藏，如果想应用更早的储藏，则可以通过名字指定，如：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash <span class="built_in">apply</span> stash@&#123;<span class="number">2</span>&#125;</div></pre></td></tr></table></figure></p><p>此时对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。可以通过运行<code>git stash apply</code>命令时带上一个<code>--index</code>的选项来告诉命令重新应用被暂存的变更。<br><code>apply</code>选项只尝试应用储藏的工作,但储藏的栈上仍然有该储藏。可以通过运行<code>git stash drop</code>，加上希望移除的储藏的名字来移除该储藏，或者直接通过<code>git stash pop</code>来重新应用储藏并在此之后快速删除栈上的储藏。  </p><h5 id="取消储藏"><a href="#取消储藏" class="headerlink" title="取消储藏"></a>取消储藏</h5><p>如果要取消之前所应用的储藏的修改，可以通过取消该储藏的补丁达到该效果:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash show -p stash@&#123;<span class="number">0</span>&#125; | <span class="type">git</span> <span class="built_in">apply</span> -R</div></pre></td></tr></table></figure></p><p>如果没有指定储藏名称，则会自动选择最近的储藏:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash show -p | <span class="type">git</span> <span class="built_in">apply</span> -R</div></pre></td></tr></table></figure></p><h5 id="从储藏中创建分支"><a href="#从储藏中创建分支" class="headerlink" title="从储藏中创建分支"></a>从储藏中创建分支</h5><p>在储藏一个工作状态后，继续在该分支上工作，最后还原储藏的时候可能会引起合并冲突，此时可以新建一个储藏分支简化工作。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">git</span> stash <span class="keyword">branch </span>&lt;<span class="keyword">branchname&gt;</span></div></pre></td></tr></table></figure></p><p>此时Git会创建一个新的分支，检出储藏工作时的所处的提交，重新应用，如果成功，则丢弃储藏。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前版本控制系统比较流行的就是SVN和Git了，相比较而言，Git有分布式的优势，对网络依赖性更低，但SVN简单，这一条就有很强的生存能力了。用Git已经好几年了，不过很长一段时间只是在用&lt;code&gt;clone pull add commit push&lt;/code&gt;这些类&lt;code&gt;Ctrl+C/V&lt;/code&gt;的命令(Office中)，连操作Head指针实现&lt;code&gt;Ctrl+Z/Y&lt;/code&gt;都没怎么用，想起去年收到了Leancloud的&lt;code&gt;10X&lt;/code&gt;程序员笔记本，里面附页还写着几行Git命令，突然觉得有些陌生了。  &lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://dfine.tech/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://dfine.tech/tags/Linux/"/>
    
      <category term="Git" scheme="http://dfine.tech/tags/Git/"/>
    
      <category term="版本控制" scheme="http://dfine.tech/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Telegram接管聊天消息</title>
    <link href="http://dfine.tech/posts/b03b049f/"/>
    <id>http://dfine.tech/posts/b03b049f/</id>
    <published>2019-03-20T14:49:44.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>虽有Web微信的简陋功能，虽有electronic的外观封装，但每次登陆实在太麻烦，以及很多功能被限制，表情无法接收等，被鹅厂放弃的Linux用户对微信的体验大概确实不好。<br><a id="more"></a></p><h3 id="关于Telegram"><a href="#关于Telegram" class="headerlink" title="关于Telegram"></a>关于Telegram</h3><p>关于Telegram(电报)，直接引用<a href="https://zh.wikipedia.org/wiki/Telegram" rel="external nofollow noopener noreferrer" target="_blank">维基</a>上的介绍:  </p><blockquote><p>Telegram是一个跨平台的即时通信软件，它的客户端是自由及开放源代码软件，但是它的服务器是专有软件。用户可以相互交换加密与自毁消息，发送照片、影片等所有类型文件。官方提供手机版（Android、iOS、Windows Phone）、桌面版（Windows、macOS、Linux）和网页版等多种平台客户端；同时官方开放应用程序接口，因此拥有许多第三方的客户端可供选择，其中多款内置中文。</p></blockquote><p>这个是俄国的社交服务VK的创始者杜洛夫兄弟的作品，Telegram Messenger LLP是独立的非营利公司，与VK也没啥关系，所有的宗旨只在于保证聊天和隐私安全。但不接受监管的软件通常过的不是太好，追求绝对的隐私安全，以至于其在各个国家遭受了被封锁的命运。其他国家暂且不论，因为不肯交出密钥，连俄罗斯媒体监管机构都请求法庭再全国范围内封锁该软件。抛开这些原因不谈，就技术方面，其良好的功能体验，开源的客户端以及开放的应用程序接口，已经领先于绝大多数同类APP了。<br>Tencent基本是属于放弃Linux用户的一类，后来新注册的微信号连网页版都无法使用，虽然嫌弃通常是相互的，但微信之类的产品用的人太多，粘性太大，有时候不得不用其交流，等网页版每次都要扫一下也是麻烦，所以直接使用Telegram的机器人来收发微信消息。  </p><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><p>聚合社交平台这方面，<a href="https://github.com/blueset/ehForwarderBot" rel="external nofollow noopener noreferrer" target="_blank">EFB</a>做的不错，而且也有了现成的Docker镜像（由royx提供），使得环境搭建更为简单。<br>另外，需要一台能访问外网的主机，主要是能访问TG(Telegram)服务器。<br>然后安装Docker:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL http<span class="variable">s:</span>//<span class="built_in">get</span>.daocloud.io/docker | <span class="keyword">sh</span></div></pre></td></tr></table></figure></p><p>安装好之后，就可以拉取镜像了:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">docker</span> pull royx/docker-efb</div></pre></td></tr></table></figure></p><h3 id="配置TG-Bot"><a href="#配置TG-Bot" class="headerlink" title="配置TG Bot"></a>配置TG Bot</h3><p>主要方式是通过登陆网页版微信，然后将微信消息通过Bot发送及接受。首先需要配置TG Bot:  </p><ol><li>搜索并找到<code>@botfather</code>机器人，然后发送指令:<code>/newbot</code></li><li>给Bot起个名字。</li><li>给机器人起用户名，以<code>bot</code>结尾</li><li>获取机器人的Token</li><li>设置Bot隐私权限: 默认Bot可能无法接收非<code>/</code>开头的消息，所以需要设置隐私权限。向该机器人发送指令<code>/setprivacy</code>，选择刚刚创建的机器人，点<code>Disable</code>即可。  </li><li>允许将Bot添加进群组: 给机器人发送指令<code>/setjoingroups</code>,选择enable。</li><li>允许Bot提供指令列表: 给机器人发送指令<code>/setcommand</code>，输入以下内容：  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">help - 显示命令列表.</div><div class="line">link - 将远程会话绑定到 Telegram 群组</div><div class="line">chat - 生成会话头</div><div class="line">recog - 回复语音消息以进行识别</div><div class="line">info - 显示当前 Telegram 聊天的信息.</div><div class="line">unlink_all - 将所有远程会话从 Telegram 群组解绑.</div><div class="line">update_info - 更新群组名称和头像</div><div class="line">extra - 获取更多功能</div></pre></td></tr></table></figure></li></ol><h3 id="获取TG-ID"><a href="#获取TG-ID" class="headerlink" title="获取TG ID"></a>获取TG ID</h3><p>搜索另外一个机器人<code>@get_id_bot</code>，点击<code>start</code>即可获得TG ID。  </p><h3 id="配置EFB"><a href="#配置EFB" class="headerlink" title="配置EFB"></a>配置EFB</h3><p>新建一个<code>config.py</code>文件保存机器人信息，输入以下内容:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">master_channel = <span class="string">'plugins.eh_telegram_master'</span>, <span class="string">'TelegramChannel'</span></div><div class="line">slave_channels = [(<span class="string">'plugins.eh_wechat_slave'</span>, <span class="string">'WeChatChannel'</span>)]</div><div class="line"></div><div class="line">eh_telegram_master = &#123;</div><div class="line">    <span class="string">"token"</span>: <span class="string">"12345678:QWFPGJLUYarstdheioZXCVBKM"</span>,</div><div class="line">    <span class="string">"admins"</span>: [<span class="number">13456782</span>],</div><div class="line">    <span class="string">"bing_speech_api"</span>: [<span class="string">"xxx"</span>, <span class="string">"xxx"</span>],</div><div class="line">    <span class="string">"baidu_speech_api"</span>: &#123;</div><div class="line">        <span class="string">"app_id"</span>: <span class="number">0</span>,</div><div class="line">        <span class="string">"api_key"</span>: <span class="string">"xxx"</span>,</div><div class="line">        <span class="string">"secret_key"</span>: <span class="string">"xxx"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在其中输入之前所获得的token，以及将admin后的内容换成TG ID。其余<code>xxx</code>的内容是语音识别API，想要的可以申请，没有的也无所谓。<br>然后新建一个<code>tgdata.db</code>文件，为空即可。</p><h3 id="启动EFB容器"><a href="#启动EFB容器" class="headerlink" title="启动EFB容器"></a>启动EFB容器</h3><p>指定配置文件和数据文件的地址，启动容器:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run -d --restart=always --name=ehforwarderbot \</div><div class="line">        -v $(pwd)/config<span class="selector-class">.py</span>:/opt/ehForwarderBot/config<span class="selector-class">.py</span> \</div><div class="line">        -v $(pwd)/tgdata<span class="selector-class">.db</span>:/opt/ehForwarderBot/plugins/eh_telegram_master/tgdata<span class="selector-class">.db</span> \</div><div class="line">        royx/docker-efb</div></pre></td></tr></table></figure></p><p>然后通过<code>docker logs</code>查看容器输出内容，应该可以看到一个二维码，用微信扫一扫即可登录。  </p><h3 id="机器人使用"><a href="#机器人使用" class="headerlink" title="机器人使用"></a>机器人使用</h3><p>登陆成功即可正常使用机器人收发微信消息，默认情况下，所有的微信消息以及公众号消息，全都是通过那个机器人发送的，看起来会比较乱。<br>如果需要单独跟某个人聊天，一种方法是在你创建的机器人中发送<code>/chat 好友名</code>，然后机器人会给一段消息，回复那个消息就可以将消息发送给指定的联系人。但是略显麻烦，聊天不多的人可以这样。<br>另一种方法是单读创建一个TG群组，然后将名称命名为你要聊天的好友名，将机器人拉进来。然后向你所创建的机器人发送指令<code>/link 好友名</code>，将与该好友的聊天绑定到你所创建的群组中，即可如微信一般发送以及接收消息，且可以发送TG的自定义贴纸表情。  </p><h3 id="后加-接管QQ消息"><a href="#后加-接管QQ消息" class="headerlink" title="(后加)接管QQ消息"></a>(后加)接管QQ消息</h3><p>此外，使用EFB工具也可以托管QQ消息，方法挺多，这里依然采用最简单的容器方法。<br>和接管微信消息一样，需要创建一个机器人获取Token，也可以就用微信机器人，不过为了方便管理，就直接另外创建一个机器人了。<br>然后直接使用EFB和酷Q的<code>efb-qq-coolq-docker</code>项目中的配置，仓库<a href="https://github.com/Earth-Online/efb-qq-coolq-docker" rel="external nofollow noopener noreferrer" target="_blank">在这</a>.<br>然后修改两个配置文件:  </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vim ehforward_config<span class="regexp">/profiles/</span><span class="keyword">default</span><span class="regexp">/blueset.telegram/</span>config.yaml</div><div class="line"></div><div class="line"><span class="string">token:</span> <span class="string">"你的机器人token"</span></div><div class="line"><span class="string">admins:</span></div><div class="line">- 你的tgid</div></pre></td></tr></table></figure><p>和  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim docker-compose.yml</div><div class="line"></div><div class="line">- <span class="attribute">VNC_PASSWD</span>=你的密码</div><div class="line">- <span class="attribute">COOLQ_ACCOUNT</span>=你的qq账号</div></pre></td></tr></table></figure><p>执行<code>docker-compose up -d</code>,然后打开<code>ip:9801</code>完成登录操作。<br>但目前直接登录后，login可以成功，却无法获取到friends，借用<code>blue-bird1</code>的解决方法，修改bot容器中的配置：  </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker exec -it efb-qq-coolq-docker_bot_1 /bin/ash</div><div class="line"></div><div class="line">vi /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">python3</span>.6/<span class="title">site</span>-<span class="title">packages</span>/<span class="title">efb_qq_slave</span>/<span class="title">Clients</span>/<span class="title">CoolQ</span>/<span class="title">CoolQ</span>.<span class="title">py</span></span></div></pre></td></tr></table></figure><p>将第329行和第512行的调用赋值改为绝对赋值:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">res</span> = &#123;<span class="string">"good"</span>: <span class="literal">True</span>, <span class="string">"online"</span>: <span class="literal">True</span>&#125;</div></pre></td></tr></table></figure><p>然后重启容器即可。  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">restart</span> efb-qq-coolq-docker_bot_1</div></pre></td></tr></table></figure><p>此时即可正常收发QQ消息。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽有Web微信的简陋功能，虽有electronic的外观封装，但每次登陆实在太麻烦，以及很多功能被限制，表情无法接收等，被鹅厂放弃的Linux用户对微信的体验大概确实不好。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://dfine.tech/categories/Linux/"/>
    
    
      <category term="Docker" scheme="http://dfine.tech/tags/Docker/"/>
    
      <category term="Telegram" scheme="http://dfine.tech/tags/Telegram/"/>
    
  </entry>
  
  <entry>
    <title>Hashcat密码破解</title>
    <link href="http://dfine.tech/posts/b0550b46/"/>
    <id>http://dfine.tech/posts/b0550b46/</id>
    <published>2019-03-14T11:25:21.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>拿到了一个被加密的Excel，要求输入密码才能打开，于是尝试了下密码破解方法。<br><a id="more"></a></p><h3 id="AROP破解"><a href="#AROP破解" class="headerlink" title="AROP破解"></a>AROP破解</h3><p>AROP(ADVANCED OFFICEPASSWORD RECOVERY)好像是比较主流的Office的破解工具，有收费版和免费版，区别在于密码长度是否超过4字节。<br>用了一个虚拟机跑了一下，字典查询没有，于是暴力破解，嗯，破解速度比较令人绝望，毕竟是CPU在跑。<br>将该Excel文件解压之后，可以发现里面包含<code>DataSpace</code>、<code>EncryptedPackage</code>以及<code>EncryptionInfo</code>等文件，打开<code>EncryptionInfo</code>文件，可以看到里面加密的一些信息:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;?xml <span class="attribute">version</span>=<span class="string">"1.0"</span> <span class="attribute">encoding</span>=<span class="string">"UTF-8"</span> <span class="attribute">standalone</span>=<span class="string">"yes"</span>?&gt;</div><div class="line">&lt;encryption <span class="attribute">xmlns</span>=<span class="string">"http://schemas.microsoft.com/office/2006/encryption"</span> xmlns:<span class="attribute">p</span>=<span class="string">"http://schemas.microsoft.com/office/2006/keyEncryptor/password"</span> xmlns:<span class="attribute">c</span>=<span class="string">"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate"</span>&gt;&lt;keyData <span class="attribute">saltSize</span>=<span class="string">"16"</span> <span class="attribute">blockSize</span>=<span class="string">"16"</span> <span class="attribute">keyBits</span>=<span class="string">"256"</span> <span class="attribute">hashSize</span>=<span class="string">"64"</span> <span class="attribute">cipherAlgorithm</span>=<span class="string">"AES"</span> <span class="attribute">cipherChaining</span>=<span class="string">"ChainingModeCBC"</span> <span class="attribute">hashAlgorithm</span>=<span class="string">"SHA512"</span> <span class="attribute">saltValue</span>=<span class="string">"tLnK9YHGccHAgMyj9Nuwmg=="</span>/&gt;&lt;dataIntegrity <span class="attribute">encryptedHmacKey</span>=<span class="string">"wF7fTyyf/qhB8Vg+8fvQcspTyuR7cc2+yjIyuEAF0O8avnv0LxYhw+DaVmikzCbFDjLgFCAj6+C6m6iJdhuknA=="</span> <span class="attribute">encryptedHmacValue</span>=<span class="string">"IK7Xc7/e0AVLERogsLvFl912xsbhw+oRKd/ABUwE5vw5iQtcAkM0K0rjz+gB8UlDDJlGbQx0HOKWypF3EDbqcA=="</span>/&gt;&lt;keyEncryptors&gt;&lt;keyEncryptor <span class="attribute">uri</span>=<span class="string">"http://schemas.microsoft.com/office/2006/keyEncryptor/password"</span>&gt;&lt;p:encryptedKey <span class="attribute">spinCount</span>=<span class="string">"100000"</span> <span class="attribute">saltSize</span>=<span class="string">"16"</span> <span class="attribute">blockSize</span>=<span class="string">"16"</span> <span class="attribute">keyBits</span>=<span class="string">"256"</span> <span class="attribute">hashSize</span>=<span class="string">"64"</span> <span class="attribute">cipherAlgorithm</span>=<span class="string">"AES"</span> <span class="attribute">cipherChaining</span>=<span class="string">"ChainingModeCBC"</span> <span class="attribute">hashAlgorithm</span>=<span class="string">"SHA512"</span> <span class="attribute">saltValue</span>=<span class="string">"wisEIaAFG08tJoh3tD0Bqw=="</span> <span class="attribute">encryptedVerifierHashInput</span>=<span class="string">"ZMMqH6NC6xpnsH8zBXtfyA=="</span> <span class="attribute">encryptedVerifierHashValue</span>=<span class="string">"mEcTV0662f/U1+nndKsBiv+L/CsAusbw+So+pA4g8TBKq70rNYy7nkZk+tYB6M/fFZdBfRH4363GRI4m8WPk6Q=="</span> <span class="attribute">encryptedKeyValue</span>=<span class="string">"xUZ5hE+Tzhim5YcUf7KOA5Z1jAG+cTaOGRd859sCkPA="</span>/&gt;&lt;/keyEncryptor&gt;&lt;/keyEncryptors&gt;&lt;/encryption&gt;</div></pre></td></tr></table></figure></p><p>其中，采用的是AES算法，有盐(salt,指随机的数据，加入到哈希的过程中，加大破解难度)，hash算法是SHA512,<code>spinCount=100000</code>经过了100000次的迭代操作，想直接逆向破解，实在太难。字典尝试无效，只能暴力破解，但是随着密码长度增加，以及字母数字、特殊字符的引入，破解难度指数增长。对于纯小写字母的6位密码，复杂度为$26^6 = 308915776$次，七位则超过了80亿次，指望这个靠CPU计算的软件，实际希望不大，跑了半天后放弃了。</p><h3 id="Hashcat破解"><a href="#Hashcat破解" class="headerlink" title="Hashcat破解"></a>Hashcat破解</h3><blockquote><p>Hashcat号称世界上最快的密码破解，世界上第一个和唯一的基于GPGPU规则引擎，免费多GPU（高达128个GPU），多哈希，多操作系统（Linux和Windows本地二进制文件），多平台（OpenCL和CUDA支持），多算法，资源利用率低，基于字典攻击，支持分布式破解等等。  </p></blockquote><p>嗯，暴力破解的话，只能考虑使用GPU跑，这时，开源的<a href="https://hashcat.net/hashcat/" rel="external nofollow noopener noreferrer" target="_blank">hashcat</a>就是一个不错的选择。</p><h4 id="获取文件hash值"><a href="#获取文件hash值" class="headerlink" title="获取文件hash值"></a>获取文件hash值</h4><p>使用hashcat破解office，先需要获取文件的hash值，网上有现成的工具<code>office2join.py</code>，然后用python运行，参数加上该office文件即可。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python office2john.py <span class="built_in">..</span>/test.xlsx </div><div class="line"></div><div class="line">test.xlsx:<span class="variable">$office</span>$<span class="number">*2013</span><span class="number">*100000</span><span class="number">*256</span><span class="number">*16</span><span class="number">*c22b0421a0051b4f2d268877b43d01ab</span><span class="number">*64c32a1fa342eb1a67b07f33057b5fc8</span><span class="number">*984713574ebad9ffd4d7e9e774ab018aff8bfc2b00bac6f0f92a3ea40e20f130</span></div></pre></td></tr></table></figure></p><p>可以看到，加密方式为office2013，将第一个冒号后面的字串复制到一个新文件中保存即可。</p><h4 id="hashcat破解"><a href="#hashcat破解" class="headerlink" title="hashcat破解"></a>hashcat破解</h4><p>知道加密方式后，需要找到对应的破解模式，首先使用<code>--help</code>看一下帮助:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">./hashcat64.bin</span> <span class="params">--help</span></div></pre></td></tr></table></figure></p><p>可以看到office的加密模式有以下几种:<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">9700 </span>| MS Office &lt;= <span class="number">2003</span> $<span class="number">0</span>/$<span class="number">1</span>, MD5 + RC4               | Documents</div><div class="line"><span class="symbol">9710 </span>| MS Office &lt;= <span class="number">2003</span> $<span class="number">0</span>/$<span class="number">1</span>, MD5 + RC4, collider #<span class="number">1</span>  | Documents</div><div class="line"><span class="symbol">9720 </span>| MS Office &lt;= <span class="number">2003</span> $<span class="number">0</span>/$<span class="number">1</span>, MD5 + RC4, collider #<span class="number">2</span>  | Documents</div><div class="line"><span class="symbol">9800 </span>| MS Office &lt;= <span class="number">2003</span> $<span class="number">3</span>/$<span class="number">4</span>, SHA1 + RC4              | Documents</div><div class="line"><span class="symbol">9810 </span>| MS Office &lt;= <span class="number">2003</span> $<span class="number">3</span>, SHA1 + RC4, collider #<span class="number">1</span>    | Documents</div><div class="line"><span class="symbol">9820 </span>| MS Office &lt;= <span class="number">2003</span> $<span class="number">3</span>, SHA1 + RC4, collider #<span class="number">2</span>    | Documents</div><div class="line"><span class="symbol">9400 </span>| MS Office <span class="number">2007</span>                                   | Documents</div><div class="line"><span class="symbol">9500 </span>| MS Office <span class="number">2010</span>                                   | Documents</div><div class="line"><span class="symbol">9600 </span>| MS Office <span class="number">2013</span>                                   | Documents</div></pre></td></tr></table></figure></p><p>所以，office2013选择<code>-m 9600</code>，然后开始破解：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">./hashcat64.bin</span> -a 3  -m 9600 <span class="params">--session</span> test -o found.txt hash.txt ?l?l?l?l?l?l?l</div></pre></td></tr></table></figure></p><p>其中，<code>-a</code>表示破解模式，<code>3</code>是暴力破解，<code>--session test</code>是将该次破解进程命名，可有可无，但之后如果要中断再恢复，则可以使用进程名恢复。<code>-o found.txt</code>是将找到的结果输出到指定文件中，<code>hash.txt</code>是之前保存hash码的文件，最后是一串正则表达式，有<code>?l?u?d?s</code>，分别表示小写字母、大写字母、数字、和特殊字符。该例子表示暴力破解七位小写字母的密码。  </p><p>但由于不确定位数，先从简单的开始，破解从1到8位的小写字母：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">./hashcat64.bin</span> -a 3 -m 9600  -o found.txt hash.txt  <span class="params">--increment</span> <span class="params">--increment-min</span> 1 <span class="params">--increment-max</span> 8 ?l?l?l?l?l?l?l?l</div></pre></td></tr></table></figure></p><p>其中，<code>--increment-min 1 --increment-max 8</code>即如本身含义。<br>然后查看一下显卡运行情况：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Tue Mar 12 14:57:13 2019</div><div class="line"><span class="code">+-----------------------------------------------------------------------------+</span></div><div class="line">| NVIDIA-SMI 410.78       Driver Version: 410.78       CUDA Version: 10.0     |</div><div class="line">|-------------------------------<span class="code">+----------------------+</span>----------------------+</div><div class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</div><div class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</div><div class="line">|===============================<span class="code">+======================+</span>======================|</div><div class="line">|   0  GeForce RTX 208...  Off  | 00000000:18:00.0 Off |                  N/A |</div><div class="line">| 90%   80C    P2   247W / 250W |   2341MiB / 10989MiB |     94%      Default |</div><div class="line"><span class="code">+-------------------------------+</span>----------------------<span class="code">+----------------------+</span></div><div class="line">|   1  GeForce RTX 208...  Off  | 00000000:3B:00.0 Off |                  N/A |</div><div class="line">| 90%   80C    P2   248W / 250W |   2341MiB / 10989MiB |     95%      Default |</div><div class="line"><span class="code">+-------------------------------+</span>----------------------<span class="code">+----------------------+</span></div><div class="line">|   2  GeForce RTX 208...  Off  | 00000000:86:00.0 Off |                  N/A |</div><div class="line">| 91%   81C    P2   247W / 250W |   2341MiB / 10989MiB |     95%      Default |</div><div class="line"><span class="code">+-------------------------------+</span>----------------------<span class="code">+----------------------+</span></div><div class="line"></div><div class="line"><span class="code">+-----------------------------------------------------------------------------+</span></div><div class="line">| Processes:                                                       GPU Memory |</div><div class="line">|  GPU       PID   Type   Process name                             Usage      |</div><div class="line">|=============================================================================|</div><div class="line">|    0      1852      C   ./hashcat64.bin                             2331MiB |</div><div class="line">|    1      1852      C   ./hashcat64.bin                             2331MiB |</div><div class="line">|    2      1852      C   ./hashcat64.bin                             2331MiB |</div><div class="line"><span class="code">+-----------------------------------------------------------------------------+</span></div></pre></td></tr></table></figure></p><p>如果中途有事，可以先暂停一下，然后跑完后再过来继续破解：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">./hashcat64.bin --restore</div><div class="line"></div><div class="line">Session..........: test</div><div class="line">Status...........: Cracked</div><div class="line">Hash.Type........: MS Office <span class="number">2013</span></div><div class="line">Hash.Target......: $office$*<span class="number">2013</span>*<span class="number">100000</span>*<span class="number">256</span>*<span class="number">16</span>*c22b0421a0051b4f2d26887..<span class="number">.20</span>f130</div><div class="line">Time.Started.....: Wed Mar <span class="number">13</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">19</span> <span class="number">2019</span> (<span class="number">9</span> hours, <span class="number">37</span> mins)</div><div class="line">Time.Estimated...: Thu Mar <span class="number">14</span> <span class="number">00</span>:<span class="number">05</span>:<span class="number">48</span> <span class="number">2019</span> (<span class="number">0</span> secs)</div><div class="line">Guess.Mask.......: ?l?l?l?l?l?l?l [<span class="number">7</span>]</div><div class="line">Guess.Queue......: <span class="number">1</span>/<span class="number">1</span> (<span class="number">100.00</span>%)</div><div class="line">Speed.#<span class="number">1.</span>........:    <span class="number">19777</span> H/s (<span class="number">8.49</span>ms) @ Accel:<span class="number">64</span> Loops:<span class="number">16</span> Thr:<span class="number">256</span> Vec:<span class="number">1</span></div><div class="line">Speed.#<span class="number">2.</span>........:    <span class="number">19260</span> H/s (<span class="number">8.66</span>ms) @ Accel:<span class="number">64</span> Loops:<span class="number">16</span> Thr:<span class="number">256</span> Vec:<span class="number">1</span></div><div class="line">Speed.#<span class="number">3.</span>........:    <span class="number">19438</span> H/s (<span class="number">8.60</span>ms) @ Accel:<span class="number">64</span> Loops:<span class="number">16</span> Thr:<span class="number">256</span> Vec:<span class="number">1</span></div><div class="line">Speed.#*.........:    <span class="number">58475</span> H/s</div><div class="line">Recovered........: <span class="number">1</span>/<span class="number">1</span> (<span class="number">100.00</span>%) Digests, <span class="number">1</span>/<span class="number">1</span> (<span class="number">100.00</span>%) Salts</div><div class="line">Progress.........: <span class="number">2025455616</span>/<span class="number">8031810176</span> (<span class="number">25.22</span>%)</div><div class="line">Rejected.........: <span class="number">0</span>/<span class="number">2025455616</span> (<span class="number">0.00</span>%)</div><div class="line">Restore.Point....: <span class="number">74645504</span>/<span class="number">308915776</span> (<span class="number">24.16</span>%)</div><div class="line">Restore.Sub.#<span class="number">1.</span>..: Salt:<span class="number">0</span> Amplifier:<span class="number">17</span><span class="number">-18</span> Iteration:<span class="number">7520</span><span class="number">-7536</span></div><div class="line">Restore.Sub.#<span class="number">2.</span>..: Salt:<span class="number">0</span> Amplifier:<span class="number">0</span><span class="number">-1</span> Iteration:<span class="number">99984</span><span class="number">-100000</span></div><div class="line">Restore.Sub.#<span class="number">3.</span>..: Salt:<span class="number">0</span> Amplifier:<span class="number">6</span><span class="number">-7</span> Iteration:<span class="number">53776</span><span class="number">-53792</span></div><div class="line">Candidates.#<span class="number">1.</span>...: efmfogr -&gt; ehdaznt</div><div class="line">Candidates.#<span class="number">2.</span>...: svtdyyl -&gt; srhqbks</div><div class="line">Candidates.#<span class="number">3.</span>...: lnkkjnt -&gt; ljnzibl</div><div class="line">Hardware.Mon.#<span class="number">1.</span>.: Temp: <span class="number">77</span>c Fan: <span class="number">87</span>% Util: <span class="number">94</span>% Core:<span class="number">1635</span>MHz Mem:<span class="number">6800</span>MHz Bus:<span class="number">16</span></div><div class="line">Hardware.Mon.#<span class="number">2.</span>.: Temp: <span class="number">77</span>c Fan: <span class="number">87</span>% Util: <span class="number">93</span>% Core:<span class="number">1695</span>MHz Mem:<span class="number">6800</span>MHz Bus:<span class="number">16</span></div><div class="line">Hardware.Mon.#<span class="number">3.</span>.: Temp: <span class="number">77</span>c Fan: <span class="number">87</span>% Util: <span class="number">94</span>% Core:<span class="number">1725</span>MHz Mem:<span class="number">6800</span>MHz Bus:<span class="number">16</span></div><div class="line"></div><div class="line">Started: Wed Mar <span class="number">13</span> <span class="number">14</span>:<span class="number">27</span>:<span class="number">42</span> <span class="number">2019</span></div><div class="line">Stopped: Thu Mar <span class="number">14</span> <span class="number">00</span>:<span class="number">05</span>:<span class="number">50</span> <span class="number">2019</span></div></pre></td></tr></table></figure></p><p>最后大概半天吧，跑出来结果如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$office</span>$<span class="number">*2013</span><span class="number">*100000</span><span class="number">*256</span><span class="number">*16</span><span class="number">*c22b0421a0051b4f2d268877b43d01ab</span><span class="number">*64c32a1fa342eb1a67b07f33057b5fc8</span><span class="number">*984713574ebad9ffd4d7e9e774ab018aff8bfc2b00bac6f0f92a3ea40e20f130</span>:semicjj</div></pre></td></tr></table></figure></p><p>冒号后面的就是密码。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拿到了一个被加密的Excel，要求输入密码才能打开，于是尝试了下密码破解方法。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://dfine.tech/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://dfine.tech/tags/Linux/"/>
    
      <category term="Git" scheme="http://dfine.tech/tags/Git/"/>
    
      <category term="Hashcat" scheme="http://dfine.tech/tags/Hashcat/"/>
    
  </entry>
  
  <entry>
    <title>Docker博客环境封装及自动化部署</title>
    <link href="http://dfine.tech/posts/6b278ddb/"/>
    <id>http://dfine.tech/posts/6b278ddb/</id>
    <published>2019-03-05T07:25:21.000Z</published>
    <updated>2022-05-19T04:23:59.327Z</updated>
    
    <content type="html"><![CDATA[<p>说来惭愧，也不记得有几次立flag要把博客坚持下去的，看看上一篇的时间，一拖又是这么久了。<br>为了不至于彻底沦落成上班摸鱼，下班看剧的MADAO（并非在说长谷川先生），还是想去舒适区外面逛逛。自动化部署并不是什么难事，记得以前网上就可以找到一堆TravisCI的教程。不过记得去年暑假时候使用Docker封装了博客环境，以便能在新系统上使用(Ubuntu 16.04 =&gt; 18.04)，同时也是为了防止博客插件以及npm的更新引起问题。</p><a id="more"></a><h3 id="容器内构建环境"><a href="#容器内构建环境" class="headerlink" title="容器内构建环境"></a>容器内构建环境</h3><p>关于Docker容器的储存结构以及基本介绍，之前貌似有一篇<a href="/posts/a0c49a8e/">文章</a>已经说了一些了，这里不再赘述。<br>通过镜像构建容器很简单，<code>docker run imagename</code>即可，由于是博客，可以把本地的blog目录挂在进去，并映射里面的端口，即加上<code>-v /Blog:/Blog</code> 和<code>-p 4000:4000</code>，其他设置自己怎么喜欢怎么来。<br>个人是直接从Docker Hub官方仓库中的ubuntu:16.04镜像来启动容器的，可以使用<code>docker pull</code>，也可以使用<code>docker run</code>命令来启动容器。<br>然后是安装一些必要的软件：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">apt <span class="keyword">update</span> &amp;&amp; apt install -<span class="keyword">y</span> <span class="keyword">vim</span> git <span class="keyword">python</span> wget gcc g++</div><div class="line">wget -qO- http<span class="variable">s:</span>//raw.github.<span class="keyword">com</span>/creationix/nvm/v0.<span class="number">33.11</span>/install.<span class="keyword">sh</span> | <span class="keyword">sh</span></div><div class="line">git config --<span class="keyword">global</span> user.email <span class="string">"ABCDEFG@qq.com"</span> &amp;&amp; \</div><div class="line">git config --<span class="keyword">global</span> user.name <span class="string">"username"</span> &amp;&amp; \</div><div class="line"><span class="keyword">source</span> ~/.<span class="keyword">profile</span></div><div class="line">nvm install v9.<span class="number">2.1</span> &amp;&amp; \</div><div class="line">npm install hexo-cli -g &amp;&amp; \</div><div class="line">npm install gulp -g</div></pre></td></tr></table></figure></p><p>首先安装必要的环境，然后安装npm的包管理工具nvm，然后配置git账号，并安装特定版本的node，在安装之前先确认之前可以运行的时候的node版本即可。剩下的就是安装hexo和gulp（博客资源压缩工具，<a href="/posts/6d87f1ac/">优化</a>用）。<br>为了hexo能够直接deploy，配置免密登录密钥并添加到github中。<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -<span class="built_in">t</span> rsa -P <span class="string">""</span></div></pre></td></tr></table></figure></p><p>拷贝<code>/root/.ssh/id_rsa.pub</code>文件中内容到github的SSH-KEY中即可。<br>然后删掉博客中的<code>node_modules/</code>文件夹和<code>db.json</code>文件，重新安装。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span></div></pre></td></tr></table></figure></p><p>之后便可以正常在本地访问博客了。  </p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><h4 id="容器直接构建"><a href="#容器直接构建" class="headerlink" title="容器直接构建"></a>容器直接构建</h4><p>在之前环境配置好之后，退出容器，将该容器打包成镜像。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit <span class="comment">[OPTIONS]</span> <span class="keyword">CONTAINER</span> <span class="comment">[REPOSITORY<span class="comment">[:TAG]</span>]</span></div></pre></td></tr></table></figure></p><p>可加参数有<code>-a authorname</code> 添加作者信息，<code>-m message</code>添加说明文字，如:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit -<span class="selector-tag">a</span> <span class="string">"Lilei &amp;&amp; Hanmeimei"</span> -m <span class="string">"blog image"</span> CONTAINER_ID REPOSITORY:TAG</div></pre></td></tr></table></figure></p><p>后面添加容器ID或者容器名都可以，然后添加你要上传到DockerHub的仓库名以及版本标签(TAG如果为空，默认为latest)  </p><h4 id="通过Dockerfile构建"><a href="#通过Dockerfile构建" class="headerlink" title="通过Dockerfile构建"></a>通过Dockerfile构建</h4><p>将之前的指令写入Dockerfile文件，然后建立镜像即可。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></div><div class="line"><span class="keyword">MAINTAINER</span> gitever</div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt update &amp;&amp; apt install -y vim git python wget gcc g++ make &amp;&amp; \</span></div><div class="line"><span class="bash">    wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh </span></div><div class="line"><span class="bash">ENV NVM_DIR /root/.nvm</span></div><div class="line"><span class="bash">COPY ssh /root/.ssh</span></div><div class="line"><span class="bash">RUN git config --global user.email <span class="string">"ABCDEFG@qq.com"</span> &amp;&amp; \</span></div><div class="line"><span class="bash">    git config --global user.name <span class="string">"username"</span> &amp;&amp; \</span></div><div class="line"><span class="bash">    . <span class="variable">$NVM_DIR</span>/nvm.sh &amp;&amp; \</span></div><div class="line"><span class="bash">    nvm install v9.2.1 &amp;&amp; \</span></div><div class="line"><span class="bash">    npm install hexo-cli -g &amp;&amp; \</span></div><div class="line"><span class="bash">    npm install gulp -g</span></div></pre></td></tr></table></figure><p>其中<code>MAINTAINER</code>是作者名字，<code>FROM</code>是使用的镜像来源，然后安装环境，和之前一样。最后使用<code>Docker build</code>命令构建镜像。<br>需要说一点的是，通过Dockerfile构建的镜像不能直接使用<code>ssh-keygen</code>命令生成免密密钥，因为每次构建镜像时都会执行一次生成指令，如果之后版本需要修改，Dockerfile中需要加入其他指令，那么原来可以免密的镜像，生成后会变的无法登陆。最明显的就是使用ssh的方式的hexo deploy和github 仓库的访问，故而将已经可以免密的<code>.ssh/</code>文件夹直接拷贝进来。  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t gitever/<span class="keyword">blog:ci </span> .</div></pre></td></tr></table></figure><p>使用<code>-t</code>指令是指定之后要上传到Docker Hub的镜像仓库名。<br>然后等待一会，会显示构建完成，使用<code>docker images</code>便可以查看之前直接在容器中构建的镜像和使用Dockerfile构建的镜像。通常使用Dockerfile构建镜像体积会更小，因为Docker的分层存储方式，由于在容器内通常会做很多多余的无用指令，所以直接commit构建的体积很容易变得臃肿。<br>之后就是上传镜像：  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">docker</span> <span class="keyword">push </span>gitever/<span class="keyword">blog:ci</span></div></pre></td></tr></table></figure><h3 id="Docker自动化部署"><a href="#Docker自动化部署" class="headerlink" title="Docker自动化部署"></a>Docker自动化部署</h3><p>其实在镜像制作完成后，即可以使用镜像启动容器，然后使用博客环境了。上传镜像之后，可以在不同电脑上使用该博客环境，也不会有环境冲突的问题。但是每次都要挂载本地目录到容器中(因为博客目录体积较大，直接放入容器中体积太大，而且博客会更新，容器不能保存，只能重新制作镜像，使得效率低下)。也许是觉得在不同电脑上都要下载镜像启动容器显得麻烦，或者觉得每次都要手动generate、push和deploy显得麻烦，便开始打算使用Docker自动化部署。<br>首先去DockerHub创建一个仓库用来自动化部署，仓库创建需要绑定github账号，然后将博客的源文件仓库链接至该镜像仓库，如下图所示。  </p><p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325150413.png" alt="Docker CI"><br></center><br>不过也不一定要链接至博客源文件仓库，可以新建一个仓库，将Dockerfile上传至该仓库，每次push该仓库触发博客自动更新也可以。直接使用博客源文件仓库则是每次写好文章push上去便直接触发更新了。<br>然后在本地的博客源文件（或新仓库）添加一个Dockerfile记录要自动更新的指令。  </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> gitever/blog:ci</div><div class="line"><span class="keyword">MAINTAINER</span> gitever</div><div class="line"><span class="keyword">ADD</span><span class="bash"> .git/ /.git/</span></div><div class="line"><span class="bash">RUN git <span class="built_in">clone</span> YourRepoUrl /Blog &amp;&amp;\</span></div><div class="line"><span class="bash">    . <span class="variable">$NVM_DIR</span>/nvm.sh &amp;&amp; \</span></div><div class="line"><span class="bash">    <span class="built_in">cd</span> /Blog   &amp;&amp; \</span></div><div class="line"><span class="bash">    npm install &amp;&amp; \</span></div><div class="line"><span class="bash">    hexo cle &amp;&amp; \</span></div><div class="line"><span class="bash">    gulp &amp;&amp; \</span></div><div class="line"><span class="bash">    hexo d</span></div></pre></td></tr></table></figure><p>然后<code>git add .</code>以及使用<code>commit</code>和<code>push</code>上传至git仓库即可触发。<br>其中，<code>ADD</code>一个变化的值，保证之后的构建不使用缓存，不然即使仓库更新了，容器里的仓库也不会更新。<br>其实不用每次<code>git clone</code>，git的优点就是差异性存储，所以可以之前依然可以使用缓存，节省时间，将后续操作设置成不使用缓存。  </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> gitever/blog:ci</div><div class="line"><span class="keyword">MAINTAINER</span> gitever</div><div class="line"><span class="keyword">RUN</span><span class="bash"> git <span class="built_in">clone</span> YourRepoUrl /Blog &amp;&amp;\</span></div><div class="line"><span class="bash">    . <span class="variable">$NVM_DIR</span>/nvm.sh &amp;&amp; \</span></div><div class="line"><span class="bash">    npm install &amp;&amp; \</span></div><div class="line"><span class="bash">ADD .git/ /.git/</span></div><div class="line"><span class="bash">RUN <span class="built_in">cd</span> /Blog   &amp;&amp; \</span></div><div class="line"><span class="bash">    . <span class="variable">$NVM_DIR</span>/nvm.sh &amp;&amp; \</span></div><div class="line"><span class="bash">    git pull &amp;&amp; \</span></div><div class="line"><span class="bash">    hexo cle &amp;&amp; \</span></div><div class="line"><span class="bash">    gulp &amp;&amp; \</span></div><div class="line"><span class="bash">    hexo d</span></div></pre></td></tr></table></figure><p>另一种方式，直接将当前仓库中的文件添加到容器中:   </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> gitever/blog:ci</div><div class="line"><span class="keyword">MAINTAINER</span> gitever</div><div class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /Blog </span></div><div class="line"><span class="bash">COPY _config.yml /Blog</span></div><div class="line"><span class="bash">COPY package* /Blog/</span></div><div class="line"><span class="bash">COPY gulpfile.js /Blog</span></div><div class="line"><span class="bash">COPY scaffolds/ /Blog/scaffolds</span></div><div class="line"><span class="bash">RUN <span class="built_in">cd</span> /Blog &amp;&amp; \</span></div><div class="line"><span class="bash">    . <span class="variable">$NVM_DIR</span>/nvm.sh &amp;&amp; \</span></div><div class="line"><span class="bash">    npm install </span></div><div class="line"><span class="bash">ADD themes/ /Blog/themes</span></div><div class="line"><span class="bash">ADD <span class="built_in">source</span>/ /Blog/<span class="built_in">source</span></span></div><div class="line"><span class="bash">ADD .git/ /Blog/.git/</span></div><div class="line"><span class="bash">RUN <span class="built_in">cd</span> /Blog &amp;&amp; \</span></div><div class="line"><span class="bash">    . <span class="variable">$NVM_DIR</span>/nvm.sh &amp;&amp; \</span></div><div class="line"><span class="bash">    git pull &amp;&amp; \</span></div><div class="line"><span class="bash">    hexo cle &amp;&amp; \</span></div><div class="line"><span class="bash">    gulp &amp;&amp; \</span></div><div class="line"><span class="bash">    hexo d</span></div></pre></td></tr></table></figure><p>这种方式，每次修改文件后都将整个文件夹添加到容器中，文件夹比较大的话会花比较多的时间。另一方面，因为Docker层层有缓存，所以第一种方式也只有第一次较慢。<br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325150459.png" alt="Docker CI"><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325150525.png" alt="日志"><br>最后观察触发是否成功以及最后输出结果是否在预期内。<br>上述涉及到<code>ADD</code>和<code>COPY</code>区别，COPY只是简单的复制，ADD支持下载URL，并支持解压，并具有判断其<code>ADD</code>的<code>src</code>功能。因此，在没有特殊需求时，尽量使用COPY提高效率，上述使用<code>ADD .git/</code>是为了让Docker Daemon判断git仓库是否更新了，如果更新了，则不使用缓存，这样，后续的<code>git pull</code>才能真正获取更新并最终更新到网站上。  </p><p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325150550.png" alt="取消缓存"><br></center><br>此外，还可以添加<code>.dockerignore</code>文件来忽略一些容器中你不用的文件以提高速度。容器加载时会默认将当前目录下所有文件打包传给Docker Daemon，比如就是<code>node_modules</code>文件夹。<br>没有写的太细，长篇累牍容易给看客压力，<code>step by step</code>操作一番，不填坑也不会有印象，也并不会达到对容器熟悉的效果。<br>因为容器的方便性，我曾不断向人安利，但也许是推荐的对象不适合，用的人貌似不多，记得以前也答应过人把Docker封装环境的详细过程写写，现在算是应诺了，希望还能帮人节省一点时间。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说来惭愧，也不记得有几次立flag要把博客坚持下去的，看看上一篇的时间，一拖又是这么久了。&lt;br&gt;为了不至于彻底沦落成上班摸鱼，下班看剧的MADAO（并非在说长谷川先生），还是想去舒适区外面逛逛。自动化部署并不是什么难事，记得以前网上就可以找到一堆TravisCI的教程。不过记得去年暑假时候使用Docker封装了博客环境，以便能在新系统上使用(Ubuntu 16.04 =&amp;gt; 18.04)，同时也是为了防止博客插件以及npm的更新引起问题。&lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="http://dfine.tech/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Linux" scheme="http://dfine.tech/tags/Linux/"/>
    
      <category term="Docker" scheme="http://dfine.tech/tags/Docker/"/>
    
      <category term="Blog" scheme="http://dfine.tech/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>小聊乐理</title>
    <link href="http://dfine.tech/posts/d48d9dba/"/>
    <id>http://dfine.tech/posts/d48d9dba/</id>
    <published>2018-11-17T05:51:28.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>很久啦，不止一个人说我写的太无聊，确实我又不是什么有趣的主儿。孤芳自赏，历来惯了。不过生活多点味道也挺好，技术博客里也不需要太多技术，毕竟技术应该寄生在人身上，而不是博客里。<br>——今天偶尔尝试一下别的内容了。<br><a id="more"></a></p><p>不知道有没有人对音乐感兴趣，然而不为盈利，也非是为了悦人而作，也只是突然想写，写便罢。  </p><h3 id="节拍"><a href="#节拍" class="headerlink" title="节拍"></a>节拍</h3><p>拍子是音乐里最基础的节奏单位，经常听到的电音里面的那些”咚-咚-咚–”就是一拍一拍的。一定数量的拍可以构成节，如传统的  $\frac{4}{4}$   下面的4表示4分音符为一拍，上面的4表示一小节拍4下。<img class="github-emoji" style="display:inline;vertical-align:bottom;padding:0px;border:0px solid rgba(0, 0, 0, 0);border-bottom:4px solid rgba(221, 221, 221, 0)" title="yum" alt="yum" src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8" height="20" width="20"><br>另外，拍子的速度则是每分钟拍多少下，即<code>beats per minute</code>(bpm)。时值则是音符持续时间长短，比如2分拍的时值就是4分拍的2倍。  </p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325150831.png" alt=""><br></center><h3 id="琴键"><a href="#琴键" class="headerlink" title="琴键"></a>琴键</h3><p>钢琴一共88键，其实结构很简单，如果从数学的角度考虑，其实也都很容易记住。我画了一下：<br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325150852.png" alt=""><br>恩，画得好累～虽然花了点时间，但实际上手绘就比较快了，钢琴一共88个键，左音低，右音高。其中，最右边的是小字5组C,即($C^5$)，最左边的则是大字2组A，即($A^2$)。中间从小字组往左分别是大字组和大字一组，往右是小字一组到小字五组。每组为CDEFGAB七个白健，键盘中相邻两个键相差为半音，如B和C之间相差即为半音，而C和D之间，由于中间存在一个黑键，因此相差为一个全音。<br>黑键没有独立的名字，分别根据相邻的白健命名，如C和D之间的黑键称为C#或者D♭,其中sharp(#)表示升调，♭符号表示降调。  </p><h4 id="中央C"><a href="#中央C" class="headerlink" title="中央C"></a>中央C</h4><p>关于中央C，即最中间组的C，图中从大字二组到小字五组一共有九个组，中央组就是第五组了，也就是小字一组C，有的也称之为$C^5$。</p><h3 id="音程"><a href="#音程" class="headerlink" title="音程"></a>音程</h3><p>音程，即两个音之间的高低关系，可以理解为两个音之间的距离。与两个音之间的半音数有关。<br>半音数和音程之间的关系，如下表所示：  </p><table><thead><tr><th>半音数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr></thead><tbody><tr><td>音程</td><td>纯一度</td><td>小二度</td><td>大二度</td><td>小三度</td><td>大三度</td><td>纯四度</td><td>增四/减五度</td><td>纯五度</td><td>小六度</td><td>大六度</td><td>小七度</td><td>大七度</td><td>纯八度</td></tr></tbody></table><p>嗯，可以简要从数学方面分析一下。<br>为此，我再画两个组,从C到A，重复两次：</p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325150919.png" alt=""><br></center><p>虽然说规律一致，我还是一个一个分析吧：  </p><ul><li>图中最远的距离是从C回到C，即CDEFGABC，看做数列的话，项数为8，因此最高度数是8。由于钢琴这8度一组，七个白键五个黑键，不断循环。不管怎样，8度必然是这么多白健和黑键，半音数就是$7+5=12$。之所以叫纯八度，是为了和大小增减音程区分开来。非纯音程的原因通常是黑键位置导致的实际值不等于整度数。  </li><li>同时按两次相同位置的C，他们之间的半音数为0，项数为1，只有一度，也不存在由于黑键导致的大于或者等于1的度数，因此是纯一度。  </li><li>再看从C到D，度数为2，但是中间有一个黑键，因此半音数相差为1+1=2，此时称之为大二度。物理上，两个白键之间最多有一个黑键。因此半音数相差为1或者2，为了区分这两种情况，同样是2度音程，有黑键情况，半音数较多称之为大二度，无黑键情况称之为小二度。</li><li>度数为3的情况，如从C到E，中间有两个黑键，半音数为$2+2=4$，而物理上，度数为3的情况也有两种，一种是中间有一个黑键，一种是中间有两个黑键，这就导致了实际半音数会相差1。同样的方法，以大小度数来记，三个白键之间最多有两个黑键，此时称之为大三度；最少有一个黑键，此时称之为小三度。</li><li>度数为4的情况，如从C到F，中间有两个黑键，此时半音数为3+2=5。其实通常情况下四个白键之间都有两个黑键。只有一种情况，就是从F到B，中间有三个黑键，此时半音数为6。因此，当半音数为5，即通常情况下，半音数为5，度数为4的称之为纯四度。半音数为6，度数为4的称之为增四度。</li><li>度数为5的情况，与度数为4的情况类似。如从C到G，中间通常都有三个黑键，半音数为4+3=7。称之为纯五度。只有一种情况，即，从D到G，中间只有两个黑键，半音数为6，但由于度数为6，所以此时称之为减五度。  </li><li>度数为6的情况，与度数为3的情况类似。如从C到A，中间有4个黑键，半音数为5+4=9。而度数为6的情况，白键之间的黑键数量也有两种，如从E到C，中间有三个黑键，半音数为8。同样的记法，半音数8，度数为6的称之为小六度；半音数9，度数为6的称之为大六度。</li><li>最后看度数为7的情况，如从C到A。也是类似，七个白键之间的黑键可能为4或者5，因此半音数可能为10或者11。半音数为10，度数为7的称之为小七度；半音数为11，度数为7的称之为大七度。  </li></ul><p>表中，增四度和减五度之间的距离都是6个半音，即三个全音，因此增四度减五度都成为三全音。  </p><h4 id="音程转位"><a href="#音程转位" class="headerlink" title="音程转位"></a>音程转位</h4><p>音程转位就是从一个组的调转到下一个组的该调。如CDE转位后为EFGABC。从数列方面看，也有一些规律。<br>因为七个白键一组，所以从一个音会到下个组的本音，之间项数为8，距离为7。但转位之后，如从C-E与E-C，中E出现两次，所以最后一共有9个度数。故转位之后度数之和为9。而这一组白键中，黑键数量永远为5，因此转位之后，音程互补。对于大音程，转为之后成为小音程。增音程，转位之后成为减音程。  </p><h4 id="协和音程"><a href="#协和音程" class="headerlink" title="协和音程"></a>协和音程</h4><p>主观感受吧，大致是觉得听起来比较协调，就觉得是协和音程。<br>主要分为4类：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>完全协和音程</td><td>纯一度、纯八度</td></tr><tr><td>协和音程</td><td>纯四度、纯五度</td></tr><tr><td>不完全协和音程</td><td>大/小三度、大/小六度</td></tr><tr><td>不协和音程</td><td>大/小二度、大/小七度、增四度、减五度</td></tr></tbody></table><h3 id="调"><a href="#调" class="headerlink" title="调"></a>调</h3><p>音调，记得初中物理里解释为声音频率的高低，其实大致也是这种感觉吧。直观的感觉是高音轻短细，低音中长粗。<br>图中琴键每七个音阶一组，即<code>CDEFGAB</code>，调有大小之分。</p><h4 id="大调"><a href="#大调" class="headerlink" title="大调"></a>大调</h4><p>以一个C大调为例，如表所示：</p><table><thead><tr><th>C大调</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>距离</td><td>全音</td><td>全音</td><td>半音</td><td>全音</td><td>全音</td><td>全音</td><td>全音</td><td>半音</td></tr></tbody></table><p>选取任意一组琴键，图中可以看到，一个大调包含了七个白健，五个黑键，除了中间的EF两个白健之间没有黑键，其余的从C开始到B，中间都有黑键。因此除了EF之间是相差半音，其余都是相差全音。另外，由于一组七个循环都是从白健开始，首位白健之间也是没有黑键的，因此如果从C回到C，最后B和C之间也是相差半音。大调特征即是如此，即三和七为半音，其余为全音，所谓的“全全半全全全半”。<br>以此方式，则D大调为：</p><table><thead><tr><th>D大调</th><th>D</th><th>E</th><th>F#</th><th>G</th><th>A</th><th>B</th><th>C#</th><th>D</th></tr></thead><tbody><tr><td>距离</td><td>全音</td><td>全音</td><td>半音</td><td>全音</td><td>全音</td><td>全音</td><td>全音</td><td>半音</td></tr></tbody></table><p>表中F和C处为了保持半音和全音的距离，因此写作了F#和C#。虽然F#和G♭是一样的，但在这里，为了保持相邻两音度数为2，因此只能写作F#。如果写作G♭，则G♭和G之间只有一度音，少了F调，无法成为全音。C#的原因也是一样。（主要是写法不同）<br>另外，有个关于升号调和降号调的一个表格：</p><table><thead><tr><th>升号调</th><th>G</th><th>D</th><th>A</th><th>E</th><th>B</th><th>F#</th><th>C#</th></tr></thead><tbody><tr><td>降号调</td><td>F</td><td>B♭</td><td>E♭</td><td>A♭</td><td>D♭</td><td>G♭</td><td>C♭</td></tr></tbody></table><p>以此方式，可以看一下F大调：</p><table><thead><tr><th>F大调</th><th>F</th><th>G</th><th>A</th><th>B♭</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>距离</td><td>全音</td><td>全音</td><td>半音</td><td>全音</td><td>全音</td><td>全音</td><td>全音</td><td>半音</td></tr></tbody></table><p>以上述方式理解或者直接查升号调降号调表格，中可以看到，F属于降号调表示。</p><h4 id="稳定音"><a href="#稳定音" class="headerlink" title="稳定音"></a>稳定音</h4><p>各音之间，稳定性是有差异的，最稳定的音为主音，如C大调主音为C，各音的稳定性如下：</p><table><thead><tr><th>最稳定</th><th>1</th><th>5</th><th>3</th><th>6</th><th>2</th><th>4</th><th>7</th><th>最不稳定</th></tr></thead><tbody><tr><td></td><td>稳定音</td><td>稳定音</td><td>稳定音</td><td>不稳定音</td><td>不稳定音</td><td>不稳定音</td><td>不稳定音</td></tr></tbody></table><p>而各音会有倾向性，即不稳定的音听起来会倾向于进行到稳定音上。其中2级倾向于进行到1级，4级倾向于进行到3级，6级倾向于进行到5级，7级倾向于进行到1级。  </p><h3 id="和弦"><a href="#和弦" class="headerlink" title="和弦"></a>和弦</h3><p>和弦是一些音的结合，先看几个基本的三度叠置和弦:  </p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325150919.png" alt=""><br></center><ul><li>大三和弦： 如从C-E-G，C和E之间存在两个黑键，三度白键之间最多也就两个黑键，因此CE之间是大三度。E和G之间有一个黑键，故EG是小三度。这种<code>大三度+小三度</code>的和弦称之为大三和弦，称之为$Cmaj$，简写为C。其中，C称之为根音，E和G相对于根音分别是3和5度（算上根音本身），因此称之为三音和五音。</li><li>小三和弦： 与大三和弦相对。如从D-F-A,D和F之间是小三度，F和A之间是大三度，DFA则被成为小三和弦。记作$Cminor$，简写为Dm。即小三度+大三度。  </li><li>减三和弦： 如从B-D-F，是小三度+小三度，称之为减三和弦，记作Bdim，简写为$B^。$。  </li><li>从琴键结构可以看出，只算白键的话，两个大三度不可能连续在一起，即大三度+大三度，通常采用黑键表示，即所谓的增三和弦（增三和弦属于极不协和的和弦）。  </li><li>大七和弦(大大七和弦)： 如从C-E-G-B，即大三度+小三度+大三度，此时称之为大七和弦，或称为大大七和弦。简写为CM7。</li><li>属七和弦：如GBDF，大三和弦+小七度，即大三度+小三度+小三度。写作Gdom7，简写为G7。  </li><li>小大七和弦：如EGBD#，小三和弦+大七度，即小三度+大三度+大三度。记作${Emin}^{Maj7}$，间协作${Em}^{M7}$。</li></ul><h4 id="和弦转位"><a href="#和弦转位" class="headerlink" title="和弦转位"></a>和弦转位</h4><p>将三音或者五音、七音放在最下面时(即作为低音)，构成和弦转位。<br>如CEG和弦：</p><table><thead><tr><th>和弦转位</th><th>CEG</th><th>EGC</th><th>GCE</th></tr></thead><tbody><tr><td>位置</td><td>原位</td><td>第一转位</td><td>第二转位</td></tr><tr><td>记法</td><td>C</td><td>C/E</td><td>C/G</td></tr></tbody></table><p>同样的，如大七和弦：</p><table><thead><tr><th>和弦转位</th><th>CEGB</th><th>EGBC</th><th>GBCE</th><th>BCGE</th></tr></thead><tbody><tr><td>位置</td><td>原位</td><td>第一转位</td><td>第二转位</td><td>第三转位</td></tr><tr><td>记法</td><td>CM7</td><td>CM7/E</td><td>CM7/G</td><td>CM7/B</td></tr></tbody></table><h3 id="五度循环圈"><a href="#五度循环圈" class="headerlink" title="五度循环圈"></a>五度循环圈</h3><p>看这名字，可以大致想一下，一组键包括7个白键，5个黑键，加起来是12个键，如果要五度循环，那么最小公倍数为60，因此应该是12组，从C开始算，最后才能回到C，完成一个循环。<br>纯五度协和程度仅次于纯一度和纯八度。五度循环圈如图所示：  </p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325151125.png" alt="五度循环圈"><br></center><p>图中字母可以看做和弦根音，也可以看作单个的音，也可以看作调式主音。如从C大调的所有纯五度音程为：C-G,G-D,D-A,A-E,E-B,F-C。与五度循环圈中位置一致。<br>外圈和内圈作等音转换，如C#等于D♭，圈里有三个半音。通过五度循环圈，可以很容易的写出和弦音。  </p><h3 id="调式音级"><a href="#调式音级" class="headerlink" title="调式音级"></a>调式音级</h3><p>调式七个音级使用罗马数字表示，每个调式和音级关系如下表：</p><table><thead><tr><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>I</td><td>II</td><td>III</td><td>IV</td><td>V</td><td>VI</td><td>VII</td><td>I</td></tr><tr><td>主</td><td>上主</td><td>中</td><td>下属</td><td>属</td><td>下中</td><td>导</td><td>主</td></tr></tbody></table><p>主要可以由琴键理解。C上方是D，因此D称之为上主音。C下方是B，称为导音。然后主音上方纯五度，即G处是属音。C下方纯五度为下属音，即F处。主音和属音中间的音称为中音，即E处。主音和下属音中间的称为下中音，即A处。  </p><h3 id="小调"><a href="#小调" class="headerlink" title="小调"></a>小调</h3><h4 id="自然小调"><a href="#自然小调" class="headerlink" title="自然小调"></a>自然小调</h4><p>通常大调与小调区别，再直观感受上是，大调比较欢快、明朗，小调忧郁、悲伤。再音阶结构上区别如下:</p><table><thead><tr><th>C大调</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>c小调</td><td>C</td><td>D</td><td>E♭</td><td>F</td><td>G</td><td>A♭</td><td>B♭</td><td>C</td></tr><tr><td></td><td>I</td><td>II</td><td>III</td><td>IV</td><td>V</td><td>VI</td><td>VII</td><td>I</td></tr><tr><td></td><td>全</td><td>半</td><td>全</td><td>全</td><td>半</td><td>全</td><td>全</td></tr></tbody></table><p>如表中所示，大调和小调的区别在III级音和VI、VII级处，其中最主要的区别在于三级音，也成为调式特性音。主音相同，三级音的特性是使小调悲伤的主要原因。<br>此外，音阶结构相对于大调的“全全半全全全半”，为“全半全全半全全”。  </p><h4 id="关系大小调"><a href="#关系大小调" class="headerlink" title="关系大小调"></a>关系大小调</h4><p>比较一下C大调和a小调：</p><table><thead><tr><th>C大调</th><th></th><th></th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>a小调</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td></td></tr></tbody></table><p>a小调再琴键上全是白健，构成音和C大调一样，只是主音不同。此时这两者称之为关系大小调：a小调是C大调的关系小调，C大调是a小调的关系大调。<br>通常构成音相同的大小调称为关系大小调，大调六级音为小调主音，小调三级音为大调主音。还是用数学方法证明一下：  </p><table><thead><tr><th>小调音阶</th><th>全</th><th>半</th><th>全</th><th>全</th><th>半</th><th>全</th><th>全</th><th></th><th></th></tr></thead><tbody><tr><td>大调音阶</td><td></td><td></td><td>全</td><td>全</td><td>半</td><td>全</td><td>全</td><td>全</td><td>半</td></tr></tbody></table><p>将大小调音阶对比，可以看出，在平移两度之后，小调音阶与大调音阶一致。从表中可以得到，大调的关系小调在其下方小三度处（相差2度）。<br>小调调号使用关系大调调号。画在五度循环圈里如下:  </p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325151221.png" alt="五度循环圈"><br></center><h4 id="自然音程和变化音程"><a href="#自然音程和变化音程" class="headerlink" title="自然音程和变化音程"></a>自然音程和变化音程</h4><p>自然音程：大调（或者自然小调）中，任何两个音构成的音程都属于自然音程。<br>之前所分析的音程均为自然音程，共四大类，14种。  </p><table><thead><tr><th>自然音程</th><th></th></tr></thead><tbody><tr><td>纯音程</td><td>纯一度</td><td>纯四度</td><td>纯五度</td><td>纯八度</td></tr><tr><td>大音程</td><td>大二度</td><td>大三度</td><td>大六度</td><td>大七度</td></tr><tr><td>小音程</td><td>小二度</td><td>小三度</td><td>小六度</td><td>小七度</td></tr><tr><td>三全音</td><td>增四度</td><td>减五度</td></tr></tbody></table><p>除了自然音程之外的，都属于变化音程，也有四类：</p><ul><li>增音程（除增四度）</li><li>减音程（除减五度）</li><li>倍增音程</li><li>倍减音程</li></ul><p>具体关系可由图表示：  </p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325151257.png" alt="变化音程"><br><br></center><p>图中可以看出，纯音程和大音程，在度数不变情况下，增加一个半音可得到增音程，再增加一个半音，可以得到倍增音程。如下表所示：</p><table><thead><tr><th>F-G</th><th>大二度</th></tr></thead><tbody><tr><td>F-G#</td><td>增二度</td></tr><tr><td>F-Gx</td><td>倍增二度</td></tr></tbody></table><p>减音程和倍减音程类似：对于纯音程和小音程，在度数不变情况下，减少一个半音可以得到减音程，在减少一个半音可以得到倍减音程。  </p><table><thead><tr><th>G#-A</th><th>小二度</th></tr></thead><tbody><tr><td>G#-A♭</td><td>减二度</td></tr><tr><td>G#-A♭♭</td><td>倍减二度</td></tr></tbody></table><p>纯音程可以变为增音程、倍增音程和减音程、倍减音程。但由于纯一度的半音数为0，所以纯一度没有减音程和倍减音程。  </p><h4 id="小调变体"><a href="#小调变体" class="headerlink" title="小调变体"></a>小调变体</h4><p>小调与大调区别主要在于音阶，自然小调变体有和声小调和旋律小调。  </p><table><thead><tr><th></th><th>I</th><th>II</th><th>III</th><th>IV</th><th>V</th><th>VI</th><th>VII</th><th>I</th></tr></thead><tbody><tr><td>a自然小调</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>A</td></tr><tr><td>a和声小调</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G#</td><td>A</td></tr><tr><td>a旋律小调</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F#</td><td>G#</td><td>A</td></tr></tbody></table><p>大调与小调之间的关系:</p><table><thead><tr><th></th><th>I</th><th>II</th><th>III</th><th>IV</th><th>V</th><th>VI</th><th>VII</th><th>I</th></tr></thead><tbody><tr><td>C大调</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>A</td><td>B</td><td>C</td></tr><tr><td>c自然小调</td><td>C</td><td>D</td><td>E♭</td><td>F</td><td>G</td><td>A♭</td><td>B♭</td><td>C</td></tr><tr><td>c和声小调</td><td>C</td><td>D</td><td>E♭</td><td>F</td><td>G</td><td>A♭</td><td>B</td><td>C</td></tr><tr><td>c旋律小调</td><td>C</td><td>D</td><td>E♭</td><td>F</td><td>G</td><td>A</td><td>B</td><td>C</td></tr></tbody></table><p>从表中可以看出，大调与同主音的主要区别在三级音，将大调三级音降半音，可以得到旋律小调，再将六级音降半音可以得到和声小调，再将七级音降半音就可以得到自然小调了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久啦，不止一个人说我写的太无聊，确实我又不是什么有趣的主儿。孤芳自赏，历来惯了。不过生活多点味道也挺好，技术博客里也不需要太多技术，毕竟技术应该寄生在人身上，而不是博客里。&lt;br&gt;——今天偶尔尝试一下别的内容了。&lt;br&gt;
    
    </summary>
    
      <category term="乐理" scheme="http://dfine.tech/categories/%E4%B9%90%E7%90%86/"/>
    
    
      <category term="乐理" scheme="http://dfine.tech/tags/%E4%B9%90%E7%90%86/"/>
    
      <category term="和弦" scheme="http://dfine.tech/tags/%E5%92%8C%E5%BC%A6/"/>
    
      <category term="音律" scheme="http://dfine.tech/tags/%E9%9F%B3%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>LXD搭设服务器</title>
    <link href="http://dfine.tech/posts/325daa6a/"/>
    <id>http://dfine.tech/posts/325daa6a/</id>
    <published>2018-10-11T23:11:47.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>主要是想搭设几台服务器，希望用户环境能隔离，相互安装和配置环境不影响，也希望不至于发生有了sudo权限就把别人的都删了的情况。同时也希望所有用户都能使用服务器上的硬件设备如GPU，且都能上网。<br><a id="more"></a><br>如果采用虚拟机技术，则硬件只能独占，不能共享，且开销大，另外一旦确定了所需分配的资源就成了固定开销，无论虚拟机中资源利用率如何。而另一方面，容器技术的特点则是资源共享，基本不占用硬件资源，所以考虑使用容器技术来实现用户环境隔离。<br>目前最流行的容器技术还是Docker，但Docker更适合于单个应用环境的部署，对于用户来说，希望在相互隔离时候也能用到服务器资源，更希望是一个虚拟机，而不是一个应用环境。目前Linux上主要有LXC和LXD，Docker以前就是用的LXC的Runtime，而LXD也只是一个提供了REST API的LXC容器管理器而已，其仓库地址<a href="https://github.com/lxc/lxd" rel="external nofollow noopener noreferrer" target="_blank">在此</a>。因此打算使用LXD来搭建这个服务器。</p><p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325151518.png" alt=""><br></center></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先是下载LXD容器，如果是Ubuntu16.04里的apt软件仓库，最高应该是2.x的版本，如果要支持LXD容器内GPU的数据处理，至少版本为3.0.好在从16.04时候引进了另一个软件包管理工具，之前一篇<a href="/posts/9dfc9fe0/">文章</a>有所介绍，即使用snap软件包管理工具。<br>查看版本：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ▶ snap <span class="builtin-name">find</span> lxd</div><div class="line">Name             Version        Publisher       Notes  Summary</div><div class="line">lxd-demo-server  0+git.f3532e3  stgraber        -      Online software demo sessions using LXD</div><div class="line">lxd              3.6            canonical✓      -     <span class="built_in"> System </span>container manager <span class="keyword">and</span> API</div><div class="line">nova             ocata          james-page      -      OpenStack Compute<span class="built_in"> Service </span>(nova)</div><div class="line">satellite        0.1.2          alanzanattadev  -      Advanced scalable Open source intelligence platform</div><div class="line">nova-hypervisor  ocata          james-page      -      OpenStack Compute<span class="built_in"> Service </span>- KVM Hypervisor (nova)</div></pre></td></tr></table></figure></p><p>可以看到已经到3.6了，直接下载就行<code>snap install lxd</code>。<br>安装好后应该就可以直接使用了,第一部是初始化LXD的环境，使用<code>lxd init</code>。如果出现<code>permission denied</code>之类的问题，可以加<code>sudo</code>，嫌麻烦可以将当前用户加入LXD组内：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo usermod <span class="keyword">add</span><span class="bash"> -aG lxd <span class="variable">$&#123;USER&#125;</span></span></div></pre></td></tr></table></figure></p><p>然后注销重新登录就行了。<br>在初始化之前，需要安装几个工具，一个是ZFS，是LXD默认的后端存储工具，另一个是Bridge管理工具，LXD自身也带网桥创建功能，默认创建网桥会自动创建局域网私有地址并分配DHCP地址至虚拟网卡。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt <span class="keyword">install</span> zfsutils-linux bridge-utils</div></pre></td></tr></table></figure></p><p>初始化过程如下：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">lxd init</span></div></pre></td></tr></table></figure></p><p>所有提示注意一下是否创建网桥时候选择no就行，其余基本可以使用默认配置。如果不用管外网远程登录，可以直接全选默认。<br>然后拉取一个镜像，如：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lxc <span class="built_in">launch</span> ubuntu:<span class="number">16.04</span> test</div></pre></td></tr></table></figure></p><p>拉取成功启动了就可以使用<code>lxc list</code>看到容器了。使用<code>lxc exec test -- ${command}</code>命令在容器内执行命令。如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lxc <span class="built_in">exec</span> <span class="built_in">test</span> bash</div></pre></td></tr></table></figure></p><p>这时可以进入容器内的bash。<br>然后通过配置好第一个容器，将其作为模板，制作出多个虚拟主机。</p><h3 id="显卡配置"><a href="#显卡配置" class="headerlink" title="显卡配置"></a>显卡配置</h3><p>在此之前，需要宿主机上安装显卡驱动和CUDA，具体过程不做赘述。<br>先关闭容器<code>lxc stop test</code>，然后将显卡设备添加到容器中：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lxc<span class="built_in"> config </span>device <span class="builtin-name">add</span> test gpu gpu</div></pre></td></tr></table></figure></p><p>该命令是添加所有显卡，也可以手动指定显卡id。<br>然后启动容器，安装显卡驱动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lxc <span class="built_in">exec</span> <span class="built_in">test</span> bash</div><div class="line">apt update</div></pre></td></tr></table></figure></p><p>可以直接参考宿主机的显卡驱动，查看一下宿主机显卡驱动版本，可以使用<code>nvidia-smi</code>或者<code>sudo dpkg -l |grep nvidia</code>查看，然后回到容器，使用<code>apt install nvidia-XXX-dev</code>安装。<br>如果安装成功，即可以使用nvidia命令查看显卡。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">nvidia-smi</div><div class="line"></div><div class="line"><span class="code">+-----------------------------------------------------------------------------+</span></div><div class="line">| NVIDIA-SMI 390.30                 Driver Version: 390.30                    |</div><div class="line">|-------------------------------<span class="code">+----------------------+</span>----------------------+</div><div class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</div><div class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</div><div class="line">|===============================<span class="code">+======================+</span>======================|</div><div class="line">|   0  Quadro P4000        Off  | 00000000:02:00.0 Off |                  N/A |</div><div class="line">| 46%   37C    P0    28W / 105W |      0MiB /  8118MiB |      0%      Default |</div><div class="line"><span class="code">+-------------------------------+</span>----------------------<span class="code">+----------------------+</span></div><div class="line">|   1  Quadro P4000        Off  | 00000000:03:00.0 Off |                  N/A |</div><div class="line">| 46%   40C    P0    28W / 105W |      0MiB /  8119MiB |      0%      Default |</div><div class="line"><span class="code">+-------------------------------+</span>----------------------<span class="code">+----------------------+</span></div><div class="line">|   2  Quadro P4000        Off  | 00000000:82:00.0 Off |                  N/A |</div><div class="line">| 46%   40C    P0    28W / 105W |      0MiB /  8119MiB |      0%      Default |</div><div class="line"><span class="code">+-------------------------------+</span>----------------------<span class="code">+----------------------+</span></div><div class="line"><span class="code">                                                                           </span></div><div class="line"><span class="code">+-----------------------------------------------------------------------------+</span></div><div class="line">| Processes:                                                       GPU Memory |</div><div class="line">|  GPU       PID   Type   Process name                             Usage      |</div><div class="line">|=============================================================================|</div><div class="line">|  No running processes found                                                 |</div><div class="line"><span class="code">+-----------------------------------------------------------------------------+</span></div></pre></td></tr></table></figure></p><p>CUDA版本和TensorFlow版本由用户自己选择，默认不安装。  </p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>这个是最麻烦的，如果需要访问外网的话。目前个人方法如下：</p><h4 id="lxc创建网桥"><a href="#lxc创建网桥" class="headerlink" title="lxc创建网桥"></a>lxc创建网桥</h4><p>先使用lxc创建一个网桥，网桥地址应该与本地电脑在一个网段，这样桥接后本地其他电脑才可以远程访问该容器。假如本地各电脑IP为<code>192.168.1.xxx</code>，则：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lxc<span class="built_in"> network </span>create lxd0 ipv4.<span class="attribute">address</span>=192.168.1.10/24</div></pre></td></tr></table></figure></p><p>其他可使用默认配置，具体各项参数见官方<a href="https://lxd.readthedocs.io/en/latest/" rel="external nofollow noopener noreferrer" target="_blank">说明</a>。<br>然后使用bridge管理工具将网桥连接至本地网卡，假如本地网卡为enp1s0，则：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">sudo</span> <span class="keyword">brctl </span><span class="keyword">addif </span>lxd0 enp1s0</div></pre></td></tr></table></figure></p><p>添加之后可以使用<code>brctl show</code>命令查看。</p><h4 id="宿主机路由"><a href="#宿主机路由" class="headerlink" title="宿主机路由"></a>宿主机路由</h4><p>这时可能出现宿主机无法上网的问题，原因是访问网络时，数据包都默认转发到新建网桥地址，而不是默认网关地址，所以需要添加一条路由表：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo<span class="built_in"> route </span><span class="builtin-name">add</span><span class="built_in"> default </span>gw 192.168.1.1</div></pre></td></tr></table></figure></p><p>可以解决本地宿主机上网问题。  </p><h4 id="重新初始化"><a href="#重新初始化" class="headerlink" title="重新初始化"></a>重新初始化</h4><p>关闭容器后再次使用<code>lxd init</code>初始化容器环境，主要是为容器选择默认网桥，这时只用修改一项配置<code>Would you like to configure LXD to use an existing bridge or host interface? (yes/no) [default=no]</code>，改为yes，然后输入新建网桥名<code>lxd0</code>即可。  </p><h4 id="分配静态地址"><a href="#分配静态地址" class="headerlink" title="分配静态地址"></a>分配静态地址</h4><p>然后重新启动容器并进入bash，修改网络配置文件：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim <span class="regexp">/etc/</span>network<span class="regexp">/interfaces</span></div></pre></td></tr></table></figure></p><p>添加<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">auto eth0</div><div class="line">iface eth0 inet static</div><div class="line">address 192.168.1.11</div><div class="line">gateway 192.168.1.1</div><div class="line">netmask 255.255.255.0</div></pre></td></tr></table></figure></p><p>重启网络服务<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">/etc/i</span>nit.d<span class="regexp">/networking restart</span></div></pre></td></tr></table></figure></p><p>如果IP还不变，那就重启宿主机。  </p><h4 id="修改DNS"><a href="#修改DNS" class="headerlink" title="修改DNS"></a>修改DNS</h4><p>通常到上一步已经可以上网了，默认域名解析服务地址是网桥地址，你也可以改为自定义的DNS地址，如<code>114.114.114.114</code>。最通常的方法是修改<code>/etc/resolv.conf</code>文件中的<code>nameserver</code>。但重启后会失效。以下是永久修改DNS的方法，通常在搭建过程中不需要用到。  </p><h5 id="修改Resolvconf配置"><a href="#修改Resolvconf配置" class="headerlink" title="修改Resolvconf配置"></a>修改Resolvconf配置</h5><p>修改<code>/etc/resolvconf/resolv.conf.d</code>目录下的base，在里面修改DNS服务器地址即可。  </p><h5 id="修改DHCP配置"><a href="#修改DHCP配置" class="headerlink" title="修改DHCP配置"></a>修改DHCP配置</h5><p>另一个方法是修改DHCP配置文件，<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">vim</span> /etc/dhcp/dhclient.<span class="keyword">conf</span></div></pre></td></tr></table></figure></p><p>可以看到，<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#supersede</span> <span class="selector-tag">domain-name</span> "<span class="selector-tag">fugue</span><span class="selector-class">.com</span> <span class="selector-tag">home</span><span class="selector-class">.vix</span><span class="selector-class">.com</span>";</div><div class="line"> <span class="selector-id">#prepend</span> <span class="selector-tag">domain-name-servers</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span>;</div></pre></td></tr></table></figure></p><p>去掉前面的#，将域名服务器改成自己的就可以了。  </p><h3 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h3><p>如果希望用户能远程访问容器，除了网络配置之外，还需要修改一下ssh配置。默认禁止root用户登录，容器创建默认用户也是root用户，里面有个ubuntu用户，未初始化。既然虚拟主机交给用户，即把root也给用户了，所以先设置允许root用户登录，如不需要可以让用户自行更改。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim <span class="regexp">/etc/</span>ssh<span class="regexp">/sshd_config</span></div></pre></td></tr></table></figure></p><p>将其中的<code>PermitRootLogin prohibit-password</code>改为<code>PermitRootLogin yes</code>，以及<code>ChallengeResponseAuthentication no</code>改为<code>ChallengeResponseAuthentication yes</code>。<br>然后为root用户设置密码：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">passwd root</span></div></pre></td></tr></table></figure></p><p>另外可以编辑ssh登录用户的欢迎信息，通过编辑<code>/etc/update-motd.d/</code>目录下的<code>00-header</code>和<code>01-hepler-text</code>中的内容即可完成。<br>最后，重启ssh服务，<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">/etc/i</span>nit.d<span class="regexp">/ssh restart</span></div></pre></td></tr></table></figure></p><h3 id="挂载共享目录"><a href="#挂载共享目录" class="headerlink" title="挂载共享目录"></a>挂载共享目录</h3><p>最后需要在主机上创建一个文件夹，用于各个容器与主机共享，文件传输之类，虽然主机lxc已经有pull和push方法从主机和容器之间拷贝文件，但共享目录会显得更为方便，即便在容器之间也可以相互访问。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lxc<span class="built_in"> config </span>device <span class="builtin-name">add</span> mycontainer sharedtmp disk  <span class="attribute">path</span>=/tmp/share_on_lxc <span class="attribute">source</span>=/tmp/share_on_host</div></pre></td></tr></table></figure></p><p>其中，<code>path</code>和<code>source</code>的地址可以自己定义。<br>到这里，基本结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是想搭设几台服务器，希望用户环境能隔离，相互安装和配置环境不影响，也希望不至于发生有了sudo权限就把别人的都删了的情况。同时也希望所有用户都能使用服务器上的硬件设备如GPU，且都能上网。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://dfine.tech/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://dfine.tech/tags/Linux/"/>
    
      <category term="LXD" scheme="http://dfine.tech/tags/LXD/"/>
    
      <category term="容器" scheme="http://dfine.tech/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Time Machine</title>
    <link href="http://dfine.tech/posts/a0c49a8e/"/>
    <id>http://dfine.tech/posts/a0c49a8e/</id>
    <published>2018-10-09T23:15:37.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是个好东西，或者说容器是个好东西。<br>毕竟回忆里的昨天,我再也回不去。<br>但容器可以。  </p><a id="more"></a><h3 id="Docker存储方式"><a href="#Docker存储方式" class="headerlink" title="Docker存储方式"></a>Docker存储方式</h3><p>还是先说一下Docker容器的储存结构，容器镜像采用的是分层存储的方式，下面是一个Ubuntu16.04的镜像结构。  </p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325151627.png" alt="docker"><br></center><p>也可以在命令行观察，在拉取的时候也可以看到结果：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ▶ docker pull <span class="string">ubuntu:</span><span class="number">16.04</span></div><div class="line"><span class="number">16.04</span>: Pulling from library/ubuntu</div><div class="line"><span class="number">3</span><span class="string">b37166ec614:</span> Already exists</div><div class="line"><span class="number">504</span><span class="string">facff238f:</span> Already exists</div><div class="line"><span class="string">ebbcacd28e10:</span> Already exists</div><div class="line"><span class="string">c7fb3351ecad:</span> Already exists</div><div class="line"><span class="number">2e3</span><span class="string">debadcbf7:</span> Already exists</div><div class="line"><span class="string">Digest:</span> <span class="string">sha256:</span><span class="number">45</span>ddfa61744947b0b8f7f20b8de70cbcdd441a6a0532f791fd4c09f5e491a8eb</div><div class="line"><span class="string">Status:</span> Downloaded newer image <span class="keyword">for</span> <span class="string">ubuntu:</span><span class="number">16.04</span></div></pre></td></tr></table></figure></p><p>其中，每层表示的是与上一层的差异，而不是直接操作底层镜像，这样，当使用其他基于此镜像制作的镜像时，就不必整个拉取或者复制过来，因为它们很多的底层镜像是一样的。Docker镜像采用的是共享存储方式，当拉取一个镜像时，会首先获取所有层的信息，如果该镜像层本地已经有了，就不用下载，只需要下载所需要的镜像层。</p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325151653.png" alt="docker"><br></center><p>在使用镜像建立容器时候，会在最上面一层镜像上建立一个可写层，即容器层。当在容器中所有的操作都会被保存在这个可写层，如果直接删除容器，则可写层就会被删除，即使利用相同镜像重新建立容器，之前的所有操作也不会被保存。镜像层都是只读的，基于此安全性，所有的容器都可以访问底层镜像，所以一次可以利用同一镜像建立多个容器。最后完成修改封装成新的容器的时候，也只是在原来的镜像层之上又加了一层而已。镜像的这种共享存储方式可以极大地提高资源利用效率，而差异存储也是文件管理的主流之选。</p><p>说到这个，想起来目前有个PWD(Play with Docker)的网站，可以直接在里面体验docker，地址<a href="https://labs.play-with-docker.com/?stack=https://raw.githubusercontent.com/docker-library/docs/e24f39cddf21560cf0a24f149059ff23640b0f16/owncloud/stack.yml" rel="external nofollow noopener noreferrer" target="_blank">在这</a>。进去就可以创建一个Docker playground。</p><p><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325151723.png" alt="docker"></p><h3 id="利用Docker运行CUDA和TensorFlow"><a href="#利用Docker运行CUDA和TensorFlow" class="headerlink" title="利用Docker运行CUDA和TensorFlow"></a>利用Docker运行CUDA和TensorFlow</h3><p>在电脑上配置CUDA或者TensorFlow啥的，经常因为各种版本不同导致一大堆问题，于是就想看看可不可以利用Docker去解决这个问题，每次直接打开封装好的镜像就行了，让Docker里的环境去使用GPU，不用去配环境，也不用在电脑上装啥别的软件。然后发现NVIDIA也在Docker上稍微封装了一下，弄了个Nvidia-docker命令，基本命令与docker命令一样，唯一的区别是普通的Docker无法使用GPU，所以<code>Nvidia-docker</code>等效于命令<code>docker --runtime=nvidia</code>。  </p><p>要使用GPU，首先也要安装好显卡驱动，怎么安装这里不做赘述，通常安装成功是可以看到的。  </p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325151759.jpeg" alt=""><br></center><p>当然，Docker肯定要先装好。  </p><h4 id="Nvidia-Docker"><a href="#Nvidia-Docker" class="headerlink" title="Nvidia Docker"></a>Nvidia Docker</h4><p>然后就是安装Nvidia封装的Docker来调用GPU了，具体可以参照<a href="NVIDIA/nvidia-docker">NVIDIA/nvidia-docker</a>页面。  </p><center><br><img src="https://cloud.githubusercontent.com/assets/3028125/12213714/5b208976-b632-11e5-8406-38d379ec46aa.png" alt=""><br></center><p>如果之前有安装1.0版本的Nvidia-docker的，需要先卸载：  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># If you have nvidia-docker <span class="number">1.0</span> installed: we need <span class="keyword">to</span> <span class="built_in">remove</span> it <span class="built_in">and</span> <span class="keyword">all</span> existing GPU containers</div><div class="line">docker volume <span class="keyword">ls</span> -q -<span class="keyword">f</span> driver=nvidia-docker | xargs -r -I&#123;&#125; -n1 docker <span class="keyword">ps</span> -q -<span class="keyword">a</span> -<span class="keyword">f</span> volume=&#123;&#125; | xargs -r docker rm -<span class="keyword">f</span></div><div class="line">sudo apt-<span class="built_in">get</span> purge -<span class="keyword">y</span> nvidia-docker</div></pre></td></tr></table></figure><p>没有的话可以直接略过。然后添加仓库地址重定向到镜像源文件中，再更新软件源。  </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Add the package repositories</span></div><div class="line"><span class="attribute">curl</span> -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \</div><div class="line">  sudo apt-key add -</div><div class="line">  distribution=$(. /etc/os-release;<span class="attribute">echo</span> <span class="variable">$ID</span><span class="variable">$VERSION_ID</span>)</div><div class="line">  curl -s -L https://nvidia.github.io/nvidia-docker/<span class="variable">$distribution</span>/nvidia-docker.list | \</div><div class="line">    sudo tee /etc/apt/sources.list.d/nvidia-docker.list</div><div class="line">    sudo apt-get update</div></pre></td></tr></table></figure><p>然后直接安装即可。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Install nvidia-docker2 and reload the Docker daemon configuration</span></div><div class="line">sudo apt-<span class="builtin-name">get</span> install -y nvidia-docker2</div><div class="line">sudo pkill -SIGHUP dockerd</div></pre></td></tr></table></figure></p><h4 id="CUDA测试"><a href="#CUDA测试" class="headerlink" title="CUDA测试"></a>CUDA测试</h4><p>首先运行一个cuda的镜像，进入bash中，<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run --runtime=nvidia -it --name cuda --rm nvidia/<span class="symbol">cuda:</span><span class="number">9.0</span>-base /bin/bash</div><div class="line">root<span class="variable">@c1d523d61051</span><span class="symbol">:/</span><span class="comment">#</span></div><div class="line">root<span class="variable">@c1d523d61051</span><span class="symbol">:/</span><span class="comment">#</span></div></pre></td></tr></table></figure></p><p>这里将容器命名为cuda方便操作，需要选择runtime为nvidia，或者直接使用<code>nvidia-docker</code>命令。然后输入<code>nvidia-smi</code>就可以看到是否成功调用显卡了。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">root@c1d523d61051:/# nvidia-smi </div><div class="line">Thu Oct 11 07:51:19 2018       </div><div class="line"><span class="code">+-----------------------------------------------------------------------------+</span></div><div class="line">| NVIDIA-SMI 384.130                Driver Version: 384.130                   |</div><div class="line">|-------------------------------<span class="code">+----------------------+</span>----------------------+</div><div class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</div><div class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</div><div class="line">|===============================<span class="code">+======================+</span>======================|</div><div class="line">|   0  GeForce GTX 1080    Off  | 00000000:01:00.0  On |                  N/A |</div><div class="line">|  0%   44C    P8    14W / 200W |    867MiB /  8110MiB |      0%      Default |</div><div class="line"><span class="code">+-------------------------------+</span>----------------------<span class="code">+----------------------+</span></div><div class="line"><span class="code">                                                                               </span></div><div class="line"><span class="code">+-----------------------------------------------------------------------------+</span></div><div class="line">| Processes:                                                       GPU Memory |</div><div class="line">|  GPU       PID   Type   Process name                             Usage      |</div><div class="line">|=============================================================================|</div><div class="line"><span class="code">+-----------------------------------------------------------------------------+</span></div></pre></td></tr></table></figure></p><h4 id="TensorFlow测试"><a href="#TensorFlow测试" class="headerlink" title="TensorFlow测试"></a>TensorFlow测试</h4><p>刚刚也说了，如果要使用GPU，需要在docker命令中加上–runtime=nvidia或者直接使用<code>nvidia-docker</code>命令。这里就直接使用<code>nvidia-docker</code>命令了，<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> $ ▶ nvidia-docker <span class="built_in">run</span> -<span class="keyword">it</span> -d <span class="comment">--name tensor -p 8888:8888 tensorflow/tensorflow </span></div><div class="line"><span class="number">9</span>c7db93b36788acf61a20f52cb187f32e0d6018f7e8da031a30fa135252a4896</div></pre></td></tr></table></figure></p><p>查看容器内信息，<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">docker logs tensor</div><div class="line">[I 08:01:55.452 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret                                                                                                                              </div><div class="line">[I 08:01:55.465 NotebookApp] Serving notebooks from local directory: /notebooks</div><div class="line">[I 08:01:55.465 NotebookApp] The Jupyter Notebook is running at:</div><div class="line">[I 08:01:55.465 NotebookApp] http://(9c7db93b3678 or 127.0.0.1):8888/?token=64e73aaba8febd5539fae22201c7b7cea1b8578cc1413850</div><div class="line">[I 08:01:55.465 NotebookApp] <span class="keyword">Use</span> Control-C <span class="keyword">to</span> <span class="keyword">stop</span> this <span class="keyword">server</span> <span class="keyword">and</span> shut down all kernels (twice <span class="keyword">to</span> <span class="keyword">skip</span> confirmation).</div><div class="line">[C <span class="number">08</span>:<span class="number">01</span>:<span class="number">55.466</span> NotebookApp]</div><div class="line"></div><div class="line">Copy/paste this <span class="keyword">URL</span> <span class="keyword">into</span> your browser <span class="keyword">when</span> you <span class="keyword">connect</span> <span class="keyword">for</span> the <span class="keyword">first</span> <span class="keyword">time</span>,</div><div class="line"><span class="keyword">to</span> login <span class="keyword">with</span> a token:</div><div class="line"><span class="keyword">http</span>://(<span class="number">9</span>c7db93b3678 <span class="keyword">or</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>):<span class="number">8888</span>/?token=<span class="number">64e73</span>aaba8febd5539fae22201c7b7cea1b8578cc1413850</div></pre></td></tr></table></figure></p><p>打开浏览器窗口，输入<code>localhost:8888/?token=64e73aaba8febd5539fae22201c7b7cea1b8578cc1413850</code>，可以看到一个Jupyter的界面。<br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325151838.png" alt="jupyter"></p><p>在里面可以编辑及运行python程序，或者使用终端操作：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>▶ docker exec -it tensor /bin/bash</div><div class="line">root<span class="variable">@9c7db93b3678</span><span class="symbol">:/notebooks</span><span class="comment"># ls</span></div><div class="line"><span class="number">1_</span>hello_tensorflow.ipynb  <span class="number">2_</span>getting_started.ipynb  <span class="number">3_</span>mnist_from_scratch.ipynb  BUILD  LICENSE</div><div class="line">root<span class="variable">@9c7db93b3678</span><span class="symbol">:/notebooks</span><span class="comment"># python</span></div><div class="line">python            python2           python2.<span class="number">7</span>         python3           python3.<span class="number">5</span>m</div><div class="line">python-config     python2-config    python2.<span class="number">7</span>-config  python3.<span class="number">5</span>         python3m</div><div class="line">root<span class="variable">@9c7db93b3678</span><span class="symbol">:/notebooks</span><span class="comment"># python</span></div><div class="line">Python <span class="number">2.7</span>.<span class="number">12</span> (default, Dec  <span class="number">4</span> <span class="number">2017</span>, <span class="number">14</span><span class="symbol">:</span><span class="number">50</span><span class="symbol">:</span><span class="number">18</span>)</div><div class="line">[GCC <span class="number">5.4</span>.<span class="number">0</span> <span class="number">20160609</span>] on linux2</div><div class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</div></pre></td></tr></table></figure><h4 id="关于Docker的Runtime"><a href="#关于Docker的Runtime" class="headerlink" title="关于Docker的Runtime"></a>关于Docker的Runtime</h4><p>一个容器运行需要制定规范、Runtime、管理和定义工具、镜像仓库、运行OS等环节。容器的Runtime是容器运行时的一些规范，主要任务是和操作系统的kernel协作来提供容器的运行环境，由<a href="https://www.opencontainers.org/" rel="external nofollow noopener noreferrer" target="_blank">OCI</a>（Open Container Initiative,由Google，Docker、CoreOS、IBM、微软、红帽等于2015年联合发起的组织）维护。主要包括容器的文件系统包(Filesystem Bundle)，容器的运行和生存周期Runtime and Lifecycle)，容器配置文件(Container Configuration file)，以及Linux的运行和配置文件(Linux Runtime, Linux Container Configuration)等。目前Linux上最原始的容器Runtime是LXC，即Linux Container，最初Docker也是用LXC作为Runtime，后来Docker基于libcontainer开发了自己的Runtime，即runC。谷歌也基于Docker的Runtime发布了Kubernetes，后来CoreOS开发了独立的rkt作为运行容器的Runtime。<br>而与容器相对的就是虚拟机了，目前虚拟机的Runtime如runV，看名字就知道是要与runC分庭抗礼的。此外Intel也弄了一个Clear containers的Runtime，也可以对接容器。基于Hyper runV和Clear containers，Openstack又新起了一个<a href="https://katacontainers.io/" rel="external nofollow noopener noreferrer" target="_blank">Kata</a> Containers，目前已经可以在snap商店看到了，才出来没多久，地址<a href="https://snapcraft.io/blog/kata-containers-now-available-in-the-snap-store" rel="external nofollow noopener noreferrer" target="_blank">在这</a>。  </p><h3 id="利用Docker搭建私有云盘"><a href="#利用Docker搭建私有云盘" class="headerlink" title="利用Docker搭建私有云盘"></a>利用Docker搭建私有云盘</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>这里使用的是一个开源的云存储方案<a href="https://store.docker.com/images/owncloud?tab=description" rel="external nofollow noopener noreferrer" target="_blank">OwnCloud</a>来搭建私有云盘。<br>首先可以搜一下Dockerhub中的镜像，<code>docker search owncloud</code>可以看到结果：</p><p><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325151921.png" alt="owncloud"></p><p>其中第一个就是官方的镜像了，直接<code>docker pull owncloud:8.1</code>拉取就行。或者也可以直接<code>docker run</code>，本地没有它会去Dockerhub下载。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">-d</span> <span class="selector-tag">-p</span> 80<span class="selector-pseudo">:80</span> <span class="selector-tag">owncloud</span><span class="selector-pseudo">:8.1</span></div></pre></td></tr></table></figure><p>其中，<code>-d</code>表示后台运行，<code>-p</code>用来映射端口。也可以直接用<code>-it</code>前台打开tty直接操作。<br>这时候可以在浏览器中看到了，输入<code>localhost</code>就可以看到登陆界面，大致是下面的样子：<br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325151952.png" alt="owncloud"></p><h4 id="运行配置"><a href="#运行配置" class="headerlink" title="运行配置"></a>运行配置</h4><p>其中数据保存在<code>/var/www/html/data</code>目录中，默认是使用SQLite用于数据存储，但对于较大的或者使用桌面客户端同步文件时，并不推荐SQLite，可以考虑最流行的MySQL。其他数据库需要外部安装。<br>在运行时可以使用<code>-v</code>选项来将本地磁盘挂载到容器中数据保存的位置，即<code>/var/www/html/</code>中。  </p><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">v /&lt;mydatalocation&gt;<span class="symbol">:/var/www/html</span></span></div></pre></td></tr></table></figure><p>分的更细一点，可以添加三项，设置命令：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">v /&lt;mydatalocation&gt;<span class="regexp">/apps:/var</span><span class="regexp">/www/html</span><span class="regexp">/apps installed /</span> modified apps</span></div><div class="line"><span class="ruby">-v /&lt;mydatalocation&gt;<span class="regexp">/config:/var</span><span class="regexp">/www/html</span><span class="regexp">/config local configuration</span></span></div><div class="line"><span class="ruby">-v /&lt;mydatalocation&gt;<span class="regexp">/data:/var</span><span class="regexp">/www/html</span><span class="regexp">/data the actual data of your ownCloud</span></span></div></pre></td></tr></table></figure><h4 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h4><p>外部数据库配置有几种方法，第一个是使用Owncloud自己提供的OCC工具(OwnCloud Console)来配置，使用<code>docker exec执行</code>:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -u www-<span class="keyword">data</span> some-owncloud php occ <span class="keyword">status</span></div></pre></td></tr></table></figure></p><p>另外的就是用Docker的工具了，Docker Stack或者Docker Compose来配置。首先需要编辑一个yml配置文件，如<code>stack.yml</code>或<code>compose.yml</code>，名字随便起，然后加入数据库配置:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> ownCloud with MariaDB/MySQL</span></div><div class="line"><span class="meta">#</span><span class="bash"></span></div><div class="line"><span class="meta">#</span><span class="bash"> Access via <span class="string">"http://localhost:8080"</span> (or <span class="string">"http://<span class="variable">$(docker-machine ip)</span>:8080"</span> <span class="keyword">if</span> using docker-machine)</span></div><div class="line"><span class="meta">#</span><span class="bash"></span></div><div class="line"><span class="meta">#</span><span class="bash"> During initial ownCloud setup, select <span class="string">"Storage &amp; database"</span> --&gt; <span class="string">"Configure the database"</span> --&gt; <span class="string">"MySQL/MariaDB"</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> Database user: root</span></div><div class="line"><span class="meta">#</span><span class="bash"> Database password: example</span></div><div class="line"><span class="meta">#</span><span class="bash"> Database name: pick any name</span></div><div class="line"><span class="meta">#</span><span class="bash"> Database host: replace <span class="string">"localhost"</span> with <span class="string">"mysql"</span></span></div><div class="line">version: '3.1'</div><div class="line">services:</div><div class="line">  owncloud:</div><div class="line">    image: owncloud:8.1</div><div class="line">    restart: always</div><div class="line">    ports:</div><div class="line">      - 8080:80</div><div class="line">    volumes: </div><div class="line">      - "/home/newdee/Downloads/owncloud/:/var/www/html/"</div><div class="line">  mysql:</div><div class="line">    image: mysql:5.6</div><div class="line">    restart: always</div><div class="line">    environment:</div><div class="line">      MYSQL_ROOT_PASSWORD: 123456</div><div class="line">      MYSQL_DATABASE: owncloud</div><div class="line">      MYSQL_USER: first</div><div class="line">      MYSQL_PASSWORD: 123456</div></pre></td></tr></table></figure></p><p>最后运行<code>docker stack deploy -c stack.yml owncloud (or docker-compose -f compose.yml up)</code>即可。<br>此时可以发现有两个容器正在运行:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> $ ▶ docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</div><div class="line">8499dc015bc8        owncloud:<span class="number">8.1</span>        <span class="string">"/entrypoint.sh apac…"</span>   <span class="number">15</span> minutes ago      <span class="meta">Up</span> <span class="number">12</span> minutes       <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:<span class="number">8080</span>-&gt;<span class="number">80</span>/tcp   owncloud_owncloud_1</div><div class="line">6e145ebcca20        mysql:<span class="number">5.6</span>           <span class="string">"docker-entrypoint.s…"</span>   <span class="number">15</span> minutes ago      <span class="meta">Up</span> <span class="number">12</span> minutes       <span class="number">3306</span>/tcp               owncloud_mysql_1</div></pre></td></tr></table></figure></p><p>然后在浏览器输入<code>http://localhost:8080</code>可以看到登陆界面，登录信息填yml文件中的信息就行。<br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325152024.png" alt="owncloud"></p><p>登陆成功就可以看到登陆界面了。然后就可以网页上传下载了，还可以生成分享链接。上传下载地址位于挂载的目录中。没有机子也可以去试试VPS，自己搭一个私有云盘用来平时备份下载。  </p><p><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325152113.png" alt="owncloud"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker是个好东西，或者说容器是个好东西。&lt;br&gt;毕竟回忆里的昨天,我再也回不去。&lt;br&gt;但容器可以。  &lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="http://dfine.tech/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Linux" scheme="http://dfine.tech/tags/Linux/"/>
    
      <category term="CUDA" scheme="http://dfine.tech/tags/CUDA/"/>
    
      <category term="Docker" scheme="http://dfine.tech/tags/Docker/"/>
    
      <category term="TensorFlow" scheme="http://dfine.tech/tags/TensorFlow/"/>
    
      <category term="OwnCloud" scheme="http://dfine.tech/tags/OwnCloud/"/>
    
  </entry>
  
  <entry>
    <title>不满就折腾小记</title>
    <link href="http://dfine.tech/posts/9dfc9fe0/"/>
    <id>http://dfine.tech/posts/9dfc9fe0/</id>
    <published>2018-10-08T11:40:58.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>又不记得有多久没来了。稀里糊涂的过着日子，稀里糊涂的毕了业。很多事都是历久愈艰，所以很多习惯才没法坚持下去，对于博客这种需要长期维护的事情来说也当是如此。<br>然而，还是又回来试图挣扎一下了。  </p><a id="more"></a><p>其实这已经是第二篇博文了，第一篇写了很多废话，因为再重装系统换上了Ubuntu18.04之后，发现怎么都没法配好博客环境。很多东西都在变化，系统升级了，nodejs升级了，hexo升级了，连next啥的都升级了，当初在里面乱改插件的，现在对于重建是已经近乎绝望的心态了。  </p><p>但是喜欢挣扎，删了该博客目录，重新从以前备份的博客仓库克隆下来重新搭建，还是搭不好，之前写好的文章，也不小心随着那个博客目录涅槃了。后来尝试了使用Docker来重现当时的博客环境，花了些时间，但好在成功了，以后也不必再因为博客环境再花费太多时间了。</p><h3 id="暂别基佬紫"><a href="#暂别基佬紫" class="headerlink" title="暂别基佬紫"></a>暂别基佬紫</h3><p>笔记本重装了Ubuntu18.04，首先是改了下基佬紫的登陆界面，毕竟这种颜色陪伴了我太多年，学校的校花貌似都是这种颜色，毕竟一直看着也很无聊，其实这种小事，网上教程挺多的。因为Ubuntu18.04拥抱了Gnome，里面的很多登陆或者开机都是以样式文件存储，是挺方便改的了，但目前只想改这个，其余的以后再说。</p><p>由于gnome的缘故，采用了css样式文件保存登陆界面样式，所以只需要简单修改<code>/etc/alternatives/gdm3.css</code>或者<code>/usr/share/gnome-shell/theme/.ubuntu.css</code>文件即可。这两个字虽然位置不同，实际上是一个文件，对其中一个的修改会立刻反映到另一个文件上，如果同时打开，则会有下面的警告:</p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325152358.png" alt="theme"><br></center><p>主要就是修改<code>#lockDialogGroup</code>的样式了，可以改成想要的颜色，也可以换成喜欢的图片，随便都行。</p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325152429.png" alt="theme"><br></center><p>另外就是安装输入法了，还是习惯用的搜狗输入法，毕竟Linux下没几个好用的，安装完之后再语言管理栏添加以下语言和输入法就可以用了，没太多要说的。<br>记得取消Only Show那个选项，然后添加就行。<br>然后安装主题，还是用tweak工具，去gnome主题页面选择喜欢的下载下来应用就行了。  </p><p>还有个小问题就是，安装了Ubuntu 18.04之后，截图工具有点问题了，每次截完图直接保存了，没有跳出复制还是保存的窗口，不过好在也不是什么大问题，以后用快捷键就可以解决。</p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325152457.png" alt="screenshot"><br></center><h4 id="统计计数不蒜子"><a href="#统计计数不蒜子" class="headerlink" title="统计计数不蒜子"></a>统计计数不蒜子</h4><p>回来发现站点统计也挂了，后来去不蒜子页面看了下，发现了这样一段话：</p><blockquote><p>因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！  </p></blockquote><p>那没办法了，只好将原来不蒜子插件里的js源地址改一下。<br>还有Vim手动编译以支持Python，Tmux手动编译，Powerline设置，等等，还是重复以往的工作，都挺无聊的，不过好在发现了一个有趣的网址，<a href="http://www.xyzgate.com/" rel="external nofollow noopener noreferrer" target="_blank">数字之门</a>，可以免费提供各种云端镜像，有点像Docker，比如想学习Linux，各种化学分子软件，以及TensorFlow之类的软件，里面都有现成的镜像，不用自己配环境，适用于练习。  </p><h3 id="关于Gnome-shell扩展"><a href="#关于Gnome-shell扩展" class="headerlink" title="关于Gnome-shell扩展"></a>关于Gnome-shell扩展</h3><p>具体扩展部分可以参看Gnome的<a href="https://wiki.gnome.org/Projects/GnomeShell/Extensions" rel="external nofollow noopener noreferrer" target="_blank">wiki</a>页面,主要了解了一下它的透明效果:LookingGlass。可以使用JavaScript语言控制gnome-shell的界面。<br>Ubuntu 18.04 Gnome支持Alt F2快速启动命令，  </p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325152525.png" alt="lookingglass"><br></center><p>然后输入lg即可打开界面。<br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190325152552.png" alt="lookingglass"></p><p>其中第一个是Evaluator，就是脚本执行界面，里面可以直接运行JavaScript，可以使用tab补全。第二个是Windows，里面会显示当前电脑里的所有窗口，用鼠标点击可以看到。剩下一个就是它的扩展了，里面会列出当前系统所安装的所有扩展，有错的话也会显示出来。</p><h3 id="外网问题"><a href="#外网问题" class="headerlink" title="外网问题"></a>外网问题</h3><p>另一个问题就是使用Google学术以及其他完全不相关的事了。目前ss安全性已经大不如前了，主要还是ssr，有两种方式安装。</p><h4 id="简洁版"><a href="#简洁版" class="headerlink" title="简洁版"></a>简洁版</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget https:<span class="comment">//newdee.cf/ssr</span></div><div class="line">sudo chmod +x <span class="built_in">ssr</span></div><div class="line">sudo mv <span class="built_in">ssr</span> /usr/local/bin</div><div class="line"><span class="built_in">ssr</span> install</div></pre></td></tr></table></figure><p>配置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim <span class="regexp">/usr/</span>local<span class="regexp">/share/</span>shadowsocksr<span class="regexp">/config.json</span></div></pre></td></tr></table></figure><p>里面填上服务器的信息，然后使用<code>ssr start</code>，再在系统或者浏览器中配置代理端口即可。  </p><h4 id="GUI版"><a href="#GUI版" class="headerlink" title="GUI版"></a>GUI版</h4><p>去项目页面<a href="https://github.com/erguotou520/electron-ssr/releases" rel="external nofollow noopener noreferrer" target="_blank">安装</a><br>然后使用dpkg安装，再用apt修复一下，基本是可以打开的，和win版本的操作类似，可以添加订阅地址。  </p><h4 id="V2ray"><a href="#V2ray" class="headerlink" title="V2ray"></a>V2ray</h4><p>现在兴起的另一种加密方式，可见其项目<a href="https://github.com/v2ray/v2ray-core/releases" rel="external nofollow noopener noreferrer" target="_blank">页面</a>，下载解压</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /etc/v2ray/</div><div class="line">sudo cp vpoint_vmess_freedom<span class="selector-class">.json</span>  /etc/v2ray/config.json</div><div class="line">sudo mkdir -<span class="selector-tag">p</span> /var/log/v2ray</div></pre></td></tr></table></figure><p>编辑config.json文件，之后<a href="https://yuan.ga/v2ray-complete-tutorial/" rel="external nofollow noopener noreferrer" target="_blank">运行</a></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo <span class="string">./v2ray</span></div></pre></td></tr></table></figure><p>直接运行程序，V2Ray默认会在当前文件夹寻找名为 config.json 的配置文件并运行。<br>或者移动到系统文件夹下运行:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo mkdir <span class="meta-keyword">/etc/</span>v2ray <span class="meta-keyword">/usr/</span>v2ray <span class="meta-keyword">/var/</span>log/v2ray <span class="meta"># 创建目录</span></div><div class="line">sudo mv v2ray v2ctl geoip.dat geosite.dat -t <span class="meta-keyword">/usr/</span>bin/ <span class="meta"># 移动文件</span></div><div class="line">touch <span class="meta-keyword">/etc/</span>v2ray/config.json <span class="meta"># 仅创建配置文件的空文件</span></div><div class="line">sudo mv systemd/v2ray.service <span class="meta-keyword">/etc/</span>systemd<span class="meta-keyword">/system/</span></div><div class="line">sudo systemctl enable v2ray</div></pre></td></tr></table></figure><p>不过我放弃了，不知道是不是系统版本原因，目前该项目问题也比较多，暂时求稳。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>其他的<code>vpn</code>主要如Windscribe，跨平台vpn，Linux版本下载<a href="https://chn.windscribe.com/guides/linux" rel="external nofollow noopener noreferrer" target="_blank">地址</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sudo apt-key adv --keyserver keyserver.ubuntu.<span class="keyword">com</span> --recv-key FDC247B7</div><div class="line"></div><div class="line"><span class="keyword">echo</span> <span class="string">'deb https://repo.windscribe.com/ubuntu zesty main'</span> | sudo tee /etc/apt/sources.<span class="keyword">list</span>.d/windscribe-repo.<span class="keyword">list</span></div><div class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></div><div class="line"></div><div class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></div><div class="line">windscribe login</div><div class="line">windscribe connect</div><div class="line"></div><div class="line">windscribe --<span class="keyword">help</span></div></pre></td></tr></table></figure><p>不过免费的速度都不怎么样，试过也放弃了。<br>如果有账号的话，直接安装openvpn就可以了：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="builtin-name">get</span> install openvpn network-manager-openvpn network-manager-openvpn-gnome</div></pre></td></tr></table></figure><p>另外，对于有IPv6的代理来说，可以设置浏览器的优先级。如Firefox设置IPv6优先：<br>输入<code>about:config</code>，并找到以下两项做相应修改：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">network<span class="selector-class">.dns</span><span class="selector-class">.disableIPv6</span> 设置成 false</div><div class="line">network<span class="selector-class">.http</span><span class="selector-class">.fast-fallback-to-IPv4</span> 设置成 false</div></pre></td></tr></table></figure><h3 id="Snap软件包管理"><a href="#Snap软件包管理" class="headerlink" title="Snap软件包管理"></a>Snap软件包管理</h3><p>Ubuntu里新起的一种软件包管理方式，好像在16.04中开始引入。命令方式与apt类似，管理方式与docker容器类似，各个应用程序之间相对独立。与apt管理方式相比，s可以较好解决了应用之间的依赖问题便于管理，另一方面会占用较多磁盘空间，当apt方式无法下载所需的应用时，也可以选择使用snap方式下载。</p><h3 id="Docker重建"><a href="#Docker重建" class="headerlink" title="Docker重建"></a>Docker重建</h3><p>最后说说被博客折腾得心力交瘁时候的救星，Docker是一个容器技术已经不想多说，主要是环境隔离且独立的特点，非常适用于各种项目的平台迁移。已经不用再在自己电脑上安装nodejs和nvm来惹这些麻烦了，毕竟是好事。  </p><p>主要方式是通过努力回忆，记起当时的各个软件的版本，然后用同样的系统去重建一遍，基本可以成功。由于npm和各个插件的版本已经在<code>package.json</code>和<code>package-lock.json</code>文件里了，按照里面的版本，利用nvm安装，然后删掉<code>node_modules</code>文件夹，使用npm重新安装即可跑起来。<br>关于Docker的镜像构建，可以通过<code>Docker commit</code>和Dockerfile文件两种方式完成，前者可以直接从tty中构建，后者则可以实现自动部署。Docker教程网上太多，官方的也简明易上手，不知道有没有再写一篇关于Docker的笔记，而且网上也有很多已经写好了的镜像，是可以直接用的。<br>最后，使用<code>-p</code>映射端口后，用<code>-v</code>挂载博客目录，然后写了这篇文章来做个测试。</p><p>终于找到家了~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又不记得有多久没来了。稀里糊涂的过着日子，稀里糊涂的毕了业。很多事都是历久愈艰，所以很多习惯才没法坚持下去，对于博客这种需要长期维护的事情来说也当是如此。&lt;br&gt;然而，还是又回来试图挣扎一下了。  &lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="http://dfine.tech/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Linux" scheme="http://dfine.tech/tags/Linux/"/>
    
      <category term="Docker" scheme="http://dfine.tech/tags/Docker/"/>
    
      <category term="Ubuntu" scheme="http://dfine.tech/tags/Ubuntu/"/>
    
      <category term="Vim" scheme="http://dfine.tech/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>GStreamer笔记五: Media Formats and Pad Capabilities</title>
    <link href="http://dfine.tech/posts/79fb69ed/"/>
    <id>http://dfine.tech/posts/79fb69ed/</id>
    <published>2017-12-06T07:26:11.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>此次所述有关pad功能。关于pad，<a href="/posts/413bb42a/">前面</a>已有简单介绍，pad功能是GStreamer的一个基本元素，由于框架会自动处理他们，所以大多数时候它们是不可见的。本次主要了解的是关于pad功能的检索。<br><a id="more"></a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Pads"><a href="#Pads" class="headerlink" title="Pads"></a>Pads</h4><p>之前已经说过，pad相当于一个接口，允许信息通过或者离开一个元素。Pad的功能(Capabilities或者简写为Cap)指定哪种信息可以通过pad。例如“分辨率为320x200像素，每秒30帧的RGB视频”，或“每采样音频16位，每秒44100采样率的5.1声道”，甚至压缩格式如mp3或h264等。<br>Pad可以支持多种功能(如一个video sink可以支持不同类型的RGB或者YUV格式的视频)，而且功能也可以指定范围(如一个audio sink可以支持每秒1-48000个采样的采样率)。但从pad到pad的实际信息必须仅有一个明确指定的类型。两个相连的pad通过一个协商过程达到一个共同的类型，从而使其pad功能变得固定(仅有一种类型，不包含范围)。<br>要让两个元素连接在一起，他们的能力必须有一个公共子集，否则不可能相互理解。这也是能力的主要目标。<br>应用程序开发人员通常会通过将元素连接到一起来构建管道（如果使用playbin之类的全部元素，则程度较低）。在这种情况下需要知道元素的Pad Caps，或者至少知道当GStreamer拒绝连接两个协商错误的元素时它们的Caps是什么。  </p><h4 id="Pad-templates"><a href="#Pad-templates" class="headerlink" title="Pad templates"></a>Pad templates</h4><p>Pad是从pad模板创建的，pad模板表示了pad可能具有的所有功能。模板可用于创建一些相似的pad，并且允许早期拒绝元素之间的连接：如果其pad模板的功能没有公共子集（相交为空），则无需进一步协商。<br>pad模板可视为协商过程第一步。随着过程的演变，实际的Pads被实例化并且其能力被提炼，直到它们被固定（或者协商失败）。  </p><h4 id="Capabilities-examples"><a href="#Capabilities-examples" class="headerlink" title="Capabilities examples"></a>Capabilities examples</h4><p>一个能力的例子如下:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="string">SINK</span> <span class="attr">template:</span> <span class="string">'sink'</span></div><div class="line"><span class="attr">  Availability:</span> <span class="string">Always</span></div><div class="line"><span class="attr">  Capabilities:</span></div><div class="line">    <span class="string">audio/x-raw</span></div><div class="line"><span class="attr">               format:</span> <span class="string">S16LE</span></div><div class="line"><span class="attr">                 rate:</span> <span class="string">[</span> <span class="number">1</span><span class="string">,</span> <span class="number">2147483647</span> <span class="string">]</span></div><div class="line"><span class="attr">             channels:</span> <span class="string">[</span> <span class="number">1</span><span class="string">,</span> <span class="number">2</span> <span class="string">]</span></div><div class="line">    <span class="string">audio/x-raw</span></div><div class="line"><span class="attr">               format:</span> <span class="string">U8</span></div><div class="line"><span class="attr">                 rate:</span> <span class="string">[</span> <span class="number">1</span><span class="string">,</span> <span class="number">2147483647</span> <span class="string">]</span></div><div class="line"><span class="attr">             channels:</span> <span class="string">[</span> <span class="number">1</span><span class="string">,</span> <span class="number">2</span> <span class="string">]</span></div></pre></td></tr></table></figure></p><p>如代码中所示，该pad是一个接收端(sink)，且一直可用。它支持两种媒体，包括整数格式的原始音频（audio/x-raw）：带符号的16位小端 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>和无符号8位。 方括号表示一个范围：例如，通道数从1到2不等。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">SRC</span> <span class="attr">template:</span> <span class="string">'src'</span></div><div class="line"><span class="attr">  Availability:</span> <span class="string">Always</span></div><div class="line"><span class="attr">  Capabilities:</span></div><div class="line">    <span class="string">video/x-raw</span></div><div class="line"><span class="attr">                width:</span> <span class="string">[</span> <span class="number">1</span><span class="string">,</span> <span class="number">2147483647</span> <span class="string">]</span></div><div class="line"><span class="attr">               height:</span> <span class="string">[</span> <span class="number">1</span><span class="string">,</span> <span class="number">2147483647</span> <span class="string">]</span></div><div class="line"><span class="attr">            framerate:</span> <span class="string">[</span> <span class="number">0</span><span class="string">/1,</span> <span class="number">2147483647</span><span class="string">/1</span> <span class="string">]</span></div><div class="line"><span class="attr">               format:</span> <span class="string">&#123;</span> <span class="string">I420,</span> <span class="string">NV12,</span> <span class="string">NV21,</span> <span class="string">YV12,</span> <span class="string">YUY2,</span> <span class="string">Y42B,</span> <span class="string">Y444,</span> <span class="string">YUV9,</span> <span class="string">YVU9,</span> <span class="string">Y41B,</span> <span class="string">Y800,</span> <span class="string">Y8,</span> <span class="string">GREY,</span> <span class="string">Y16</span> <span class="string">,</span> <span class="string">UYVY,</span> <span class="string">YVYU,</span> <span class="string">IYU1,</span> <span class="string">v308,</span> <span class="string">AYUV,</span> <span class="string">A420</span> <span class="string">&#125;</span></div></pre></td></tr></table></figure></p><p>video/x-raw表示这个信号源输出原始视频。它支持多种尺寸和帧率，以及一组YUV格式（大括号列表表示）。所有这些格式都表示图像平面的不同的填充和下采样。  </p><h4 id="Last-remarks"><a href="#Last-remarks" class="headerlink" title="Last remarks"></a>Last remarks</h4><p>可以使用<code>gst-inspect-1.0</code>工具了解所有GStreamer元素的Caps。<br>一些元素查询底层硬件支持的格式，并相应地提供他们的pad功能（通常进入READY或更高状态时在这样做）。 因此，显示的能力可能因平台而异，也可能从一次执行到下一次执行就变了（即使这种情况很少）。<br>本次将会实例化两个元素（这次通过其工厂函数），显示其pad模板，连接它们并设置管道播放。 在每次状态改变时，sink元素的Pad的功能会被显示，所以可以观察到协商如何进行直到Pad Caps固定。  </p><h3 id="Pad功能实例"><a href="#Pad功能实例" class="headerlink" title="Pad功能实例"></a>Pad功能实例</h3><p>一个普通的有关pad caps的例子如下:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;gst/gst.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">/* Functions below print the Capabilities in a human-friendly format */</span></div><div class="line">static gboolean print_field (GQuark field, const GValue * value, gpointer pfx) &#123;</div><div class="line">  gchar *str = gst_value_serialize (value)<span class="comment">;</span></div><div class="line"></div><div class="line">  g_print (<span class="string">"%s  %15s: %s\n"</span>, (gchar *) pfx, g_quark_to_string (field), str)<span class="comment">;</span></div><div class="line">  g_free (str)<span class="comment">;</span></div><div class="line">  return TRUE<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">static void print_caps (const GstCaps * caps, const gchar * pfx) &#123;</div><div class="line">  guint i<span class="comment">;</span></div><div class="line"></div><div class="line">  g_return_if_fail (caps != NULL)<span class="comment">;</span></div><div class="line"></div><div class="line">  if (gst_caps_is_any (caps)) &#123;</div><div class="line">    g_print (<span class="string">"%sANY\n"</span>, pfx)<span class="comment">;</span></div><div class="line">    return<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">  if (gst_caps_is_empty (caps)) &#123;</div><div class="line">    g_print (<span class="string">"%sEMPTY\n"</span>, pfx)<span class="comment">;</span></div><div class="line">    return<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  for (i = <span class="number">0</span><span class="comment">; i &lt; gst_caps_get_size (caps); i++) &#123;</span></div><div class="line">    GstStructure *structure = gst_caps_get_structure (caps, i)<span class="comment">;</span></div><div class="line"></div><div class="line">    g_print (<span class="string">"%s%s\n"</span>, pfx, gst_structure_get_name (structure))<span class="comment">;</span></div><div class="line">    gst_structure_foreach (structure, print_field, (gpointer) pfx)<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Prints information about a Pad Template, including its Capabilities */</span></div><div class="line">static void print_pad_templates_information (GstElementFactory * factory) &#123;</div><div class="line">  const GList *pads<span class="comment">;</span></div><div class="line">  GstStaticPadTemplate *padtemplate<span class="comment">;</span></div><div class="line"></div><div class="line">  g_print (<span class="string">"Pad Templates for %s:\n"</span>, gst_element_factory_get_longname (factory))<span class="comment">;</span></div><div class="line">  if (!gst_element_factory_get_num_pad_templates (factory)) &#123;</div><div class="line">    g_print (<span class="string">"  none\n"</span>)<span class="comment">;</span></div><div class="line">    return<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  pads = gst_element_factory_get_static_pad_templates (factory)<span class="comment">;</span></div><div class="line">  while (pads) &#123;</div><div class="line">    padtemplate = pads-&gt;data<span class="comment">;</span></div><div class="line">    pads = g_list_next (pads)<span class="comment">;</span></div><div class="line"></div><div class="line">    if (padtemplate-&gt;<span class="keyword">direction </span>== GST_PAD_SRC)</div><div class="line">      g_print (<span class="string">"  SRC template: '%s'\n"</span>, padtemplate-&gt;name_template)<span class="comment">;</span></div><div class="line">    else if (padtemplate-&gt;<span class="keyword">direction </span>== GST_PAD_SINK)</div><div class="line">      g_print (<span class="string">"  SINK template: '%s'\n"</span>, padtemplate-&gt;name_template)<span class="comment">;</span></div><div class="line">    else</div><div class="line">      g_print (<span class="string">"  UNKNOWN!!! template: '%s'\n"</span>, padtemplate-&gt;name_template)<span class="comment">;</span></div><div class="line"></div><div class="line">    if (padtemplate-&gt;presence == GST_PAD_ALWAYS)</div><div class="line">      g_print (<span class="string">"    Availability: Always\n"</span>)<span class="comment">;</span></div><div class="line">    else if (padtemplate-&gt;presence == GST_PAD_SOMETIMES)</div><div class="line">      g_print (<span class="string">"    Availability: Sometimes\n"</span>)<span class="comment">;</span></div><div class="line">    else if (padtemplate-&gt;presence == GST_PAD_REQUEST) &#123;</div><div class="line">      g_print (<span class="string">"    Availability: On request\n"</span>)<span class="comment">;</span></div><div class="line">    &#125; else</div><div class="line">      g_print (<span class="string">"    Availability: UNKNOWN!!!\n"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">    if (padtemplate-&gt;static_caps.string) &#123;</div><div class="line">      GstCaps *caps<span class="comment">;</span></div><div class="line">      g_print (<span class="string">"    Capabilities:\n"</span>)<span class="comment">;</span></div><div class="line">      caps = gst_static_caps_get (&amp;padtemplate-&gt;static_caps)<span class="comment">;</span></div><div class="line">      print_caps (caps, <span class="string">"      "</span>)<span class="comment">;</span></div><div class="line">      gst_caps_unref (caps)<span class="comment">;</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    g_print (<span class="string">"\n"</span>)<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Shows the CURRENT capabilities of the requested pad in the given element */</span></div><div class="line">static void print_pad_capabilities (GstElement *element, gchar *pad_name) &#123;</div><div class="line">  GstPad *pad = NULL<span class="comment">;</span></div><div class="line">  GstCaps *caps = NULL<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Retrieve pad */</span></div><div class="line">  pad = gst_element_get_static_pad (element, pad_name)<span class="comment">;</span></div><div class="line">  if (!pad) &#123;</div><div class="line">    g_printerr (<span class="string">"Could not retrieve pad '%s'\n"</span>, pad_name)<span class="comment">;</span></div><div class="line">    return<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Retrieve negotiated caps (or acceptable caps if negotiation is not finished yet) */</span></div><div class="line">  caps = gst_pad_get_current_caps (pad)<span class="comment">;</span></div><div class="line">  if (!caps)</div><div class="line">    caps = gst_pad_query_caps (pad, NULL)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Print and free */</span></div><div class="line">  g_print (<span class="string">"Caps for the %s pad:\n"</span>, pad_name)<span class="comment">;</span></div><div class="line">  print_caps (caps, <span class="string">"      "</span>)<span class="comment">;</span></div><div class="line">  gst_caps_unref (caps)<span class="comment">;</span></div><div class="line">  gst_object_unref (pad)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">  GstElement *pipeline, *source, *sink<span class="comment">;</span></div><div class="line">  GstElementFactory *source_factory, *sink_factory<span class="comment">;</span></div><div class="line">  GstBus *<span class="keyword">bus;</span></div><div class="line"><span class="keyword"> </span> GstMessage *msg<span class="comment">;</span></div><div class="line">  GstStateChangeReturn ret<span class="comment">;</span></div><div class="line">  gboolean terminate = FALSE<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Initialize GStreamer */</span></div><div class="line">  gst_init (&amp;argc, &amp;argv)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Create the element factories */</span></div><div class="line">  source_factory = gst_element_factory_find (<span class="string">"audiotestsrc"</span>)<span class="comment">;</span></div><div class="line">  sink_factory = gst_element_factory_find (<span class="string">"autoaudiosink"</span>)<span class="comment">;</span></div><div class="line">  if (!source_factory <span class="title">||</span> !sink_factory) &#123;</div><div class="line">    g_printerr (<span class="string">"Not all element factories could be created.\n"</span>)<span class="comment">;</span></div><div class="line">    return -<span class="number">1</span><span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Print information about the pad templates of these factories */</span></div><div class="line">  print_pad_templates_information (source_factory)<span class="comment">;</span></div><div class="line">  print_pad_templates_information (sink_factory)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Ask the factories to instantiate actual elements */</span></div><div class="line">  source = gst_element_factory_create (source_factory, <span class="string">"source"</span>)<span class="comment">;</span></div><div class="line">  sink = gst_element_factory_create (sink_factory, <span class="string">"sink"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Create the empty pipeline */</span></div><div class="line">  pipeline = gst_pipeline_new (<span class="string">"test-pipeline"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">  if (!pipeline <span class="title">||</span> !source <span class="title">||</span> !sink) &#123;</div><div class="line">    g_printerr (<span class="string">"Not all elements could be created.\n"</span>)<span class="comment">;</span></div><div class="line">    return -<span class="number">1</span><span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Build the pipeline */</span></div><div class="line">  gst_bin_add_many (GST_BIN (pipeline), source, sink, NULL)<span class="comment">;</span></div><div class="line">  if (gst_element_link (source, sink) != TRUE) &#123;</div><div class="line">    g_printerr (<span class="string">"Elements could not be linked.\n"</span>)<span class="comment">;</span></div><div class="line">    gst_object_unref (pipeline)<span class="comment">;</span></div><div class="line">    return -<span class="number">1</span><span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Print initial negotiated caps (in NULL state) */</span></div><div class="line">  g_print (<span class="string">"In NULL state:\n"</span>)<span class="comment">;</span></div><div class="line">  print_pad_capabilities (sink, <span class="string">"sink"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Start playing */</span></div><div class="line">  ret = gst_element_set_state (pipeline, GST_STATE_PLAYING)<span class="comment">;</span></div><div class="line">  if (ret == GST_STATE_CHANGE_FAILURE) &#123;</div><div class="line">    g_printerr (<span class="string">"Unable to set the pipeline to the playing state (check the bus for error messages).\n"</span>)<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Wait until error, EOS or State Change */</span></div><div class="line">  <span class="keyword">bus </span>= gst_element_get_bus (pipeline)<span class="comment">;</span></div><div class="line">  do &#123;</div><div class="line">    msg = gst_bus_timed_pop_filtered (<span class="keyword">bus, </span>GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR <span class="title">| GST_MESSAGE_EOS |</span></div><div class="line">        GST_MESSAGE_STATE_CHANGED)<span class="comment">;</span></div><div class="line"></div><div class="line">    <span class="comment">/* Parse message */</span></div><div class="line">    if (msg != NULL) &#123;</div><div class="line">      GError *err<span class="comment">;</span></div><div class="line">      gchar *debug_info<span class="comment">;</span></div><div class="line"></div><div class="line">      <span class="keyword">switch </span>(GST_MESSAGE_TYPE (msg)) &#123;</div><div class="line">        case GST_MESSAGE_ERROR:</div><div class="line">          gst_message_parse_error (msg, &amp;err, &amp;debug_info)<span class="comment">;</span></div><div class="line">          g_printerr (<span class="string">"Error received from element %s: %s\n"</span>, GST_OBJECT_NAME (msg-&gt;src), err-&gt;message)<span class="comment">;</span></div><div class="line">          g_printerr (<span class="string">"Debugging information: %s\n"</span>, debug_info ? debug_info : <span class="string">"none"</span>)<span class="comment">;</span></div><div class="line">          g_clear_error (&amp;err)<span class="comment">;</span></div><div class="line">          g_free (debug_info)<span class="comment">;</span></div><div class="line">          terminate = TRUE<span class="comment">;</span></div><div class="line">          <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>       case GST_MESSAGE_EOS:</div><div class="line">          g_print (<span class="string">"End-Of-Stream reached.\n"</span>)<span class="comment">;</span></div><div class="line">          terminate = TRUE<span class="comment">;</span></div><div class="line">          <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>       case GST_MESSAGE_STATE_CHANGED:</div><div class="line">          <span class="comment">/* We are only interested in state-changed messages from the pipeline */</span></div><div class="line">          if (GST_MESSAGE_SRC (msg) == GST_OBJECT (pipeline)) &#123;</div><div class="line">            GstState old_state, new_state, pending_state<span class="comment">;</span></div><div class="line">            gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state)<span class="comment">;</span></div><div class="line">            g_print (<span class="string">"\nPipeline state changed from %s to %s:\n"</span>,</div><div class="line">                gst_element_state_get_name (old_state), gst_element_state_get_name (new_state))<span class="comment">;</span></div><div class="line">            <span class="comment">/* Print the current capabilities of the sink element */</span></div><div class="line">            print_pad_capabilities (sink, <span class="string">"sink"</span>)<span class="comment">;</span></div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>       default:</div><div class="line">          <span class="comment">/* We should not reach here because we only asked for ERRORs, EOS and STATE_CHANGED */</span></div><div class="line">          g_printerr (<span class="string">"Unexpected message received.\n"</span>)<span class="comment">;</span></div><div class="line">          <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>     &#125;</div><div class="line">      gst_message_unref (msg)<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">  &#125; while (!terminate)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Free resources */</span></div><div class="line">  gst_object_unref (<span class="keyword">bus);</span></div><div class="line"><span class="keyword"> </span> gst_element_set_state (pipeline, GST_STATE_NULL)<span class="comment">;</span></div><div class="line">  gst_object_unref (pipeline)<span class="comment">;</span></div><div class="line">  gst_object_unref (source_factory)<span class="comment">;</span></div><div class="line">  gst_object_unref (sink_factory)<span class="comment">;</span></div><div class="line">  return <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>所需要的库只有<code>gstreamer-1.0</code>。  </p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p><code>print_field</code>, <code>print_caps</code>和<code>print_pad_templates</code>简单的以友好的格式显示了caps的结构，更多的GstCaps内部结构组织可以阅读GStreamer的关于Pad Caps的文档。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Shows the CURRENT capabilities of the requested pad in the given element */</span></div><div class="line">static void print_pad_capabilities (GstElement *element, gchar *pad_name) &#123;</div><div class="line">  GstPad *pad = NULL<span class="comment">;</span></div><div class="line">  GstCaps *caps = NULL<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Retrieve pad */</span></div><div class="line">  pad = gst_element_get_static_pad (element, pad_name)<span class="comment">;</span></div><div class="line">  if (!pad) &#123;</div><div class="line">    g_printerr (<span class="string">"Could not retrieve pad '%s'\n"</span>, pad_name)<span class="comment">;</span></div><div class="line">    return<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Retrieve negotiated caps (or acceptable caps if negotiation is not finished yet) */</span></div><div class="line">  caps = gst_pad_get_current_caps (pad)<span class="comment">;</span></div><div class="line">  if (!caps)</div><div class="line">    caps = gst_pad_query_caps (pad, NULL)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Print and free */</span></div><div class="line">  g_print (<span class="string">"Caps for the %s pad:\n"</span>, pad_name)<span class="comment">;</span></div><div class="line">  print_caps (caps, <span class="string">"      "</span>)<span class="comment">;</span></div><div class="line">  gst_caps_unref (caps)<span class="comment">;</span></div><div class="line">  gst_object_unref (pad)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>gst_element_get_static_pad</code>函数从给定的元素中检索命名的pad。这个pad是静态的，因为它总是存在于元素中。有关Pad可用性的更多信息，可以阅读有关Pads的GStreamer文档。<br>然后调用<code>gst_pad_get_current_caps</code>来检索pad的当前caps，它可以是固定的或不固定的，具体取决于协商过程的状态。甚至可能不存在，这种情况下调用<code>gst_pad_query_caps</code>来检索当前可接受的pad caps。当前可接受的caps将成为处于NULL状态的pad模板的caps，但可能会在以后的状态中更改，因为可能会查询实际的硬件功能。<br>然后将这些功能打印出来:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Create the element factories */</span></div><div class="line">source_factory = gst_element_factory_find (<span class="string">"audiotestsrc"</span>)<span class="comment">;</span></div><div class="line">sink_factory = gst_element_factory_find (<span class="string">"autoaudiosink"</span>)<span class="comment">;</span></div><div class="line">if (!source_factory <span class="title">||</span> !sink_factory) &#123;</div><div class="line">  g_printerr (<span class="string">"Not all element factories could be created.\n"</span>)<span class="comment">;</span></div><div class="line">  return -<span class="number">1</span><span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Print information about the pad templates of these factories */</span></div><div class="line">print_pad_templates_information (source_factory)<span class="comment">;</span></div><div class="line">print_pad_templates_information (sink_factory)<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="comment">/* Ask the factories to instantiate actual elements */</span></div><div class="line">source = gst_element_factory_create (source_factory, <span class="string">"source"</span>)<span class="comment">;</span></div><div class="line">sink = gst_element_factory_create (sink_factory, <span class="string">"sink"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>之前直接使用<code>gst_element_factory_make</code>函数创建了元素，并跳过了关于工厂的讨论。GstElementFactory负责实例化由其工厂名称标识的特定类型的元素。<br>可以使用<code>gst_element_factory_find</code>来创建一个类型为“videotestsrc”的工厂，然后通过<code>gst_element_factory_create</code>使用它实例化多个“videotestsrc”元素。<code>gst_element_factory_make</code>实际上是<code>gst_element_factory_find</code>+<code>gst_element_factory_create</code>的快捷方式。<br>Pad模板已经可以通过工厂来访问，所以一旦工厂被创建，它们就会被打印出来。<br>跳过管道的创建以及开始，转到State-Changed消息处理：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> GST_MESSAGE_STATE_CHANGED:<span class="type"></span></div><div class="line"><span class="type">  </span>/* We are only interested <span class="keyword">in</span> state-changed messages from the pipeline */</div><div class="line">  <span class="keyword">if</span> (GST_MESSAGE_SRC (msg) == GST_OBJECT (pipeline)) &#123;</div><div class="line">    GstState old_state, <span class="keyword">new</span><span class="type">_state</span>, pending_state;</div><div class="line">    gst_message_parse_state_changed (msg, &amp;old_state, &amp;<span class="keyword">new</span><span class="type">_state</span>, &amp;pending_state);</div><div class="line">    g_print (<span class="string">"\nPipeline state changed from %s to %s:\n"</span>,</div><div class="line">        gst_element_state_get_name (old_state), gst_element_state_get_name (<span class="keyword">new</span><span class="type">_state</span>));</div><div class="line">    <span class="comment">/* Print the current capabilities of the sink element */</span></div><div class="line">    print_pad_capabilities (sink, <span class="string">"sink"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p><p>该段代码在每次Pipeline状态发生改变时简单的打印出当前的pad caps。可以在输出中看到初始caps（pad模板的caps）是如何逐步完善直至完全固定（包含无范围单一类型）。  </p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">对于整型/长整型等数据类型，小端与大端相反，按照从低地址到高地址的顺序存放数据的高位字节到低位字节。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此次所述有关pad功能。关于pad，&lt;a href=&quot;/posts/413bb42a/&quot;&gt;前面&lt;/a&gt;已有简单介绍，pad功能是GStreamer的一个基本元素，由于框架会自动处理他们，所以大多数时候它们是不可见的。本次主要了解的是关于pad功能的检索。&lt;br&gt;
    
    </summary>
    
      <category term="TX1入坑" scheme="http://dfine.tech/categories/TX1%E5%85%A5%E5%9D%91/"/>
    
    
      <category term="Linux" scheme="http://dfine.tech/tags/Linux/"/>
    
      <category term="GStreamer" scheme="http://dfine.tech/tags/GStreamer/"/>
    
      <category term="TX1" scheme="http://dfine.tech/tags/TX1/"/>
    
  </entry>
  
  <entry>
    <title>GSreamer笔记四: GUI Toolkit Integration</title>
    <link href="http://dfine.tech/posts/40a79901/"/>
    <id>http://dfine.tech/posts/40a79901/</id>
    <published>2017-12-04T08:23:14.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>主要是关于如何将GStreamer集成到图形用户界面(GUI)工具箱中。基本上当GUI工具箱处理用户界面时，GStreamer主要负责媒体播放。其中两个库必须交互的部分是最有趣的两个部分，即:指导GStreamer将视频输出到GTK+的窗口中并将用户操作转发给GStreamer。<br><a id="more"></a><br>需要解决的问题有:  </p><ul><li>告诉GStreamer如何将视频输出到特定窗口，而不是自己创建窗口；</li><li>如何使用GStreamer的信息持续刷新GUI；</li><li>如何从GStreamer的多个线程更新GUI(这是大多数GUI工具包中被禁止的操作)；</li><li>一个只订阅感兴趣的消息而不是通知所有人的机制。</li></ul><h3 id="关于GTK"><a href="#关于GTK" class="headerlink" title="关于GTK+"></a>关于GTK+</h3><p>这里将使用GTK+工具包构建媒体播放器，这些概念亦适用于其他工具包如QT。<br>关键是告诉GStreamer将视频输出到所选择的窗口。具体机制取决于操作系统(或者窗口系统)，但GStreamer为平台独立性提供了一个抽象层。这种独立性来自GstVideoOverlay接口，它允许应用程序告诉视频接收器(sink)应该接收渲染的窗口的处理程序。<br>Gstreamer所使用的是GObject 接口。GObject的接口是元素可以实现的一组函数，包括GstVideoOverlay等。具体介绍如下:  </p><blockquote><p>A GObject interface (which GStreamer uses) is a set of functions that an element can implement. If it does, then it is said to support that particular interface. For example, video sinks usually create their own windows to display video, but, if they are also capable of rendering to an external window, they can choose to implement the GstVideoOverlay interface and provide functions to specify this external window. From the application developer point of view, if a certain interface is supported, you can use it and forget about which kind of element is implementing it. Moreover, if you are using playbin, it will automatically expose some of the interfaces supported by its internal elements: You can use your interface functions directly on playbin without knowing who is implementing them!</p></blockquote><p>另一个问题是，GUI工具包通常只允许主（或应用）线程来操作图形“小部件”，而GStreamer通常会派生多个线程来处理不同的任务。从回调函数中调用GTK +函数通常会失败，因为回调函数在调用线程中执行，并不需要在主线程中。这个问题可以通过回调函数在GStreamer总线上发布消息来解决: 主线程接收消息并做出相应反应。<br>这里已经注册了一个handle_message函数，每次在总线上出现一条消息时都会调用这个函数，这迫使我们解析每条消息，看看我们是否对其感兴趣。本例中使用了一种不同的方法来为每种消息注册一个回调，所以解析更少，代码更少。  </p><h3 id="GTK-播放器示例"><a href="#GTK-播放器示例" class="headerlink" title="GTK+播放器示例"></a>GTK+播放器示例</h3><p>一个简单的基于playbin的带GUI的媒体播放器如下:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div></pre></td><td class="code"><pre><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">#include &lt;gtk/gtk.h&gt;</div><div class="line">#include &lt;gst/gst.h&gt;</div><div class="line">#include &lt;gst/video/videooverlay.h&gt;</div><div class="line"></div><div class="line">#include &lt;gdk/gdk.h&gt;</div><div class="line">#<span class="keyword">if</span> defined (GDK_WINDOWING_X11)</div><div class="line">#include &lt;gdk/gdkx.h&gt;</div><div class="line">#elif defined (GDK_WINDOWING_WIN32)</div><div class="line">#include &lt;gdk/gdkwin32.h&gt;</div><div class="line">#elif defined (GDK_WINDOWING_QUARTZ)</div><div class="line">#include &lt;gdk/gdkquartz.h&gt;</div><div class="line">#endif</div><div class="line"></div><div class="line"><span class="comment">/* Structure to contain all our information, so we can pass it around */</span></div><div class="line">typedef struct _CustomData &#123;</div><div class="line">  GstElement *playbin;           <span class="comment">/* Our one and only pipeline */</span></div><div class="line"></div><div class="line">  GtkWidget *slider;              <span class="comment">/* Slider widget to keep track of current position */</span></div><div class="line">  GtkWidget *streams_list;        <span class="comment">/* Text widget to display info about the streams */</span></div><div class="line">  gulong slider_update_signal_id; <span class="comment">/* Signal ID for the slider update signal */</span></div><div class="line"></div><div class="line">  GstState state;                 <span class="comment">/* Current state of the pipeline */</span></div><div class="line">  gint64 duration;                <span class="comment">/* Duration of the clip, in nanoseconds */</span></div><div class="line">&#125; CustomData;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when the GUI toolkit creates the physical window that will hold the video.</span></div><div class="line"><span class="comment"> * At this point we can retrieve its handler (which has a different meaning depending on the windowing system)</span></div><div class="line"><span class="comment"> * and pass it to GStreamer through the VideoOverlay interface. */</span></div><div class="line">static void realize_cb (GtkWidget *widget, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  GdkWindow *window = gtk_widget_get_window (widget);</div><div class="line">  guintptr window_handle;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!gdk_window_ensure_native (window))</div><div class="line">    g_error (<span class="string">"Couldn't create native window needed for GstVideoOverlay!"</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* Retrieve window handler from GDK */</span></div><div class="line">#<span class="keyword">if</span> defined (GDK_WINDOWING_WIN32)</div><div class="line">  window_handle = (guintptr)GDK_WINDOW_HWND (window);</div><div class="line">#elif defined (GDK_WINDOWING_QUARTZ)</div><div class="line">  window_handle = gdk_quartz_window_get_nsview (window);</div><div class="line">#elif defined (GDK_WINDOWING_X11)</div><div class="line">  window_handle = GDK_WINDOW_XID (window);</div><div class="line">#endif</div><div class="line">  <span class="comment">/* Pass it to playbin, which implements VideoOverlay and will forward it to the video sink */</span></div><div class="line">  <span class="function"><span class="title">gst_video_overlay_set_window_handle</span> (GST_VIDEO_OVERLAY (<span class="keyword">data</span>-&gt;</span>playbin), window_handle);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when the PLAY button is clicked */</span></div><div class="line">static void play_cb (GtkButton *button, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  <span class="function"><span class="title">gst_element_set_state</span> (<span class="keyword">data</span>-&gt;</span>playbin, GST_STATE_PLAYING);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when the PAUSE button is clicked */</span></div><div class="line">static void pause_cb (GtkButton *button, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  <span class="function"><span class="title">gst_element_set_state</span> (<span class="keyword">data</span>-&gt;</span>playbin, GST_STATE_PAUSED);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when the STOP button is clicked */</span></div><div class="line">static void stop_cb (GtkButton *button, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  <span class="function"><span class="title">gst_element_set_state</span> (<span class="keyword">data</span>-&gt;</span>playbin, GST_STATE_READY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when the main window is closed */</span></div><div class="line">static void delete_event_cb (GtkWidget *widget, GdkEvent *event, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  stop_cb (NULL, <span class="keyword">data</span>);</div><div class="line">  gtk_main_quit ();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called everytime the video window needs to be redrawn (due to damage/exposure,</span></div><div class="line"><span class="comment"> * rescaling, etc). GStreamer takes care of this in the PAUSED and PLAYING states, otherwise,</span></div><div class="line"><span class="comment"> * we simply draw a black rectangle to avoid garbage showing up. */</span></div><div class="line">static gboolean draw_cb (GtkWidget *widget, cairo_t *cr, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  <span class="function"><span class="title">if</span> (<span class="keyword">data</span>-&gt;</span>state &lt; GST_STATE_PAUSED) &#123;</div><div class="line">    GtkAllocation allocation;</div><div class="line"></div><div class="line">    <span class="comment">/* Cairo is a 2D graphics library which we use here to clean the video window.</span></div><div class="line"><span class="comment">     * It is used by GStreamer for other reasons, so it will always be available to us. */</span></div><div class="line">    gtk_widget_get_allocation (widget, &amp;allocation);</div><div class="line">    cairo_set_source_rgb (cr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cairo_rectangle (cr, <span class="number">0</span>, <span class="number">0</span>, allocation.width, allocation.height);</div><div class="line">    cairo_fill (cr);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return FALSE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when the slider changes its position. We perform a seek to the</span></div><div class="line"><span class="comment"> * new position here. */</span></div><div class="line">static void slider_cb (GtkRange *range, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  <span class="function"><span class="title">gdouble</span> value = gtk_range_get_value (GTK_RANGE (<span class="keyword">data</span>-&gt;</span>slider));</div><div class="line">  <span class="function"><span class="title">gst_element_seek_simple</span> (<span class="keyword">data</span>-&gt;</span>playbin, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT,</div><div class="line">      (gint64)(value * GST_SECOND));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This creates all the GTK+ widgets that compose our application, and registers the callbacks */</span></div><div class="line">static void create_ui (CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  GtkWidget *main_window;  <span class="comment">/* The uppermost window, containing all other windows */</span></div><div class="line">  GtkWidget *video_window; <span class="comment">/* The drawing area where the video will be shown */</span></div><div class="line">  GtkWidget *main_box;     <span class="comment">/* VBox to hold main_hbox and the controls */</span></div><div class="line">  GtkWidget *main_hbox;    <span class="comment">/* HBox to hold the video_window and the stream info text widget */</span></div><div class="line">  GtkWidget *controls;     <span class="comment">/* HBox to hold the buttons and the slider */</span></div><div class="line">  GtkWidget *play_button, *pause_button, *stop_button; <span class="comment">/* Buttons */</span></div><div class="line"></div><div class="line">  main_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);</div><div class="line">  g_signal_connect (G_OBJECT (main_window), <span class="string">"delete-event"</span>, G_CALLBACK (delete_event_cb), <span class="keyword">data</span>);</div><div class="line"></div><div class="line">  video_window = gtk_drawing_area_new ();</div><div class="line">  gtk_widget_set_double_buffered (video_window, FALSE);</div><div class="line">  g_signal_connect (video_window, <span class="string">"realize"</span>, G_CALLBACK (realize_cb), <span class="keyword">data</span>);</div><div class="line">  g_signal_connect (video_window, <span class="string">"draw"</span>, G_CALLBACK (draw_cb), <span class="keyword">data</span>);</div><div class="line"></div><div class="line">  play_button = gtk_button_new_from_icon_name (<span class="string">"media-playback-start"</span>, GTK_ICON_SIZE_SMALL_TOOLBAR);</div><div class="line">  g_signal_connect (G_OBJECT (play_button), <span class="string">"clicked"</span>, G_CALLBACK (play_cb), <span class="keyword">data</span>);</div><div class="line"></div><div class="line">  pause_button = gtk_button_new_from_icon_name (<span class="string">"media-playback-pause"</span>, GTK_ICON_SIZE_SMALL_TOOLBAR);</div><div class="line">  g_signal_connect (G_OBJECT (pause_button), <span class="string">"clicked"</span>, G_CALLBACK (pause_cb), <span class="keyword">data</span>);</div><div class="line"></div><div class="line">  stop_button = gtk_button_new_from_icon_name (<span class="string">"media-playback-stop"</span>, GTK_ICON_SIZE_SMALL_TOOLBAR);</div><div class="line">  g_signal_connect (G_OBJECT (stop_button), <span class="string">"clicked"</span>, G_CALLBACK (stop_cb), <span class="keyword">data</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="title">data</span>-&gt;</span>slider = gtk_scale_new_with_range (GTK_ORIENTATION_HORIZONTAL, <span class="number">0</span>, <span class="number">100</span>, <span class="number">1</span>);</div><div class="line">  <span class="function"><span class="title">gtk_scale_set_draw_value</span> (GTK_SCALE (<span class="keyword">data</span>-&gt;</span>slider), <span class="number">0</span>);</div><div class="line">  <span class="function"><span class="title">data</span>-&gt;</span><span class="function"><span class="title">slider_update_signal_id</span> = g_signal_connect (G_OBJECT (<span class="keyword">data</span>-&gt;</span>slider), <span class="string">"value-changed"</span>, G_CALLBACK (slider_cb), <span class="keyword">data</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="title">data</span>-&gt;</span>streams_list = gtk_text_view_new ();</div><div class="line">  <span class="function"><span class="title">gtk_text_view_set_editable</span> (GTK_TEXT_VIEW (<span class="keyword">data</span>-&gt;</span>streams_list), FALSE);</div><div class="line"></div><div class="line">  controls = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, <span class="number">0</span>);</div><div class="line">  gtk_box_pack_start (GTK_BOX (controls), play_button, FALSE, FALSE, <span class="number">2</span>);</div><div class="line">  gtk_box_pack_start (GTK_BOX (controls), pause_button, FALSE, FALSE, <span class="number">2</span>);</div><div class="line">  gtk_box_pack_start (GTK_BOX (controls), stop_button, FALSE, FALSE, <span class="number">2</span>);</div><div class="line">  <span class="function"><span class="title">gtk_box_pack_start</span> (GTK_BOX (controls), <span class="keyword">data</span>-&gt;</span>slider, TRUE, TRUE, <span class="number">2</span>);</div><div class="line"></div><div class="line">  main_hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, <span class="number">0</span>);</div><div class="line">  gtk_box_pack_start (GTK_BOX (main_hbox), video_window, TRUE, TRUE, <span class="number">0</span>);</div><div class="line">  <span class="function"><span class="title">gtk_box_pack_start</span> (GTK_BOX (main_hbox), <span class="keyword">data</span>-&gt;</span>streams_list, FALSE, FALSE, <span class="number">2</span>);</div><div class="line"></div><div class="line">  main_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, <span class="number">0</span>);</div><div class="line">  gtk_box_pack_start (GTK_BOX (main_box), main_hbox, TRUE, TRUE, <span class="number">0</span>);</div><div class="line">  gtk_box_pack_start (GTK_BOX (main_box), controls, FALSE, FALSE, <span class="number">0</span>);</div><div class="line">  gtk_container_add (GTK_CONTAINER (main_window), main_box);</div><div class="line">  gtk_window_set_default_size (GTK_WINDOW (main_window), <span class="number">640</span>, <span class="number">480</span>);</div><div class="line"></div><div class="line">  gtk_widget_show_all (main_window);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called periodically to refresh the GUI */</span></div><div class="line">static gboolean refresh_ui (CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  gint64 current = -<span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* We do not want to update anything unless we are in the PAUSED or PLAYING states */</span></div><div class="line">  <span class="function"><span class="title">if</span> (<span class="keyword">data</span>-&gt;</span>state &lt; GST_STATE_PAUSED)</div><div class="line">    return TRUE;</div><div class="line"></div><div class="line">  <span class="comment">/* If we didn't know it yet, query the stream duration */</span></div><div class="line">  <span class="function"><span class="title">if</span> (!GST_CLOCK_TIME_IS_VALID (<span class="keyword">data</span>-&gt;</span>duration)) &#123;</div><div class="line">    <span class="function"><span class="title">if</span> (!gst_element_query_duration (<span class="keyword">data</span>-&gt;</span><span class="function"><span class="title">playbin</span>, GST_FORMAT_TIME, &amp;<span class="keyword">data</span>-&gt;</span>duration)) &#123;</div><div class="line">      g_printerr (<span class="string">"Could not query current duration.\n"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">/* Set the range of the slider to the clip duration, in SECONDS */</span></div><div class="line">      <span class="function"><span class="title">gtk_range_set_range</span> (GTK_RANGE (<span class="keyword">data</span>-&gt;</span><span class="function"><span class="title">slider</span>), 0, (gdouble)<span class="keyword">data</span>-&gt;</span>duration / GST_SECOND);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="title">if</span> (gst_element_query_position (<span class="keyword">data</span>-&gt;</span>playbin, GST_FORMAT_TIME, &amp;current)) &#123;</div><div class="line">    <span class="comment">/* Block the "value-changed" signal, so the slider_cb function is not called</span></div><div class="line"><span class="comment">     * (which would trigger a seek the user has not requested) */</span></div><div class="line">    <span class="function"><span class="title">g_signal_handler_block</span> (<span class="keyword">data</span>-&gt;</span><span class="function"><span class="title">slider</span>, <span class="keyword">data</span>-&gt;</span>slider_update_signal_id);</div><div class="line">    <span class="comment">/* Set the position of the slider to the current pipeline positoin, in SECONDS */</span></div><div class="line">    <span class="function"><span class="title">gtk_range_set_value</span> (GTK_RANGE (<span class="keyword">data</span>-&gt;</span>slider), (gdouble)current / GST_SECOND);</div><div class="line">    <span class="comment">/* Re-enable the signal */</span></div><div class="line">    <span class="function"><span class="title">g_signal_handler_unblock</span> (<span class="keyword">data</span>-&gt;</span><span class="function"><span class="title">slider</span>, <span class="keyword">data</span>-&gt;</span>slider_update_signal_id);</div><div class="line">  &#125;</div><div class="line">  return TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when new metadata is discovered in the stream */</span></div><div class="line">static void tags_cb (GstElement *playbin, gint stream, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  <span class="comment">/* We are possibly in a GStreamer working thread, so we notify the main</span></div><div class="line"><span class="comment">   * thread of this event through a message in the bus */</span></div><div class="line">  gst_element_post_message (playbin,</div><div class="line">    gst_message_new_application (GST_OBJECT (playbin),</div><div class="line">      gst_structure_new_empty (<span class="string">"tags-changed"</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when an error message is posted on the bus */</span></div><div class="line">static void error_cb (GstBus *bus, GstMessage *msg, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  GError *err;</div><div class="line">  gchar *debug_info;</div><div class="line"></div><div class="line">  <span class="comment">/* Print error details on the screen */</span></div><div class="line">  gst_message_parse_error (msg, &amp;err, &amp;debug_info);</div><div class="line">  <span class="function"><span class="title">g_printerr</span> ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg-&gt;</span><span class="function"><span class="title">src</span>), err-&gt;</span>message);</div><div class="line">  g_printerr (<span class="string">"Debugging information: %s\n"</span>, debug_info ? debug_info : <span class="string">"none"</span>);</div><div class="line">  g_clear_error (&amp;err);</div><div class="line">  g_free (debug_info);</div><div class="line"></div><div class="line">  <span class="comment">/* Set the pipeline to READY (which stops playback) */</span></div><div class="line">  <span class="function"><span class="title">gst_element_set_state</span> (<span class="keyword">data</span>-&gt;</span>playbin, GST_STATE_READY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when an End-Of-Stream message is posted on the bus.</span></div><div class="line"><span class="comment"> * We just set the pipeline to READY (which stops playback) */</span></div><div class="line">static void eos_cb (GstBus *bus, GstMessage *msg, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  g_print (<span class="string">"End-Of-Stream reached.\n"</span>);</div><div class="line">  <span class="function"><span class="title">gst_element_set_state</span> (<span class="keyword">data</span>-&gt;</span>playbin, GST_STATE_READY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when the pipeline changes states. We use it to</span></div><div class="line"><span class="comment"> * keep track of the current state. */</span></div><div class="line">static void state_changed_cb (GstBus *bus, GstMessage *msg, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  GstState old_state, new_state, pending_state;</div><div class="line">  gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);</div><div class="line">  <span class="function"><span class="title">if</span> (GST_MESSAGE_SRC (msg) == GST_OBJECT (<span class="keyword">data</span>-&gt;</span>playbin)) &#123;</div><div class="line">    <span class="function"><span class="title">data</span>-&gt;</span>state = new_state;</div><div class="line">    g_print (<span class="string">"State set to %s\n"</span>, gst_element_state_get_name (new_state));</div><div class="line">    <span class="keyword">if</span> (old_state == GST_STATE_READY &amp;&amp; new_state == GST_STATE_PAUSED) &#123;</div><div class="line">      <span class="comment">/* For extra responsiveness, we refresh the GUI as soon as we reach the PAUSED state */</span></div><div class="line">      refresh_ui (<span class="keyword">data</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Extract metadata from all the streams and write it to the text widget in the GUI */</span></div><div class="line">static void analyze_streams (CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  gint i;</div><div class="line">  GstTagList *tags;</div><div class="line">  gchar *str, *total_str;</div><div class="line">  guint rate;</div><div class="line">  gint n_video, n_audio, n_text;</div><div class="line">  GtkTextBuffer *<span class="keyword">text</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* Clean current contents of the widget */</span></div><div class="line">  <span class="function"><span class="title">text</span> = gtk_text_view_get_buffer (GTK_TEXT_VIEW (<span class="keyword">data</span>-&gt;</span>streams_list));</div><div class="line">  gtk_text_buffer_set_text (<span class="keyword">text</span>, <span class="string">""</span>, -<span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* Read some properties */</span></div><div class="line">  <span class="function"><span class="title">g_object_get</span> (<span class="keyword">data</span>-&gt;</span>playbin, <span class="string">"n-video"</span>, &amp;n_video, NULL);</div><div class="line">  <span class="function"><span class="title">g_object_get</span> (<span class="keyword">data</span>-&gt;</span>playbin, <span class="string">"n-audio"</span>, &amp;n_audio, NULL);</div><div class="line">  <span class="function"><span class="title">g_object_get</span> (<span class="keyword">data</span>-&gt;</span>playbin, <span class="string">"n-text"</span>, &amp;n_text, NULL);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_video; i++) &#123;</div><div class="line">    tags = NULL;</div><div class="line">    <span class="comment">/* Retrieve the stream's video tags */</span></div><div class="line">    <span class="function"><span class="title">g_signal_emit_by_name</span> (<span class="keyword">data</span>-&gt;</span>playbin, <span class="string">"get-video-tags"</span>, i, &amp;tags);</div><div class="line">    <span class="keyword">if</span> (tags) &#123;</div><div class="line">      total_str = g_strdup_printf (<span class="string">"video stream %d:\n"</span>, i);</div><div class="line">      gtk_text_buffer_insert_at_cursor (<span class="keyword">text</span>, total_str, -<span class="number">1</span>);</div><div class="line">      g_free (total_str);</div><div class="line">      gst_tag_list_get_string (tags, GST_TAG_VIDEO_CODEC, &amp;str);</div><div class="line">      total_str = g_strdup_printf (<span class="string">"  codec: %s\n"</span>, str ? str : <span class="string">"unknown"</span>);</div><div class="line">      gtk_text_buffer_insert_at_cursor (<span class="keyword">text</span>, total_str, -<span class="number">1</span>);</div><div class="line">      g_free (total_str);</div><div class="line">      g_free (str);</div><div class="line">      gst_tag_list_free (tags);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_audio; i++) &#123;</div><div class="line">    tags = NULL;</div><div class="line">    <span class="comment">/* Retrieve the stream's audio tags */</span></div><div class="line">    <span class="function"><span class="title">g_signal_emit_by_name</span> (<span class="keyword">data</span>-&gt;</span>playbin, <span class="string">"get-audio-tags"</span>, i, &amp;tags);</div><div class="line">    <span class="keyword">if</span> (tags) &#123;</div><div class="line">      total_str = g_strdup_printf (<span class="string">"\naudio stream %d:\n"</span>, i);</div><div class="line">      gtk_text_buffer_insert_at_cursor (<span class="keyword">text</span>, total_str, -<span class="number">1</span>);</div><div class="line">      g_free (total_str);</div><div class="line">      <span class="keyword">if</span> (gst_tag_list_get_string (tags, GST_TAG_AUDIO_CODEC, &amp;str)) &#123;</div><div class="line">        total_str = g_strdup_printf (<span class="string">"  codec: %s\n"</span>, str);</div><div class="line">        gtk_text_buffer_insert_at_cursor (<span class="keyword">text</span>, total_str, -<span class="number">1</span>);</div><div class="line">        g_free (total_str);</div><div class="line">        g_free (str);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) &#123;</div><div class="line">        total_str = g_strdup_printf (<span class="string">"  language: %s\n"</span>, str);</div><div class="line">        gtk_text_buffer_insert_at_cursor (<span class="keyword">text</span>, total_str, -<span class="number">1</span>);</div><div class="line">        g_free (total_str);</div><div class="line">        g_free (str);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (gst_tag_list_get_uint (tags, GST_TAG_BITRATE, &amp;rate)) &#123;</div><div class="line">        total_str = g_strdup_printf (<span class="string">"  bitrate: %d\n"</span>, rate);</div><div class="line">        gtk_text_buffer_insert_at_cursor (<span class="keyword">text</span>, total_str, -<span class="number">1</span>);</div><div class="line">        g_free (total_str);</div><div class="line">      &#125;</div><div class="line">      gst_tag_list_free (tags);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_text; i++) &#123;</div><div class="line">    tags = NULL;</div><div class="line">    <span class="comment">/* Retrieve the stream's subtitle tags */</span></div><div class="line">    <span class="function"><span class="title">g_signal_emit_by_name</span> (<span class="keyword">data</span>-&gt;</span>playbin, <span class="string">"get-text-tags"</span>, i, &amp;tags);</div><div class="line">    <span class="keyword">if</span> (tags) &#123;</div><div class="line">      total_str = g_strdup_printf (<span class="string">"\nsubtitle stream %d:\n"</span>, i);</div><div class="line">      gtk_text_buffer_insert_at_cursor (<span class="keyword">text</span>, total_str, -<span class="number">1</span>);</div><div class="line">      g_free (total_str);</div><div class="line">      <span class="keyword">if</span> (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) &#123;</div><div class="line">        total_str = g_strdup_printf (<span class="string">"  language: %s\n"</span>, str);</div><div class="line">        gtk_text_buffer_insert_at_cursor (<span class="keyword">text</span>, total_str, -<span class="number">1</span>);</div><div class="line">        g_free (total_str);</div><div class="line">        g_free (str);</div><div class="line">      &#125;</div><div class="line">      gst_tag_list_free (tags);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when an "application" message is posted on the bus.</span></div><div class="line"><span class="comment"> * Here we retrieve the message posted by the tags_cb callback */</span></div><div class="line">static void application_cb (GstBus *bus, GstMessage *msg, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (g_strcmp0 (gst_structure_get_name (gst_message_get_structure (msg)), <span class="string">"tags-changed"</span>) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">/* If the message is the "tags-changed" (only one we are currently issuing), update</span></div><div class="line"><span class="comment">     * the stream info GUI */</span></div><div class="line">    analyze_streams (<span class="keyword">data</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">  CustomData <span class="keyword">data</span>;</div><div class="line">  GstStateChangeReturn ret;</div><div class="line">  GstBus *bus;</div><div class="line"></div><div class="line">  <span class="comment">/* Initialize GTK */</span></div><div class="line">  gtk_init (&amp;argc, &amp;argv);</div><div class="line"></div><div class="line">  <span class="comment">/* Initialize GStreamer */</span></div><div class="line">  gst_init (&amp;argc, &amp;argv);</div><div class="line"></div><div class="line">  <span class="comment">/* Initialize our data structure */</span></div><div class="line">  memset (&amp;<span class="keyword">data</span>, <span class="number">0</span>, sizeof (<span class="keyword">data</span>));</div><div class="line">  <span class="keyword">data</span>.duration = GST_CLOCK_TIME_NONE;</div><div class="line"></div><div class="line">  <span class="comment">/* Create the elements */</span></div><div class="line">  <span class="keyword">data</span>.playbin = gst_element_factory_make (<span class="string">"playbin"</span>, <span class="string">"playbin"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">data</span>.playbin) &#123;</div><div class="line">    g_printerr (<span class="string">"Not all elements could be created.\n"</span>);</div><div class="line">    return -<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Set the URI to play */</span></div><div class="line">  g_object_set (<span class="keyword">data</span>.playbin, <span class="string">"uri"</span>, <span class="string">"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm"</span>, NULL);</div><div class="line"></div><div class="line">  <span class="comment">/* Connect to interesting signals in playbin */</span></div><div class="line">  g_signal_connect (G_OBJECT (<span class="keyword">data</span>.playbin), <span class="string">"video-tags-changed"</span>, (GCallback) tags_cb, &amp;<span class="keyword">data</span>);</div><div class="line">  g_signal_connect (G_OBJECT (<span class="keyword">data</span>.playbin), <span class="string">"audio-tags-changed"</span>, (GCallback) tags_cb, &amp;<span class="keyword">data</span>);</div><div class="line">  g_signal_connect (G_OBJECT (<span class="keyword">data</span>.playbin), <span class="string">"text-tags-changed"</span>, (GCallback) tags_cb, &amp;<span class="keyword">data</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* Create the GUI */</span></div><div class="line">  create_ui (&amp;<span class="keyword">data</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* Instruct the bus to emit signals for each received message, and connect to the interesting signals */</span></div><div class="line">  bus = gst_element_get_bus (<span class="keyword">data</span>.playbin);</div><div class="line">  gst_bus_add_signal_watch (bus);</div><div class="line">  g_signal_connect (G_OBJECT (bus), <span class="string">"message::error"</span>, (GCallback)error_cb, &amp;<span class="keyword">data</span>);</div><div class="line">  g_signal_connect (G_OBJECT (bus), <span class="string">"message::eos"</span>, (GCallback)eos_cb, &amp;<span class="keyword">data</span>);</div><div class="line">  g_signal_connect (G_OBJECT (bus), <span class="string">"message::state-changed"</span>, (GCallback)state_changed_cb, &amp;<span class="keyword">data</span>);</div><div class="line">  g_signal_connect (G_OBJECT (bus), <span class="string">"message::application"</span>, (GCallback)application_cb, &amp;<span class="keyword">data</span>);</div><div class="line">  gst_object_unref (bus);</div><div class="line"></div><div class="line">  <span class="comment">/* Start playing */</span></div><div class="line">  ret = gst_element_set_state (<span class="keyword">data</span>.playbin, GST_STATE_PLAYING);</div><div class="line">  <span class="keyword">if</span> (ret == GST_STATE_CHANGE_FAILURE) &#123;</div><div class="line">    g_printerr (<span class="string">"Unable to set the pipeline to the playing state.\n"</span>);</div><div class="line">    gst_object_unref (<span class="keyword">data</span>.playbin);</div><div class="line">    return -<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Register a function that GLib will call every second */</span></div><div class="line">  g_timeout_add_seconds (<span class="number">1</span>, (GSourceFunc)refresh_ui, &amp;<span class="keyword">data</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* Start the GTK main loop. We will not regain control until gtk_main_quit is called. */</span></div><div class="line">  gtk_main ();</div><div class="line"></div><div class="line">  <span class="comment">/* Free resources */</span></div><div class="line">  gst_element_set_state (<span class="keyword">data</span>.playbin, GST_STATE_NULL);</div><div class="line">  gst_object_unref (<span class="keyword">data</span>.playbin);</div><div class="line">  return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Required libraries: gstreamer-video-1.0 gtk+-3.0 gstreamer-1.0<br>所以此时编译需加上<code>pkg-config --cflags --libs gstreamer-video-1.0 gtk+-3.0 gstreamer-1.0</code>参数获取所需的头文件和库文件。<br>如果提示找不到gtk+-3.0,则安装。<code>sudo apt install build-essential libgtk-3-dev</code><br>提示未安装gstreamer-video-1.0，则安装。<code>sudo apt install libgstreamer-plugins-base1.0-dev</code><br>该例将会打开一个GTK+窗口并显示一个伴有音频的电影。媒体来自于互联网，所以窗口可能需要几秒才能显示，具体取决于网速。该窗口有一些按钮来暂停、停止和播放电影，还有个滑块显示当前位置，可以拖动或者改变它。此外，关于流的信息显示在右边的一列上。  </p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>本例中，函数不再在使用之前定义，代码呈现的顺序也不总是和程序顺序相匹配。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gdk/gdk.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (GDK_WINDOWING_X11)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gdk/gdkx.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined (GDK_WINDOWING_WIN32)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gdk/gdkwin32.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined (GDK_WINDOWING_QUARTZ)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gdk/gdkquartzwindow.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p><p>首先需要注意的是，现在并不是与平台完全无关的了，因为我们需要为所使用的窗口系统包含适当的头文件。幸运的是，没有那么多支持的窗口系统，所以X11 for Linux，Win32 for Windows和Quartz for Mac OSX这三行足够了。本例主要有回调函数组成，这些回调函数将从GStreamer或GTK+中调用。所以先看一下主函数，其中将会用到所有的回调函数。  </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">  CustomData data<span class="comment">;</span></div><div class="line">  GstStateChangeReturn ret<span class="comment">;</span></div><div class="line">  GstBus *<span class="keyword">bus;</span></div><div class="line"><span class="keyword"></span></div><div class="line"><span class="keyword"> </span> <span class="comment">/* Initialize GTK */</span></div><div class="line">  gtk_init (&amp;argc, &amp;argv)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Initialize GStreamer */</span></div><div class="line">  gst_init (&amp;argc, &amp;argv)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Initialize our data structure */</span></div><div class="line">  memset (&amp;data, <span class="number">0</span>, sizeof (data))<span class="comment">;</span></div><div class="line">  data.duration = GST_CLOCK_TIME_NONE<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Create the elements */</span></div><div class="line">  data.playbin = gst_element_factory_make (<span class="string">"playbin"</span>, <span class="string">"playbin"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">  if (!data.playbin) &#123;</div><div class="line">    g_printerr (<span class="string">"Not all elements could be created.\n"</span>)<span class="comment">;</span></div><div class="line">    return -<span class="number">1</span><span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Set the URI to play */</span></div><div class="line">  g_object_set (data.playbin, <span class="string">"uri"</span>, <span class="string">"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm"</span>, NULL)<span class="comment">;</span></div></pre></td></tr></table></figure><p>标准的GStreamer和playbin管道创建，以及GTK+初始化。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* Connect to interesting signals in playbin */</div><div class="line">g_signal_connect (<span class="name">G_OBJECT</span> (<span class="name">data</span>.playbin), <span class="string">"video-tags-changed"</span>, (<span class="name">GCallback</span>) tags_cb, <span class="symbol">&amp;data</span>)<span class="comment">;</span></div><div class="line">g_signal_connect (<span class="name">G_OBJECT</span> (<span class="name">data</span>.playbin), <span class="string">"audio-tags-changed"</span>, (<span class="name">GCallback</span>) tags_cb, <span class="symbol">&amp;data</span>)<span class="comment">;</span></div><div class="line">g_signal_connect (<span class="name">G_OBJECT</span> (<span class="name">data</span>.playbin), <span class="string">"text-tags-changed"</span>, (<span class="name">GCallback</span>) tags_cb, <span class="symbol">&amp;data</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>我们希望在流上出现新标签(元数据)时收到通知，为了简单起见，将处理来自相同回调函数<code>tag_cb</code>的所有种类标签(视频、音频和文本)。<br>然后创建GUI:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Create the GUI */</span></div><div class="line"><span class="symbol">create_ui</span> (&amp;<span class="meta">data</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>所有的GTK+部件创建和信号注册都发生在这个函数中，它只包含GTK相关的函数调用，所以可以跳过它的定义。其所注册的信号传递用户命令，如下面在查看回调时所示。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Instruct the bus to emit signals for each received message, and connect to the interesting signals */</span></div><div class="line">  <span class="keyword">bus </span>= gst_element_get_bus (<span class="meta">data</span>.playbin)<span class="comment">;</span></div><div class="line">  gst_bus_add_signal_watch (<span class="keyword">bus);</span></div><div class="line"><span class="keyword"> </span> g_signal_connect (G_OBJECT (<span class="keyword">bus), </span><span class="string">"message::error"</span>, (GCallback)error_cb, &amp;<span class="meta">data</span>)<span class="comment">;</span></div><div class="line">  g_signal_connect (G_OBJECT (<span class="keyword">bus), </span><span class="string">"message::eos"</span>, (GCallback)eos_cb, &amp;<span class="meta">data</span>)<span class="comment">;</span></div><div class="line">  g_signal_connect (G_OBJECT (<span class="keyword">bus), </span><span class="string">"message::state-changed"</span>, (GCallback)state_changed_cb, &amp;<span class="meta">data</span>)<span class="comment">;</span></div><div class="line">  g_signal_connect (G_OBJECT (<span class="keyword">bus), </span><span class="string">"message::application"</span>, (GCallback)application_cb, &amp;<span class="meta">data</span>)<span class="comment">;</span></div><div class="line">  gst_object_unref (<span class="keyword">bus);</span></div></pre></td></tr></table></figure></p><p>其中，<code>gst_bus_add_watch</code>函数用于注册用于接收所有的消息并发送给GStreamer总线。可以通过使用信号来达到更精细的粒度，这使得我们仅注册感兴趣的消息。<br>通过调用<code>gst_bus_add_signal_watch</code>函数，我们指导总线在每次收到一个消息时发出一个信号。信号名称是<code>message::detail</code>，其中‘detail’是触发信号发出的消息。例如，当总线接收到EOS消息时，将发出一个名为<code>message::eos</code>的信号。<br>例中仅使用信号描述(detail)来注册所感兴趣的消息。如果我们注册了一个消息的信号，我们将收到每个消息的通知，如<code>gst_bus_add_watch</code>函数所做的一样。<br>为了使“bus watches”工作（无论是<code>gst_bus_add_watch</code>还是<code>gst_bus_add_signal_watch</code>），必须运行GLib主循环。这种情况下，它隐藏在GTK+主循环中。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Register a function that GLib will call every second */</span></div><div class="line"><span class="symbol">g_timeout_add_seconds</span> (<span class="number">1</span>, (GSourceFunc)refresh_ui, &amp;<span class="meta">data</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>在将控制移交给GTK+之前，使用<code>g_timeout_add_seconds</code>函数来注册另一个回调函数————超时，且每秒会被调用：用其从<code>refresh_ui</code>函数刷新GUI。<br>在这之后，我们完成了建立并启动GTK+主循环。感兴趣的事件发生时，将从回调函数中重新获取控制权。每个回调函数都有不同的签名，具体取决于调用者。可以再信号的文档中查找签名(参数的含义和返回值)。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This function is called when the GUI toolkit creates the physical window that will hold the video.</span></div><div class="line"><span class="comment"> * At this point we can retrieve its handler (which has a different meaning depending on the windowing system)</span></div><div class="line"><span class="comment"> * and pass it to GStreamer through the VideoOverlay interface. */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">realize_cb</span> <span class="params">(GtkWidget *widget, CustomData *data)</span> </span>&#123;</div><div class="line">  GdkWindow *window = gtk_widget_get_window (widget);</div><div class="line">  guintptr window_handle;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!gdk_window_ensure_native (window))</div><div class="line">    g_error (<span class="string">"Couldn't create native window needed for GstVideoOverlay!"</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* Retrieve window handler from GDK */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (GDK_WINDOWING_WIN32)</span></div><div class="line">  window_handle = (guintptr)GDK_WINDOW_HWND (window);</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined (GDK_WINDOWING_QUARTZ)</span></div><div class="line">  window_handle = gdk_quartz_window_get_nsview (window);</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined (GDK_WINDOWING_X11)</span></div><div class="line">  window_handle = GDK_WINDOW_XID (window);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  <span class="comment">/* Pass it to playbin, which implements VideoOverlay and will forward it to the video sink */</span></div><div class="line">  gst_video_overlay_set_window_handle (GST_VIDEO_OVERLAY (data-&gt;playbin), window_handle);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在应用程序生命周期的这一点上，我们知道GStreamer应该呈现视频的窗口句柄（无论是X11的XID，Window的HWND还是Quartz的NSView）。我们只需从窗口系统中检索它，并使用<code>gst_video_overlay_set_window_handle</code>通过GstVideoOverlay接口将其传递给playbin。playbin将定位视频接收器并将处理程序传递给它，所以它不会创建自己的窗口并使用它。playbin和GstVideoOverlay将此过程简化了许多。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This function is called when the PLAY button is clicked */</span></div><div class="line">static void play_cb (GtkButton *button, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  <span class="function"><span class="title">gst_element_set_state</span> (<span class="keyword">data</span>-&gt;</span>playbin, GST_STATE_PLAYING);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when the PAUSE button is clicked */</span></div><div class="line">static void pause_cb (GtkButton *button, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  <span class="function"><span class="title">gst_element_set_state</span> (<span class="keyword">data</span>-&gt;</span>playbin, GST_STATE_PAUSED);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function is called when the STOP button is clicked */</span></div><div class="line">static void stop_cb (GtkButton *button, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  <span class="function"><span class="title">gst_element_set_state</span> (<span class="keyword">data</span>-&gt;</span>playbin, GST_STATE_READY);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这三个回调函数是关于GUI的播放，暂停和停止按钮的，它们只需要将管道设置为相应的状态即可。值得注意的是，在STOP状态下，将管道状态设置为READY。可以将流水线一直带到NULL状态，但是会导致过渡慢一点，因为有些资源(如音频设备)需要重新释放重新获取。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This function is called when the main window is closed */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event_cb</span> <span class="params">(GtkWidget *widget, GdkEvent *event, CustomData *data)</span> </span>&#123;</div><div class="line">  stop_cb (<span class="literal">NULL</span>, data);</div><div class="line">  gtk_main_quit ();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>gtk_main_quit</code>最终会在main中调用<code>gtk_main_run</code>来终止，并在这种情况下完成整个程序。这里，在停止管道(只是为了整洁)后，当主窗口关闭时调用它。  </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This function is called everytime the video window needs to be redrawn (due to damage/exposure,</span></div><div class="line"><span class="comment"> * rescaling, etc). GStreamer takes care of this in the PAUSED and PLAYING states, otherwise,</span></div><div class="line"><span class="comment"> * we simply draw a black rectangle to avoid garbage showing up. */</span></div><div class="line">static gboolean draw_cb (GtkWidget *widget, cairo_t *cr, CustomData *data) &#123;</div><div class="line">  if (data-&gt;<span class="section">state</span> &lt; GST_STATE_PAUSED) &#123;</div><div class="line">    GtkAllocation allocation;</div><div class="line"></div><div class="line">    <span class="comment">/* Cairo is a 2D graphics library which we use here to clean the video window.</span></div><div class="line"><span class="comment">     * It is used by GStreamer for other reasons, so it will always be available to us. */</span></div><div class="line">    gtk_widget_get_allocation (widget, &amp;allocation);</div><div class="line">    cairo_set_source_rgb (cr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cairo_rectangle (cr, <span class="number">0</span>, <span class="number">0</span>, allocation.width, allocation.height);</div><div class="line">    cairo_fill (cr);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return <span class="literal">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当有数据流时（处于PAUSED和PLAYING状态），视频接收器负责刷新视频窗口的内容。但其他情况下不会这样，所以必须我们自己来做: 例中我们是使用一个黑色的矩形填充窗口。  </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This function is called when the slider changes its position. We perform a seek to the</span></div><div class="line"><span class="comment"> * new position here. */</span></div><div class="line">static void slider_cb (GtkRange *range, CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  <span class="function"><span class="title">gdouble</span> value = gtk_range_get_value (GTK_RANGE (<span class="keyword">data</span>-&gt;</span>slider));</div><div class="line">  <span class="function"><span class="title">gst_element_seek_simple</span> (<span class="keyword">data</span>-&gt;</span>playbin, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT,</div><div class="line">      (gint64)(value * GST_SECOND));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过GStreamer和GTK+的协作，可以非常容易地实现一个复杂的GUI元素，如一个搜索条（或者允许搜索的滑块）。如果滑块被拖动到新位置，则告诉GStreamer使用<code>gst_element_seek_simple</code>查找该位置。 滑块已经设置，它的值代表秒。<br>值得注意的是，一些性能和响应可以通过不去响应所有的单个用户的搜索请求来获得。由于搜索操作需要花费一些时间，所以在允许另一个搜索操作之前，更好的办法是等待一会(如半秒钟)。否则，如果用户疯狂的拖拽滑动条，应用程序看起来可能也没有响应，因为在一个新的搜索操作在队列中之前将不会允许任何搜索。  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This function is called periodically to refresh the GUI */</span></div><div class="line">static gboolean refresh_ui (CustomData *<span class="keyword">data</span>) &#123;</div><div class="line">  gint64 current = <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* We do not want to update anything unless we are in the PAUSED or PLAYING states */</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">data</span>-&gt;state &lt; GST_STATE_PAUSED)</div><div class="line">    <span class="keyword">return</span> TRUE;</div></pre></td></tr></table></figure><p>该函数将移动滑块以反映媒体当前的位置。如果我们不处于PLAYING状态，那么在这里没有任何事情可做（位置和持续时间查询通常会失败）。  </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* If we didn't know it yet, query the stream duration */</span></div><div class="line"><span class="function"><span class="title">if</span> (!GST_CLOCK_TIME_IS_VALID (<span class="keyword">data</span>-&gt;</span>duration)) &#123;</div><div class="line">  <span class="function"><span class="title">if</span> (!gst_element_query_duration (<span class="keyword">data</span>-&gt;</span><span class="function"><span class="title">playbin</span>, GST_FORMAT_TIME, &amp;<span class="keyword">data</span>-&gt;</span>duration)) &#123;</div><div class="line">    g_printerr (<span class="string">"Could not query current duration.\n"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">/* Set the range of the slider to the clip duration, in SECONDS */</span></div><div class="line">    <span class="function"><span class="title">gtk_range_set_range</span> (GTK_RANGE (<span class="keyword">data</span>-&gt;</span><span class="function"><span class="title">slider</span>), 0, (gdouble)<span class="keyword">data</span>-&gt;</span>duration / GST_SECOND);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以设置滑块的范围以防我们在不知情的情况下恢复clip的持续时间。  </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">if</span> (gst_element_query_position (<span class="keyword">data</span>-&gt;</span>playbin, GST_FORMAT_TIME, &amp;current)) &#123;</div><div class="line">  <span class="comment">/* Block the "value-changed" signal, so the slider_cb function is not called</span></div><div class="line"><span class="comment">   * (which would trigger a seek the user has not requested) */</span></div><div class="line">  <span class="function"><span class="title">g_signal_handler_block</span> (<span class="keyword">data</span>-&gt;</span><span class="function"><span class="title">slider</span>, <span class="keyword">data</span>-&gt;</span>slider_update_signal_id);</div><div class="line">  <span class="comment">/* Set the position of the slider to the current pipeline positoin, in SECONDS */</span></div><div class="line">  <span class="function"><span class="title">gtk_range_set_value</span> (GTK_RANGE (<span class="keyword">data</span>-&gt;</span>slider), (gdouble)current / GST_SECOND);</div><div class="line">  <span class="comment">/* Re-enable the signal */</span></div><div class="line">  <span class="function"><span class="title">g_signal_handler_unblock</span> (<span class="keyword">data</span>-&gt;</span><span class="function"><span class="title">slider</span>, <span class="keyword">data</span>-&gt;</span>slider_update_signal_id);</div><div class="line">&#125;</div><div class="line">return TRUE;</div></pre></td></tr></table></figure><p>查询当前的管道位置，并根据滑块设置其位置。这将会触发一个<code>value-changed</code>信号，我们可以通过其知道用户在拖动滑块。除非用户请求它们，否则我们不希望发生这种情况，所以在此操作期间，使用<code>g_sinal_handler_block</code>和<code>g_signal_handler_unblock</code>禁用<code>value-changed</code>的信号发出。<br>该函数返回True将在之后保持其调用。如果返回FALSE，定时器将被删除。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This function is called when new metadata is discovered in the stream */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tags_cb</span> <span class="params">(GstElement *playbin, gint stream, CustomData *data)</span> </span>&#123;</div><div class="line">  <span class="comment">/* We are possibly in a GStreamer working thread, so we notify the main</span></div><div class="line"><span class="comment">   * thread of this event through a message in the bus */</span></div><div class="line">  gst_element_post_message (playbin,</div><div class="line">    gst_message_new_application (GST_OBJECT (playbin),</div><div class="line">      gst_structure_new_empty (<span class="string">"tags-changed"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里是该例的重点。当媒体中发现新标签时，该函数将会从streaming线程中调用，即从一个应用程序线程(或主线程)之外的线程调用。我们这里希望做的是更新GTK+的部件来反映这个新的信息，但GTK+不允许主线程之外的其它线程的操作。<br>解决方法是让playbin在总线上发布消息并返回给调用线程。在适当时候，主线程会接收到这个消息并更新GTK。<br><code>gst_element_post_message</code>函数使GStreamer元素将给定的消息发送到总线。<code>gst_message_new_application</code>函数创建一个新的应用程序类型的消息。GStreamer消息有不同的类型，且这种特殊类型将保留给应用程序:它会通过不受GStreamer影响的总线。<br>类型列表可在GstMessageType文档中找到。<br>消息可以通过嵌入的GstStructure提供额外的信息，GstStructure是一个非常灵活的数据容器。这里使用<code>gst_structure_new</code>创建一个新结构体，并将其命名为tags-changed，以避免在我们想发送其它应用程序消息时发生混淆。<br>然后，一旦在主线程中，总线将会收到这个消息并发送<code>message::application</code>信号，该信号与<code>application_cb</code>函数关联:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This function is called when an "application" message is posted on the bus.</span></div><div class="line"><span class="comment"> * Here we retrieve the message posted by the tags_cb callback */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">application_cb</span> <span class="params">(GstBus *bus, GstMessage *msg, CustomData *data)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (g_strcmp0 (gst_structure_get_name (gst_message_get_structure (msg)), <span class="string">"tags-changed"</span>) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">/* If the message is the "tags-changed" (only one we are currently issuing), update</span></div><div class="line"><span class="comment">     * the stream info GUI */</span></div><div class="line">    analyze_streams (data);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>一旦确定它是标签变化(tag-changed)消息，则调用<code>analyze_streams</code>函数。其基本上从流中恢复标签，并将其写入GUI中的文本小部件中。<br>虽然该例代码量较大，但所需的概念很少且很容易。<br>最后效果图如下:</p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190906101926.png" alt=""><br></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是关于如何将GStreamer集成到图形用户界面(GUI)工具箱中。基本上当GUI工具箱处理用户界面时，GStreamer主要负责媒体播放。其中两个库必须交互的部分是最有趣的两个部分，即:指导GStreamer将视频输出到GTK+的窗口中并将用户操作转发给GStreamer。&lt;br&gt;
    
    </summary>
    
      <category term="TX1入坑" scheme="http://dfine.tech/categories/TX1%E5%85%A5%E5%9D%91/"/>
    
    
      <category term="Linux" scheme="http://dfine.tech/tags/Linux/"/>
    
      <category term="GStreamer" scheme="http://dfine.tech/tags/GStreamer/"/>
    
      <category term="TX1" scheme="http://dfine.tech/tags/TX1/"/>
    
  </entry>
  
  <entry>
    <title>GStreamer笔记三: Time Management</title>
    <link href="http://dfine.tech/posts/58b8a847/"/>
    <id>http://dfine.tech/posts/58b8a847/</id>
    <published>2017-12-03T06:41:37.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>主要是关于如何使用GStreamer中的时间相关工具，如查询Pipeline的位置或者持续时间等信息，以及寻找或者跳转到Stream中的不同位置——时间点的方法。<br><a id="more"></a></p><h3 id="关于GstQuery"><a href="#关于GstQuery" class="headerlink" title="关于GstQuery"></a>关于GstQuery</h3><p>GstQuery是GStreamer中用于查询element和pad信息的一种机制。此篇所用例中首先需要询问是否支持寻找(seek)，因为有一些源，如live stream，并不支持跳转。本例在确定支持跳转后，一旦电影播放10s后，就是用seek函数跳转到一个不同的时间点。<br>在之前的例子中，一旦建立其了Pipeline并开始运行，主函数所做的事仅仅是坐等接收来自总线(bus)的ERROR或者EOS信息。这里将会修改这个函数来周期性的唤醒并查询Pipeline的位置，所以可以将其输出在屏幕上。有点类似于一个媒体播放器定期更新用户接口。<br>最终，在stream持续时间改变后就会重新查询和更新。  </p><h3 id="Seeking示例"><a href="#Seeking示例" class="headerlink" title="Seeking示例"></a>Seeking示例</h3><p>一个有关seeking时间点的示例如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line">#include &lt;gst/gst.h&gt;</div><div class="line"><span class="comment">/* Structure to contain all our information, so we can pass it around */</span></div><div class="line">typedef struct _CustomData &#123;</div><div class="line">  GstElement *playbin;  <span class="comment">/* Our one and only element */</span></div><div class="line">  gboolean playing;      <span class="comment">/* Are we in the PLAYING state? */</span></div><div class="line">  gboolean terminate;    <span class="comment">/* Should we terminate execution? */</span></div><div class="line">  gboolean seek_enabled; <span class="comment">/* Is seeking enabled for this media? */</span></div><div class="line">  gboolean seek_done;    <span class="comment">/* Have we performed the seek already? */</span></div><div class="line">  gint64 duration;       <span class="comment">/* How long does this media last, in nanoseconds */</span></div><div class="line">&#125; CustomData;</div><div class="line"></div><div class="line"><span class="comment">/* Forward definition of the message processing function */</span></div><div class="line">static void handle_message (CustomData *<span class="keyword">data</span>, GstMessage *msg);</div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">  CustomData <span class="keyword">data</span>;</div><div class="line">  GstBus *bus;</div><div class="line">  GstMessage *msg;</div><div class="line">  GstStateChangeReturn ret;</div><div class="line"></div><div class="line">  <span class="keyword">data</span>.playing = FALSE;</div><div class="line">  <span class="keyword">data</span>.terminate = FALSE;</div><div class="line">  <span class="keyword">data</span>.seek_enabled = FALSE;</div><div class="line">  <span class="keyword">data</span>.seek_done = FALSE;</div><div class="line">  <span class="keyword">data</span>.duration = GST_CLOCK_TIME_NONE;</div><div class="line"></div><div class="line">  <span class="comment">/* Initialize GStreamer */</span></div><div class="line">  gst_init (&amp;argc, &amp;argv);</div><div class="line"></div><div class="line">  <span class="comment">/* Create the elements */</span></div><div class="line">  <span class="keyword">data</span>.playbin = gst_element_factory_make (<span class="string">"playbin"</span>, <span class="string">"playbin"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">data</span>.playbin) &#123;</div><div class="line">    g_printerr (<span class="string">"Not all elements could be created.\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Set the URI to play */</span></div><div class="line">  g_object_set (<span class="keyword">data</span>.playbin, <span class="string">"uri"</span>, <span class="string">"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm"</span>, NULL);</div><div class="line"></div><div class="line">  <span class="comment">/* Start playing */</span></div><div class="line">  ret = gst_element_set_state (<span class="keyword">data</span>.playbin, GST_STATE_PLAYING);</div><div class="line">  <span class="keyword">if</span> (ret == GST_STATE_CHANGE_FAILURE) &#123;</div><div class="line">    g_printerr (<span class="string">"Unable to set the pipeline to the playing state.\n"</span>);</div><div class="line">    gst_object_unref (<span class="keyword">data</span>.playbin);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Listen to the bus */</span></div><div class="line">  bus = gst_element_get_bus (<span class="keyword">data</span>.playbin);</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    msg = gst_bus_timed_pop_filtered (bus, <span class="number">100</span> * GST_MSECOND,</div><div class="line">        GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS | GST_MESSAGE_DURATION);</div><div class="line"></div><div class="line">    <span class="comment">/* Parse message */</span></div><div class="line">    <span class="keyword">if</span> (msg != NULL) &#123;</div><div class="line">      handle_message (&amp;<span class="keyword">data</span>, msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">/* We got no message, this means the timeout expired */</span></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">data</span>.playing) &#123;</div><div class="line">        gint64 current = <span class="number">-1</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Query the current position of the stream */</span></div><div class="line">        <span class="keyword">if</span> (!gst_element_query_position (<span class="keyword">data</span>.playbin, GST_FORMAT_TIME, &amp;current)) &#123;</div><div class="line">          g_printerr (<span class="string">"Could not query current position.\n"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* If we didn't know it yet, query the stream duration */</span></div><div class="line">        <span class="keyword">if</span> (!GST_CLOCK_TIME_IS_VALID (<span class="keyword">data</span>.duration)) &#123;</div><div class="line">          <span class="keyword">if</span> (!gst_element_query_duration (<span class="keyword">data</span>.playbin, GST_FORMAT_TIME, &amp;<span class="keyword">data</span>.duration)) &#123;</div><div class="line">            g_printerr (<span class="string">"Could not query current duration.\n"</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Print current position and total duration */</span></div><div class="line">        g_print (<span class="string">"Position %"</span> GST_TIME_FORMAT <span class="string">" / %"</span> GST_TIME_FORMAT <span class="string">"\r"</span>,</div><div class="line">            GST_TIME_ARGS (current), GST_TIME_ARGS (<span class="keyword">data</span>.duration));</div><div class="line"></div><div class="line">        <span class="comment">/* If seeking is enabled, we have not done it yet, and the time is right, seek */</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">data</span>.seek_enabled &amp;&amp; !<span class="keyword">data</span>.seek_done &amp;&amp; current &gt; <span class="number">10</span> * GST_SECOND) &#123;</div><div class="line">          g_print (<span class="string">"\nReached 10s, performing seek...\n"</span>);</div><div class="line">          gst_element_seek_simple (<span class="keyword">data</span>.playbin, GST_FORMAT_TIME,</div><div class="line">              GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, <span class="number">30</span> * GST_SECOND);</div><div class="line">          <span class="keyword">data</span>.seek_done = TRUE;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (!<span class="keyword">data</span>.terminate);</div><div class="line"></div><div class="line">  <span class="comment">/* Free resources */</span></div><div class="line">  gst_object_unref (bus);</div><div class="line">  gst_element_set_state (<span class="keyword">data</span>.playbin, GST_STATE_NULL);</div><div class="line">  gst_object_unref (<span class="keyword">data</span>.playbin);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void handle_message (CustomData *<span class="keyword">data</span>, GstMessage *msg) &#123;</div><div class="line">  GError *err;</div><div class="line">  gchar *debug_info;</div><div class="line"></div><div class="line">  switch (GST_MESSAGE_TYPE (msg)) &#123;</div><div class="line">    case GST_MESSAGE_ERROR:</div><div class="line">      gst_message_parse_error (msg, &amp;err, &amp;debug_info);</div><div class="line">      g_printerr (<span class="string">"Error received from element %s: %s\n"</span>, GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);</div><div class="line">      g_printerr (<span class="string">"Debugging information: %s\n"</span>, debug_info ? debug_info : <span class="string">"none"</span>);</div><div class="line">      g_clear_error (&amp;err);</div><div class="line">      g_free (debug_info);</div><div class="line">      <span class="keyword">data</span>-&gt;terminate = TRUE;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    case GST_MESSAGE_EOS:</div><div class="line">      g_print (<span class="string">"End-Of-Stream reached.\n"</span>);</div><div class="line">      <span class="keyword">data</span>-&gt;terminate = TRUE;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    case GST_MESSAGE_DURATION:</div><div class="line">      <span class="comment">/* The duration has changed, mark the current one as invalid */</span></div><div class="line">      <span class="keyword">data</span>-&gt;duration = GST_CLOCK_TIME_NONE;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    case GST_MESSAGE_STATE_CHANGED: &#123;</div><div class="line">      GstState old_state, new_state, pending_state;</div><div class="line">      gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);</div><div class="line">      <span class="keyword">if</span> (GST_MESSAGE_SRC (msg) == GST_OBJECT (<span class="keyword">data</span>-&gt;playbin)) &#123;</div><div class="line">        g_print (<span class="string">"Pipeline state changed from %s to %s:\n"</span>,</div><div class="line">            gst_element_state_get_name (old_state), gst_element_state_get_name (new_state));</div><div class="line"></div><div class="line">        <span class="comment">/* Remember whether we are in the PLAYING state or not */</span></div><div class="line">        <span class="keyword">data</span>-&gt;playing = (new_state == GST_STATE_PLAYING);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">data</span>-&gt;playing) &#123;</div><div class="line">          <span class="comment">/* We just moved to PLAYING. Check if seeking is possible */</span></div><div class="line">          GstQuery *query;</div><div class="line">          gint64 start, end;</div><div class="line">          query = gst_query_new_seeking (GST_FORMAT_TIME);</div><div class="line">          <span class="keyword">if</span> (gst_element_query (<span class="keyword">data</span>-&gt;playbin, query)) &#123;</div><div class="line">            gst_query_parse_seeking (query, NULL, &amp;<span class="keyword">data</span>-&gt;seek_enabled, &amp;start, &amp;end);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">data</span>-&gt;seek_enabled) &#123;</div><div class="line">              g_print (<span class="string">"Seeking is ENABLED from %"</span> GST_TIME_FORMAT <span class="string">" to %"</span> GST_TIME_FORMAT <span class="string">"\n"</span>,</div><div class="line">                  GST_TIME_ARGS (start), GST_TIME_ARGS (end));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              g_print (<span class="string">"Seeking is DISABLED for this stream.\n"</span>);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">else</span> &#123;</div><div class="line">            g_printerr (<span class="string">"Seeking query failed."</span>);</div><div class="line">          &#125;</div><div class="line">          gst_query_unref (query);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="comment">/* We should not reach here */</span></div><div class="line">      g_printerr (<span class="string">"Unexpected message received.\n"</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  gst_message_unref (msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该段代码会打开并显示一个伴有音频的一个电影，由于媒体来自于网络，所以窗口可能需要一会才能显示出来，具体取决于网速。并在电影十秒钟后跳转到一个新的位置。  </p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>首先建立一个可以传递给其他函数的含有所有信息的结构体:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Structure to contain all our information, so we can pass it around */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CustomData</span> &#123;</span></div><div class="line">  GstElement *playbin;  <span class="comment">/* Our one and only element */</span></div><div class="line">  gboolean playing;      <span class="comment">/* Are we in the PLAYING state? */</span></div><div class="line">  gboolean terminate;    <span class="comment">/* Should we terminate execution? */</span></div><div class="line">  gboolean seek_enabled; <span class="comment">/* Is seeking enabled for this media? */</span></div><div class="line">  gboolean seek_done;    <span class="comment">/* Have we performed the seek already? */</span></div><div class="line">  gint64 duration;       <span class="comment">/* How long does this media last, in nanoseconds */</span></div><div class="line">&#125; CustomData;</div><div class="line"></div><div class="line"><span class="comment">/* Forward definition of the message processing function */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_message</span> <span class="params">(CustomData *data, GstMessage *msg)</span></span>;</div></pre></td></tr></table></figure><p>这里由于信息处理代码会变得越来越大，因此将其移到了<code>handle_message</code>函数中。<br>然后建立了一个包含单个元素(playbin)的Pipeline，然而playbin本身就是一个Pipeline，而且这种情况下，他是Pipeline中唯一的element，所以直接使用playbin。<br>这里跳过一些细节:该clip的URI通过URI属性给playbin，并将Pipeline设置为播放状态。  </p><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">msg = gst_bus_timed_pop_filtered (bus, <span class="number">100</span> * GST_MSECOND,</div><div class="line">    GST_MESSAGE_STATE_CHANGED | <span class="type">GST_MESSAGE_ERROR</span> | <span class="type">GST_MESSAGE_EOS</span> | <span class="type">GST_MESSAGE_DURATION</span>);</div></pre></td></tr></table></figure><p>之前没有给<code>gst_bus_timed_pop_filtered</code>函数提供超时参数，因此它在收到消息前不会返回。这里使用100ms的超时，所以如果在0.1s内没有收到任何消息，函数将返回NULL，并通过这个方法来更新UI。<br>需要注意的是，所有的超时时间必须指定为GstClockTime，所以都是以纳秒为单位的，表示不同时间单位的数字应该乘以宏如GST_SECOND或GST_MSECOND。也能使代码更具可读性。<br>如果收到消息，则通过<code>handle_message</code>函数处理它。否则刷新用户接口(UI)。  </p><h4 id="用户接口刷新"><a href="#用户接口刷新" class="headerlink" title="用户接口刷新"></a>用户接口刷新</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* We got no message, this means the timeout expired */</span></div><div class="line"><span class="keyword">if</span> <span class="comment">(data.playing)</span> &#123;</div></pre></td></tr></table></figure><p>如果Pipeline处于PLAYING状态，则刷新屏幕。在非PLAYING状态下我们不想做任何事，因为大多数查询都会失败。<br>这里的刷新率大约是每秒10次，对于我们的UI来说已经足够。同时将在屏幕上打印出当前媒体的位置以便了解管道查询。这涉及到几个步骤，之后再说，但是位置和持续时间是比较常见的查询，所以GStreamer提供了更容易的现成的备选方案:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Query the current position of the stream */</span></div><div class="line"><span class="keyword">if</span> (!gst_element_query_position (<span class="keyword">data</span>.pipeline, GST_FORMAT_TIME, &amp;current)) &#123;</div><div class="line">  g_printerr (<span class="string">"Could not query current position.\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中，<code>gst_element_query_position</code>函数隐藏了查询对象的管理并直接提供结果。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* If we didn't know it yet, query the stream duration */</span></div><div class="line"><span class="keyword">if</span> (!GST_CLOCK_TIME_IS_VALID (<span class="built_in">data</span>.<span class="built_in">duration</span>)) &#123;</div><div class="line">  <span class="keyword">if</span> (!gst_element_query_duration (<span class="built_in">data</span>.pipeline, GST_FORMAT_TIME, &amp;<span class="built_in">data</span>.<span class="built_in">duration</span>)) &#123;</div><div class="line">     g_printerr (<span class="string">"Could not query current duration.\n"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中，<code>gst_element_query_duration</code>用于函数查询流的长度。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* Print current position and total duration */</div><div class="line">g_print (<span class="string">"Position %"</span> GST_TIME_FORMAT <span class="string">" / %"</span> GST_TIME_FORMAT <span class="string">"\r"</span>,</div><div class="line">    GST_TIME_ARGS (<span class="name">current</span>), GST_TIME_ARGS (<span class="name">data</span>.duration))<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>这里使用<code>GST_TIME_FORMAT</code>和<code>GST_TIME_ARGS</code>宏来提供对GStreamer时间的对用户友好的表示。  </p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* <span class="keyword">If</span> seeking <span class="keyword">is</span> enabled, we have <span class="keyword">not</span> done it yet, <span class="keyword">and</span> the <span class="built_in">time</span> <span class="keyword">is</span> <span class="built_in">right</span>, seek */</div><div class="line"><span class="keyword">if</span> (data.seek_enabled &amp;&amp; !data.seek_done &amp;&amp; current &gt; <span class="number">10</span> * GST_SECOND) &#123;</div><div class="line">  g_print (<span class="string">"\nReached 10s, performing seek...\n"</span>);</div><div class="line">  gst_element_seek_simple (data.pipeline, GST_FORMAT_TIME,</div><div class="line">      GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, <span class="number">30</span> * GST_SECOND);</div><div class="line">  data.seek_done = <span class="literal">TRUE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在在管道上调用<code>gst_element_seek_simple</code>函数进行查找，这种方法的好处是隐藏了许多复杂的问题。  </p><h5 id="参数回顾"><a href="#参数回顾" class="headerlink" title="参数回顾"></a>参数回顾</h5><p>GST_FORMAT_TIME: 表示以时间单位指定目标位置，其他的查找格式使用不同的单位。<br>然后是一些GstSeekFlags，其中常见的一些如下:</p><ul><li>GST_SEEK_FLAG_FLUSH: 会在seek之前丢弃当前Pipeline中的所有数据。当Pipeline被重新填充且新的数据开始出现时，可能会暂停一下，但是极大增加了应用程序的响应能力。因为如果没有这个标志，旧数据可能会一直显示，直到新的数据出现在Pipeline末端。  </li><li>GST_SEEK_FLAG_KEY_UNIT: 对于大多数编码视频流，寻找到任意位置是不可能的，因为仅限于某些称为关键帧的帧。使用这个标识时，seek操作实际上会移动到最近的关键帧并开始产生数据。不使用这个标志的话，Pipeline将会在内部移动到最近的关键帧(没有其他选择)，但是直到到达要求的位置才会显示数据。后面一种方法更精确，但是可能需要更长的时间。  </li><li>GST_SEEK_FLAG_ACCURATE: 查找精度标识。在一些媒体clips没有提供足够的索引信息时，查找任意位置是耗时的。在这些情况下，GStreamer通常会估计要寻找的位置，而且完成的比较好。如果这个精度对于你的情况来说不够好(看到的不是要求的精确时间)，则提供该标识。但是值得注意的是，计算寻找位置可能花费更长时间(在一些文件中很长)。<br>最后提供了查找的位置。因为要求了GST_FORMAT_TIME,所以值需要用纳秒表示。为了简单起见，用秒表示时间并乘以GST_SECOND。</li></ul><h4 id="信息处理"><a href="#信息处理" class="headerlink" title="信息处理"></a>信息处理</h4><p><code>handle_message</code>函数通过管道总线(Pipeline’s bus)处理接收到的所有信息。ERROR和EOS处理之前已经说过了，所以直接跳到感兴趣的部分:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> GST_MESSAGE_DURATION:</div><div class="line">  <span class="comment">/* The duration has changed, mark the current one as invalid */</span></div><div class="line">  data-&gt;duration = GST_CLOCK_TIME_NONE;</div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p><p>该消息在流的持续时间变化时会发送给总线。这里简单地将当前持续时间标记为无效，所以稍后会被重新查询。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> GST_MESSAGE_STATE_CHANGED: <span class="type"></span>&#123;</div><div class="line">  GstState old_state, <span class="keyword">new</span><span class="type">_state</span>, pending_state;</div><div class="line">  gst_message_parse_state_changed (msg, &amp;old_state, &amp;<span class="keyword">new</span><span class="type">_state</span>, &amp;pending_state);</div><div class="line">  <span class="keyword">if</span> (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;pipeline)) &#123;</div><div class="line">    g_print (<span class="string">"Pipeline state changed from %s to %s:\n"</span>,</div><div class="line">        gst_element_state_get_name (old_state), gst_element_state_get_name (<span class="keyword">new</span><span class="type">_state</span>));</div><div class="line"></div><div class="line">    <span class="comment">/* Remember whether we are in the PLAYING state or not */</span></div><div class="line">    data-&gt;playing = (<span class="keyword">new</span><span class="type">_state</span> == GST_STATE_PLAYING);</div></pre></td></tr></table></figure></p><p>在PAUSED和PLAYING状态下，搜索和查询操作通常只会得到一个有效的回复，因为所有元素都有机会接收信息并进行自我配置。这里使用playing变量来跟踪管道是否处于PLAYING状态。如果刚刚进入了PLAYING状态，则执行第一次查询。然后询问Pipeline是否允许在此流上进行搜索:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">if</span> (<span class="keyword">data</span>-&gt;</span>playing) &#123;</div><div class="line">  <span class="comment">/* We just moved to PLAYING. Check if seeking is possible */</span></div><div class="line">  GstQuery *query;</div><div class="line">  gint64 start, end;</div><div class="line">  query = gst_query_new_seeking (GST_FORMAT_TIME);</div><div class="line">  <span class="function"><span class="title">if</span> (gst_element_query (<span class="keyword">data</span>-&gt;</span>pipeline, query)) &#123;</div><div class="line">    <span class="function"><span class="title">gst_query_parse_seeking</span> (query, NULL, &amp;<span class="keyword">data</span>-&gt;</span>seek_enabled, &amp;start, &amp;end);</div><div class="line">    <span class="function"><span class="title">if</span> (<span class="keyword">data</span>-&gt;</span>seek_enabled) &#123;</div><div class="line">      g_print (<span class="string">"Seeking is ENABLED from %"</span> GST_TIME_FORMAT <span class="string">" to %"</span> GST_TIME_FORMAT <span class="string">"\n"</span>,</div><div class="line">          GST_TIME_ARGS (start), GST_TIME_ARGS (end));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      g_print (<span class="string">"Seeking is DISABLED for this stream.\n"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    g_printerr (<span class="string">"Seeking query failed."</span>);</div><div class="line">  &#125;</div><div class="line">  gst_query_unref (query);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里<code>gst_query_new_seeking</code>函数使用GST_FORMAT_TIME格式创建了一个新的“seeking”类型的查询对象。这表明我们有兴趣通过指定想要移动的新时间来寻找。也可以使用GST_FORMAT_BYTE格式，然后在源文件中查找特定的字节位置，不过通常不太实用。<br>然后<code>gst_element_query</code>函数将查询对象传递给Pipeline，并将结果存储在同一个查询中，因此可以通过<code>gst_query_parse_seeking</code>函数方便的检索。它提取出一个表示是否允许查询的布尔值和可查找的范围。<br>最后在完成查询后释放查询对象。<br>通过这些过程基本上可以建立一个媒体播放器，根据当前流的位置定期更新一个滑块，并允许通过滑块进行搜索或跳转。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是关于如何使用GStreamer中的时间相关工具，如查询Pipeline的位置或者持续时间等信息，以及寻找或者跳转到Stream中的不同位置——时间点的方法。&lt;br&gt;
    
    </summary>
    
      <category term="TX1入坑" scheme="http://dfine.tech/categories/TX1%E5%85%A5%E5%9D%91/"/>
    
    
      <category term="Linux" scheme="http://dfine.tech/tags/Linux/"/>
    
      <category term="GStreamer" scheme="http://dfine.tech/tags/GStreamer/"/>
    
      <category term="TX1" scheme="http://dfine.tech/tags/TX1/"/>
    
  </entry>
  
  <entry>
    <title>GStreamer笔记二: Dynamic Pipeline</title>
    <link href="http://dfine.tech/posts/24b1a5e1/"/>
    <id>http://dfine.tech/posts/24b1a5e1/</id>
    <published>2017-12-01T07:52:43.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>主要也是关于建立Pipeline的，不过主要目的是建立动态的Pipeline，即在信息可用时随时创建Pipeline，而不是在应用程序开始时候定义单一Pipeline。<br><a id="more"></a></p><h3 id="一些基本概念的重申"><a href="#一些基本概念的重申" class="headerlink" title="一些基本概念的重申"></a>一些基本概念的重申</h3><p>本次尝试: 将Pipeline在其未完全建立起来时设置为Playing状态。虽然这并没有什么问题，如果不做任何动作，当数据到达Pipeline末端时将会由Pipeline产生一个error并停止，所以尝试会采取进一步的操作。尝试打开一个多路复用(muxed)的文件，即视频和音频存在一个容器文件中。负责打开该容器的元素称之为分离器(demuxers)。容器格式例如: MKV(Matroska), QT/MOV(Quick Time), Ogg或高级系统格式如ASF, WMV, WMA等。  </p><h4 id="pad"><a href="#pad" class="headerlink" title="pad"></a>pad</h4><p>如前<a href="/posts/8755e75b/">所述</a>，pad就是Gstreamer元素间互相通信的一个接口，也有人翻译为衬垫。数据通过sink pad流入，通过source pad流出。只包含source pad的称之为source元素，只包含sink pad的元素称为sink元素，两者兼有则称之为filter元素。如图所示:  </p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190906113023.png" alt=""><br></center><h4 id="分离器"><a href="#分离器" class="headerlink" title="分离器"></a>分离器</h4><p>如果一个容器嵌入多个流（例如一个视频和两个音频轨道），则分离器将分离它们并将其展示于不同的输出端口。通过这种方式，可以在流水线中创建不同的分支，处理不同类型的数据。<br>一个含有两个source pad和一个sink pad的分离器的例子如图所示:  </p><p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190906135930.png" alt=""><br></center><br>使用分离器的一个Pipeline例子如下:</p><p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190906140002.png" alt=""><br></center><br>该例是一个基本的Ogg播放器的Gstreamer Pipeline。<br>处理分离器的主要复杂性在于，只有在接收到一些数据且有机会查看容器并看到其内部信息之后，才能产生信息。即分离器开始时，没有任何其他元素能连接的source pad，因此Pipeline必须终止它们。<br>解决方法是建立一个从source向下到分离器的一个Pipeline，并将其设置为运行(Play)。当分离器了解了关于容器中数据流的数目和种类的足够信息之后，其会开始创建source pads。此时即是完成Pipeline创建并将其添加到新的分离器pads上的最佳时机。<br>简单起见，所用例子仅连接到audio pad，忽略video pad。  </p><h3 id="动态建立示例"><a href="#动态建立示例" class="headerlink" title="动态建立示例"></a>动态建立示例</h3><p>一个动态的HelloWorld示例代码如下:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;gst/gst.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">/* Structure to contain all our information, so we can pass it to callbacks */</span></div><div class="line">typedef struct _CustomData &#123;</div><div class="line">  GstElement *pipeline<span class="comment">;</span></div><div class="line">  GstElement *source<span class="comment">;</span></div><div class="line">  GstElement *convert<span class="comment">;</span></div><div class="line">  GstElement *sink<span class="comment">;</span></div><div class="line">&#125; CustomData<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="comment">/* Handler for the pad-added signal */</span></div><div class="line">static void pad_added_handler (GstElement *src, GstPad *pad, CustomData *data)<span class="comment">;</span></div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">  CustomData data<span class="comment">;</span></div><div class="line">  GstBus *<span class="keyword">bus;</span></div><div class="line"><span class="keyword"> </span> GstMessage *msg<span class="comment">;</span></div><div class="line">  GstStateChangeReturn ret<span class="comment">;</span></div><div class="line">  gboolean terminate = FALSE<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Initialize GStreamer */</span></div><div class="line">  gst_init (&amp;argc, &amp;argv)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Create the elements */</span></div><div class="line">  data.source = gst_element_factory_make (<span class="string">"uridecodebin"</span>, <span class="string">"source"</span>)<span class="comment">;</span></div><div class="line">  data.convert = gst_element_factory_make (<span class="string">"audioconvert"</span>, <span class="string">"convert"</span>)<span class="comment">;</span></div><div class="line">  data.sink = gst_element_factory_make (<span class="string">"autoaudiosink"</span>, <span class="string">"sink"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Create the empty pipeline */</span></div><div class="line">  data.pipeline = gst_pipeline_new (<span class="string">"test-pipeline"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">  if (!data.pipeline <span class="title">||</span> !data.source <span class="title">||</span> !data.convert <span class="title">||</span> !data.sink) &#123;</div><div class="line">    g_printerr (<span class="string">"Not all elements could be created.\n"</span>)<span class="comment">;</span></div><div class="line">    return -<span class="number">1</span><span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Build the pipeline. Note that we are NOT linking the source at this</span></div><div class="line"><span class="comment">   * point. We will do it later. */</span></div><div class="line">  gst_bin_add_many (GST_BIN (data.pipeline), data.source, data.convert , data.sink, NULL)<span class="comment">;</span></div><div class="line">  if (!gst_element_link (data.convert, data.sink)) &#123;</div><div class="line">    g_printerr (<span class="string">"Elements could not be linked.\n"</span>)<span class="comment">;</span></div><div class="line">    gst_object_unref (data.pipeline)<span class="comment">;</span></div><div class="line">    return -<span class="number">1</span><span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Set the URI to play */</span></div><div class="line">  g_object_set (data.source, <span class="string">"uri"</span>, <span class="string">"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm"</span>, NULL)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Connect to the pad-added signal */</span></div><div class="line">  g_signal_connect (data.source, <span class="string">"pad-added"</span>, G_CALLBACK (pad_added_handler), &amp;data)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Start playing */</span></div><div class="line">  ret = gst_element_set_state (data.pipeline, GST_STATE_PLAYING)<span class="comment">;</span></div><div class="line">  if (ret == GST_STATE_CHANGE_FAILURE) &#123;</div><div class="line">    g_printerr (<span class="string">"Unable to set the pipeline to the playing state.\n"</span>)<span class="comment">;</span></div><div class="line">    gst_object_unref (data.pipeline)<span class="comment">;</span></div><div class="line">    return -<span class="number">1</span><span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Listen to the bus */</span></div><div class="line">  <span class="keyword">bus </span>= gst_element_get_bus (data.pipeline)<span class="comment">;</span></div><div class="line">  do &#123;</div><div class="line">    msg = gst_bus_timed_pop_filtered (<span class="keyword">bus, </span>GST_CLOCK_TIME_NONE,</div><div class="line">        GST_MESSAGE_STATE_CHANGED <span class="title">| GST_MESSAGE_ERROR |</span> GST_MESSAGE_EOS)<span class="comment">;</span></div><div class="line"></div><div class="line">    <span class="comment">/* Parse message */</span></div><div class="line">    if (msg != NULL) &#123;</div><div class="line">      GError *err<span class="comment">;</span></div><div class="line">      gchar *debug_info<span class="comment">;</span></div><div class="line"></div><div class="line">      <span class="keyword">switch </span>(GST_MESSAGE_TYPE (msg)) &#123;</div><div class="line">        case GST_MESSAGE_ERROR:</div><div class="line">          gst_message_parse_error (msg, &amp;err, &amp;debug_info)<span class="comment">;</span></div><div class="line">          g_printerr (<span class="string">"Error received from element %s: %s\n"</span>, GST_OBJECT_NAME (msg-&gt;src), err-&gt;message)<span class="comment">;</span></div><div class="line">          g_printerr (<span class="string">"Debugging information: %s\n"</span>, debug_info ? debug_info : <span class="string">"none"</span>)<span class="comment">;</span></div><div class="line">          g_clear_error (&amp;err)<span class="comment">;</span></div><div class="line">          g_free (debug_info)<span class="comment">;</span></div><div class="line">          terminate = TRUE<span class="comment">;</span></div><div class="line">          <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>       case GST_MESSAGE_EOS:</div><div class="line">          g_print (<span class="string">"End-Of-Stream reached.\n"</span>)<span class="comment">;</span></div><div class="line">          terminate = TRUE<span class="comment">;</span></div><div class="line">          <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>       case GST_MESSAGE_STATE_CHANGED:</div><div class="line">          <span class="comment">/* We are only interested in state-changed messages from the pipeline */</span></div><div class="line">          if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data.pipeline)) &#123;</div><div class="line">            GstState old_state, new_state, pending_state<span class="comment">;</span></div><div class="line">            gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state)<span class="comment">;</span></div><div class="line">            g_print (<span class="string">"Pipeline state changed from %s to %s:\n"</span>,</div><div class="line">                gst_element_state_get_name (old_state), gst_element_state_get_name (new_state))<span class="comment">;</span></div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>       default:</div><div class="line">          <span class="comment">/* We should not reach here */</span></div><div class="line">          g_printerr (<span class="string">"Unexpected message received.\n"</span>)<span class="comment">;</span></div><div class="line">          <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>     &#125;</div><div class="line">      gst_message_unref (msg)<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">  &#125; while (!terminate)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Free resources */</span></div><div class="line">  gst_object_unref (<span class="keyword">bus);</span></div><div class="line"><span class="keyword"> </span> gst_element_set_state (data.pipeline, GST_STATE_NULL)<span class="comment">;</span></div><div class="line">  gst_object_unref (data.pipeline)<span class="comment">;</span></div><div class="line">  return <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* This function will be called by the pad-added signal */</span></div><div class="line">static void pad_added_handler (GstElement *src, GstPad *new_pad, CustomData *data) &#123;</div><div class="line">  GstPad *sink_pad = gst_element_get_static_pad (data-&gt;convert, <span class="string">"sink"</span>)<span class="comment">;</span></div><div class="line">  GstPadLinkReturn ret<span class="comment">;</span></div><div class="line">  GstCaps *new_pad_caps = NULL<span class="comment">;</span></div><div class="line">  GstStructure *new_pad_struct = NULL<span class="comment">;</span></div><div class="line">  const gchar *new_pad_type = NULL<span class="comment">;</span></div><div class="line"></div><div class="line">  g_print (<span class="string">"Received new pad '%s' from '%s':\n"</span>, GST_PAD_NAME (new_pad), GST_ELEMENT_NAME (src))<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* If our converter is already linked, we have nothing to do here */</span></div><div class="line">  if (gst_pad_is_linked (sink_pad)) &#123;</div><div class="line">    g_print (<span class="string">"  We are already linked. Ignoring.\n"</span>)<span class="comment">;</span></div><div class="line">    goto exit<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Check the new pad's type */</span></div><div class="line">  new_pad_caps = gst_pad_query_caps (new_pad, NULL)<span class="comment">;</span></div><div class="line">  new_pad_struct = gst_caps_get_structure (new_pad_caps, <span class="number">0</span>)<span class="comment">;</span></div><div class="line">  new_pad_type = gst_structure_get_name (new_pad_struct)<span class="comment">;</span></div><div class="line">  if (!g_str_has_prefix (new_pad_type, <span class="string">"audio/x-raw"</span>)) &#123;</div><div class="line">    g_print (<span class="string">"  It has type '%s' which is not raw audio. Ignoring.\n"</span>, new_pad_type)<span class="comment">;</span></div><div class="line">    goto exit<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Attempt the link */</span></div><div class="line">  ret = gst_pad_link (new_pad, sink_pad)<span class="comment">;</span></div><div class="line">  if (GST_PAD_LINK_FAILED (ret)) &#123;</div><div class="line">    g_print (<span class="string">"  Type is '%s' but link failed.\n"</span>, new_pad_type)<span class="comment">;</span></div><div class="line">  &#125; else &#123;</div><div class="line">    g_print (<span class="string">"  Link succeeded (type '%s').\n"</span>, new_pad_type)<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="symbol">exit:</span></div><div class="line">  <span class="comment">/* Unreference the new pad's caps, if we got them */</span></div><div class="line">  if (new_pad_caps != NULL)</div><div class="line">    gst_caps_unref (new_pad_caps)<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">/* Unreference the sink pad */</span></div><div class="line">  gst_object_unref (sink_pad)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>该示例代码仅播放音频，由于是在线媒体，所以连接速度会与网速有关。  </p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>首先定义了一个结构体:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Structure to contain all our information, so we can pass it to callbacks */</span></div><div class="line">typedef struct _CustomData &#123;</div><div class="line">  GstElement *pipeline<span class="comment">;</span></div><div class="line">  GstElement *source<span class="comment">;</span></div><div class="line">  GstElement *convert<span class="comment">;</span></div><div class="line">  GstElement *sink<span class="comment">;</span></div><div class="line">&#125; CustomData<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>简单情况下，通常可以使用一个局部变量(一个GstElement类型的基本指针)来表示所需要的信息。但大多数情况下（包括该例）是涉及到回调的，所以将其放在一个结构体中以便处理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Handler for the pad-added signal */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pad_added_handler</span> <span class="params">(GstElement *src, GstPad *pad, CustomData *data)</span></span>;</div></pre></td></tr></table></figure></p><p>此处是一个添加pad的前置函数声明。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Create the elements */</span></div><div class="line"><span class="keyword">data</span>.source = gst_element_factory_make (<span class="string">"uridecodebin"</span>, <span class="string">"source"</span>);</div><div class="line"><span class="keyword">data</span>.convert = gst_element_factory_make (<span class="string">"audioconvert"</span>, <span class="string">"convert"</span>);</div><div class="line"><span class="keyword">data</span>.sink = gst_element_factory_make (<span class="string">"autoaudiosink"</span>, <span class="string">"sink"</span>);</div></pre></td></tr></table></figure></p><p>该段是创建Element的代码。其中:<br><code>uridecodebin</code>通过将uri转化为原始音频或视频流来实例化所有的必要Element(source, 分离器，解码器)，其所做的是playbin的一半。由于含有分离器，其source pads最初并不可用，而且我们需要随时将其连接起来。<br><code>audioconvert</code>对于转换不同格式的音频很实用，由于解码器生成的格式可能和audio sink期望的不一样，所以为了确保其可以在任何平台上工作，使用<code>audioconvert</code>进行转换。<br><code>autoaudiosink</code>在音频中类似于视频中的<code>autovideosink</code>，其将会把音频流送给声卡。  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!gst_element_link (<span class="keyword">data</span>.convert, <span class="keyword">data</span>.sink)) &#123;</div><div class="line">  g_printerr (<span class="string">"Elements could not be linked.\n"</span>);</div><div class="line">  gst_object_unref (<span class="keyword">data</span>.pipeline);</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此处主要作用是将转换元素连接到sink，但是由于其不含source pads，所以没有将其连接到source上，仅仅是保持该分支(转换器+sink)为未连接状态，待后续处理。  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Set the URI to play */</span></div><div class="line">g_object_set (data.<span class="keyword">source</span>, <span class="string">"uri"</span>, <span class="string">"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm"</span>, <span class="keyword">NULL</span>);</div></pre></td></tr></table></figure><p>这里通过设置文件uri属性方法来播放它们。  </p><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>GSignals是GStreamer中的一个关键部分。当一些你感兴趣的事发生时，它允许你通过回调的方式获得通知。信号(Signals)由名称标识，且每个GObject都有自己的signals。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* Connect to the pad-added signal */</div><div class="line">g_signal_connect (<span class="name">data</span>.source, <span class="string">"pad-added"</span>, G_CALLBACK (<span class="name">pad_added_handler</span>), <span class="symbol">&amp;data</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>该行代码将一个”pad added”信号附加到我们的source(一个uridecoderbin元素)上。为此使用了<code>g_signal_connect</code>函数，并提供要使用的回调函数<code>pad_add_handler</code>和一个数据指针。GStreamer并未对数据指针做任何事，仅仅将它转发给回调函数，因此可以与其共享信息。在这种情况下，我们传递一个指向我们专门为此建立的一个结构体CustomData的指针。<br>GStreamer产生的信号可以通过其文档或者使用<code>gst-inspect-1.0</code>工具查询。<br>至此已经准备好了，只需要将Pipeline设置为PLAYING状态并开始监听总线(bus)上感兴趣的Message(如ERROR或EOS)。  </p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>当source element有了足够的信息开始产生数据时，将会创建source pads，并触发“pad-added”信号。此时，回调函数就会被调用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pad_added_handler</span> <span class="params">(GstElement *src, GstPad *new_pad, CustomData *data)</span> </span>&#123;</div></pre></td></tr></table></figure><p>其中，<br>信号处理的第一个参数始终是触发它的对象。src是触发这个信号的GstElement。此例中，它只能是<code>uridecodebin</code>，因为它是我们唯一附加的信号。<br>new_pad是刚刚添加到src element的GstPad, 通常是我们想要连接的pad。<br>data是我们附加到信号时提供的指针，例中用其传递CustomData指针。  </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">G<span class="function"><span class="title">stPad</span> *sink_pad = gst_element_get_static_pad (<span class="keyword">data</span>-&gt;</span>convert, <span class="string">"sink"</span>);</div></pre></td></tr></table></figure><p>从CustomData中提取转换元素，然后使用<code>gst_element_get_static_pad</code>函数取回其sink pad。这是我们希望连接到new_pad的pad。之前涉及的简单例子中直接将元素连接到元素，并由GStreamer选择合适的pad。现在我们直接将这些pad连接起来。  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">/* If our converter is already linked, we have nothing to do here */</span></div><div class="line"><span class="keyword">if</span> (gst_pad_is_linked (sink_pad)) &#123;</div><div class="line">  g_print (<span class="string">"  We are already linked. Ignoring.\n"</span>);</div><div class="line">  goto <span class="keyword">exit</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>uridecodebin</code>可以创建尽可能多的pad，而且每个pad都会调用这个回调函数。该行代码主要作用是阻止我们尝试连接到已经连接了的pad上。  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Check the new pad's type */</span></div><div class="line"><span class="keyword">new</span><span class="type">_pad_caps</span> = gst_pad_query_caps (<span class="keyword">new</span><span class="type">_pad</span>, NULL);</div><div class="line"><span class="keyword">new</span><span class="type">_pad_struct</span> = gst_caps_get_structure (<span class="keyword">new</span><span class="type">_pad_caps</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">new</span><span class="type">_pad_type</span> = gst_structure_get_name (<span class="keyword">new</span><span class="type">_pad_struct</span>);</div><div class="line"><span class="keyword">if</span> (!g_str_has_prefix (<span class="keyword">new</span><span class="type">_pad_type</span>, <span class="string">"audio/x-raw"</span>)) &#123;</div><div class="line">  g_print (<span class="string">"  It has type '%s' which is not raw audio. Ignoring.\n"</span>, <span class="keyword">new</span><span class="type">_pad_type</span>);</div><div class="line">  goto exit;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在将会检查这个新pad要输出的数据类型，因为我们仅对产生音频的pad有兴趣。之前已经创建了一个处理音频的Pipeline(一个<code>autoaudioconver</code>连接到一个<code>autoaudiosink</code>)，例中我们将不能将其连接到产生视频的pad上。<br><code>gst_pad_query_caps</code>函数查询或检索pad的功能(这是一种它所支持的数据，封装在GstCaps结构体中)，一个pad可以提供许多功能(cap)，因此GstCap可能包含多个GstStructure，且每个表示不同的功能。<br>由于此例中我们知道我们想要的pad只有一个能力(audio)，所以使用<code>gst_caps_get_structure</code>函数获取第一个GstStructure。<br>最后使用<code>gst_structure_get_name</code>函数获取包含格式(实际是媒体类型)的主要描述的结构体名称。如果名称不是<code>audio/x-raw</code>，这就不是解码的音频pad，也不是我们所感兴趣的。否则，尝试连接:  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Attempt the link */</span></div><div class="line">ret = gst_pad_link (<span class="keyword">new</span><span class="type">_pad</span>, sink_pad);</div><div class="line"><span class="keyword">if</span> (GST_PAD_LINK_FAILED (ret)) &#123;</div><div class="line">  g_print (<span class="string">"  Type is '%s' but link failed.\n"</span>, <span class="keyword">new</span><span class="type">_pad_type</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  g_print (<span class="string">"  Link succeeded (type '%s').\n"</span>, <span class="keyword">new</span><span class="type">_pad_type</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中，<code>gst_pad_link</code>函数尝试连接这两个pad。和<code>gst_element_link</code>函数一样，连接必须指定有source到sink，且这两个pad必须属于同一个bin(或Pipeline)中的元素。<br>至此已经基本完成，当出现一个正确类型的pad时，它将会被连接到音频处理Pipeline的其余部分，并执行且继续直到遇到ERROR或者EOS。但关于GStreamer的状态还是需要重申一下。  </p><h4 id="关于GStreamer-States"><a href="#关于GStreamer-States" class="headerlink" title="关于GStreamer States"></a>关于GStreamer States</h4><p><a href="/posts/413bb42a/">之前</a>，已经解释过GStreamer的状态了，一共四种，如下所示:  </p><table><thead><tr><th>State</th><th>Description</th></tr></thead><tbody><tr><td><code>NULL</code></td><td>the NULL state or initial state of an element.</td></tr><tr><td><code>READY</code></td><td>the element is ready to go to PAUSED.</td></tr><tr><td><code>PAUSED</code></td><td>the element is PAUSED, it is ready to accept and process data. Sink elements however only accept one buffer and then block.</td></tr><tr><td><code>PLAYING</code></td><td>the element is PLAYING, the clock is running and the data is flowing.</td></tr></tbody></table><p>四种状态只能在相邻状态之间移动，不能直接从<code>NULL</code>跳到<code>PLAYING</code>，必须经过中间的<code>READY</code>和<code>PAUSED</code>状态。但是如果将管道设置为<code>PLAYIING</code>状态，GStreamer将会为你进行中间转换。  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> GST_MESSAGE_STATE_CHANGED:<span class="type"></span></div><div class="line"><span class="type">  </span>/* We are only interested <span class="keyword">in</span> state-changed messages from the pipeline */</div><div class="line">  <span class="keyword">if</span> (GST_MESSAGE_SRC (msg) == GST_OBJECT (data.pipeline)) &#123;</div><div class="line">    GstState old_state, <span class="keyword">new</span><span class="type">_state</span>, pending_state;</div><div class="line">    gst_message_parse_state_changed (msg, &amp;old_state, &amp;<span class="keyword">new</span><span class="type">_state</span>, &amp;pending_state);</div><div class="line">    g_print (<span class="string">"Pipeline state changed from %s to %s:\n"</span>,</div><div class="line">        gst_element_state_get_name (old_state), gst_element_state_get_name (<span class="keyword">new</span><span class="type">_state</span>));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure><p>此段代码的添加主要用于监听关于状态更改的总线消息(bus message)，并将其打印在屏幕上以帮助了解这个转换。每个元素都将关于其当前状态的信息放在总线上，因此我们将其过滤出来，并只收听来自Pipeline的信息。<br>大多数应用程序只需要关心去<code>PLAYING</code>来开始播放，然后<code>PAUSED</code>来暂停，然后在程序退出时返回<code>NULL</code>来释放所有资源。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要也是关于建立Pipeline的，不过主要目的是建立动态的Pipeline，即在信息可用时随时创建Pipeline，而不是在应用程序开始时候定义单一Pipeline。&lt;br&gt;
    
    </summary>
    
      <category term="TX1入坑" scheme="http://dfine.tech/categories/TX1%E5%85%A5%E5%9D%91/"/>
    
    
      <category term="Linux" scheme="http://dfine.tech/tags/Linux/"/>
    
      <category term="GStreamer" scheme="http://dfine.tech/tags/GStreamer/"/>
    
      <category term="TX1" scheme="http://dfine.tech/tags/TX1/"/>
    
  </entry>
  
  <entry>
    <title>GStreamer笔记一: GStreamer Concepts</title>
    <link href="http://dfine.tech/posts/8755e75b/"/>
    <id>http://dfine.tech/posts/8755e75b/</id>
    <published>2017-12-01T02:30:34.000Z</published>
    <updated>2022-05-19T04:23:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>笔记主要参照GStreamer官方tutorial，之前的一篇<a href="/posts/413bb42a/">文章</a>里最后一个例子写的是一个通过uri自动建立Pipeline的代码。这里主要内容是关于实例化每个元素并连接起来来手动建立Pipeline。<br><a id="more"></a></p><h3 id="手动建立Pipeline"><a href="#手动建立Pipeline" class="headerlink" title="手动建立Pipeline"></a>手动建立Pipeline</h3><p>基本代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gst/gst.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">  GstElement *pipeline, *source, *sink;</div><div class="line">  GstBus *bus;</div><div class="line">  GstMessage *msg;</div><div class="line">  GstStateChangeReturn ret;</div><div class="line"></div><div class="line">  <span class="comment">/* Initialize GStreamer */</span></div><div class="line">  gst_init (&amp;argc, &amp;argv);</div><div class="line"></div><div class="line">  <span class="comment">/* Create the elements */</span></div><div class="line">  source = gst_element_factory_make (<span class="string">"videotestsrc"</span>, <span class="string">"source"</span>);</div><div class="line">  sink = gst_element_factory_make (<span class="string">"autovideosink"</span>, <span class="string">"sink"</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* Create the empty pipeline */</span></div><div class="line">  pipeline = gst_pipeline_new (<span class="string">"test-pipeline"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!pipeline || !source || !sink) &#123;</div><div class="line">    g_printerr (<span class="string">"Not all elements could be created.\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Build the pipeline */</span></div><div class="line">  gst_bin_add_many (GST_BIN (pipeline), source, sink, <span class="literal">NULL</span>);</div><div class="line">  <span class="keyword">if</span> (gst_element_link (source, sink) != TRUE) &#123;</div><div class="line">    g_printerr (<span class="string">"Elements could not be linked.\n"</span>);</div><div class="line">    gst_object_unref (pipeline);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Modify the source's properties */</span></div><div class="line">  g_object_set (source, <span class="string">"pattern"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* Start playing */</span></div><div class="line">  ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);</div><div class="line">  <span class="keyword">if</span> (ret == GST_STATE_CHANGE_FAILURE) &#123;</div><div class="line">    g_printerr (<span class="string">"Unable to set the pipeline to the playing state.\n"</span>);</div><div class="line">    gst_object_unref (pipeline);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Wait until error or EOS */</span></div><div class="line">  bus = gst_element_get_bus (pipeline);</div><div class="line">  msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);</div><div class="line"></div><div class="line">  <span class="comment">/* Parse message */</span></div><div class="line">  <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</div><div class="line">    GError *err;</div><div class="line">    gchar *debug_info;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (GST_MESSAGE_TYPE (msg)) &#123;</div><div class="line">      <span class="keyword">case</span> GST_MESSAGE_ERROR:</div><div class="line">        gst_message_parse_error (msg, &amp;err, &amp;debug_info);</div><div class="line">        g_printerr (<span class="string">"Error received from element %s: %s\n"</span>, GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);</div><div class="line">        g_printerr (<span class="string">"Debugging information: %s\n"</span>, debug_info ? debug_info : <span class="string">"none"</span>);</div><div class="line">        g_clear_error (&amp;err);</div><div class="line">        g_free (debug_info);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> GST_MESSAGE_EOS:</div><div class="line">        g_print (<span class="string">"End-Of-Stream reached.\n"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="comment">/* We should not reach here because we only asked for ERRORs and EOS */</span></div><div class="line">        g_printerr (<span class="string">"Unexpected message received.\n"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    gst_message_unref (msg);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Free resources */</span></div><div class="line">  gst_object_unref (bus);</div><div class="line">  gst_element_set_state (pipeline, GST_STATE_NULL);</div><div class="line">  gst_object_unref (pipeline);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译时候可以通过pkg-config命令查询所需要的头文件和库文件，关于pkg的方法前面已有叙述，地址<a href="/posts/aad6181/">在此</a>。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>其基本流程图如下:  </p><p><center><br><img src="https://raw.githubusercontent.com/newdee/BlogImage/master/20190906111933.png" alt=""><br></center></p><h4 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h4><p>在初始化GStreamer后，首先需要创建元素，如上所示代码中的:  </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* Create the elements */</div><div class="line">source = gst_element_factory_make (<span class="string">"videotestsrc"</span>, <span class="string">"source"</span>);</div><div class="line">sink = gst_element_factory_make (<span class="string">"autovideosink"</span>, <span class="string">"sink"</span>);</div></pre></td></tr></table></figure><p>使用<code>gst_element_factory_make</code>函数创建，该函数第一个参数是需要创建的元素类型，第二个参数是给这个元素实例的名称，如果为空，GStreamer会自动生成一个特有的名称。<br>此处创建了两个元素:<code>videotestsrc</code>和<code>autovideosink</code>。其中，<br><code>videotestsrc</code>属于source元素，通常用来产生或提供数据，经常用来创建一个测试用的模型。该元素在debug模式下或者教程中用得较多，实际应用中鲜有所闻。<br><code>autovideosink</code>属于sink元素，用于接受或者消费数据，将其接收到的图像展示在窗口中等。程序可以有多个video sink，这通常取决于操作系统。<code>autovideosink</code>会自动选择并实例化最好的一个，所以不用担心实现细节，代码对于平台是比较独立的。</p><h4 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h4><p>创建了Element后则需要创建Pipeline，如上所示代码中的:  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Create the empty pipeline */</span></div><div class="line">pipeline = gst_pipeline_new <span class="type"></span>(<span class="string">"test-pipeline"</span>);</div></pre></td></tr></table></figure><p>所有元素在使用前必须包含进一个Pipeline，因为需要关心其时钟和Message功能。通常使用<code>gst_pipeline_new</code>创建管道。  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Build the pipeline */</span></div><div class="line">gst_bin_add_many (GST_BIN (pipeline), <span class="keyword">source</span>, sink, <span class="keyword">NULL</span>);</div><div class="line"><span class="keyword">if</span> (gst_element_link (<span class="keyword">source</span>, sink) != <span class="keyword">TRUE</span>) &#123;</div><div class="line">  g_printerr (<span class="string">"Elements could not be linked.\n"</span>);</div><div class="line">  gst_object_unref (pipeline);</div><div class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Pipeline也是一种bin，一种特殊的bin，是一种包含了其他元素的元素。因此所有对bin适用的方法对Pipeline也同样适用。这里通过<code>gst_bin_add_many</code>函数添加多个元素到Pipeline，该函数接受多个元素，并添加到Pipeline中，以NULL结束。单个元素添加可使用<code>gst_bin_add</code>函数。<br>然后就需要将这些元素连接起来，因为虽然添加进了管道，但只是说明了管道中元素的位置，并没有将各个元素连接起来，数据无法流动。这里通过<code>gst_element_link</code>将各个元素连接起来，该函数第一个参数是源元素，第二个参数是链接的目标元素，连接必须遵照数据流动方向建立。<br>只有在同一个bin中的元素才能连接在一起，所以在连接之前必须先将其添加进Pipeline中。  </p><h4 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h4><p>如上代码中修改source的属性中的一段:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Modify the source's properties */</span></div><div class="line">g_object_set (<span class="keyword">source</span>, <span class="string">"pattern"</span>, <span class="number">0</span>, <span class="keyword">NULL</span>);</div></pre></td></tr></table></figure></p><p>该行代码改变了<code>videotestsrc</code>元素的pattern属性，控制了测试视频元素的输出类型。<br>绝大多数GStreamer元素都可以自定义其属性:可以通过修改名称属性来改变元素行为(可写属性)，或者通过查询来获取元素内部状态(可读属性)。<br>通常使用<code>g_object_get</code>函数获取属性，通过<code>g_objece_set</code>函数设置属性。<br><code>g_object_set</code>函数接受一个以<code>NULL</code>结尾的属性名-属性值列表，所以可以一次性改变元素的属性。<br>Gstreamer元素都是一种特殊的GObject(GLib对象系统，提供属性设备的实例)，所以属性处理方法都有一个带<code>g_</code>的前缀。<br>所有元素的可用属性名和属性值可以通过gst-inspect工具获取。  </p><h4 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h4><p>剩余代码则是进行错误检测以增加程序的鲁棒性。如:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Start playing */</span></div><div class="line">ret = gst_element_set_state (pipeline, GST_STATE_PLAYING)<span class="comment">;</span></div><div class="line">if (ret == GST_STATE_CHANGE_FAILURE) &#123;</div><div class="line">  g_printerr (<span class="string">"Unable to set the pipeline to the playing state.\n"</span>)<span class="comment">;</span></div><div class="line">  gst_object_unref (pipeline)<span class="comment">;</span></div><div class="line">  return -<span class="number">1</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在播放时候通过<code>gst_element_set_state</code>函数返回值来检测错误。<br>再如:<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Wait until error or EOS */</span></div><div class="line">bus = gst_element_get_bus (pipeline)<span class="comment">;</span></div><div class="line">msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS)<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="comment">/* Parse message */</span></div><div class="line"><span class="keyword">if</span> (msg != NULL) &#123;</div><div class="line">  GError *<span class="keyword">err</span><span class="comment">;</span></div><div class="line">  gchar *debug_info<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="keyword">switch</span> (GST_MESSAGE_TYPE (msg)) &#123;</div><div class="line">    <span class="keyword">case</span> GST_MESSAGE_ERROR:</div><div class="line">      gst_message_parse_error (msg, &amp;<span class="keyword">err</span>, &amp;debug_info)<span class="comment">;</span></div><div class="line">      g_printerr (<span class="string">"Error received from element %s: %s\n"</span>, GST_OBJECT_NAME (msg-&gt;src), <span class="keyword">err</span>-&gt;message)<span class="comment">;</span></div><div class="line">      g_printerr (<span class="string">"Debugging information: %s\n"</span>, debug_info ? debug_info : <span class="string">"none"</span>)<span class="comment">;</span></div><div class="line">      g_clear_error (&amp;<span class="keyword">err</span>)<span class="comment">;</span></div><div class="line">      g_free (debug_info)<span class="comment">;</span></div><div class="line">      <span class="keyword">break</span><span class="comment">;</span></div><div class="line">    <span class="keyword">case</span> GST_MESSAGE_EOS:</div><div class="line">      g_print (<span class="string">"End-Of-Stream reached.\n"</span>)<span class="comment">;</span></div><div class="line">      <span class="keyword">break</span><span class="comment">;</span></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="comment">/* We should not reach here because we only asked for ERRORs and EOS */</span></div><div class="line">      g_printerr (<span class="string">"Unexpected message received.\n"</span>)<span class="comment">;</span></div><div class="line">      <span class="keyword">break</span><span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">  gst_message_unref (msg)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中，<code>gst_bus_timed_pop_filtered</code>函数等待执行结束并返回一个GstMessage。此处该函数在遇到错误或者到EOS状态时会返回，所以需要检测是什么原因导致函数返回的，因此通过下面的if语句对msg进行判断。<br>GstMessage是一个非常通用的结构，可以提供几乎任何类型的信息。而且，GStreamer为每种消息提供了一系列的解析函数。<br>通过使用宏定义函数<code>GST_MESSAGE_TYPE</code>可以知道Message包含的错误，然后通过<code>gst_message_parse_error</code>函数返回一个GLib Error的error结构体和一个字符串用于调试。  </p><h4 id="GStreamer总线"><a href="#GStreamer总线" class="headerlink" title="GStreamer总线"></a>GStreamer总线</h4><p>GStreamer总线(bus)是一个简单的系统，负责将由元素生成的GstMessages传递给应用程序的对象，以及应用程序线程。实际的媒体流是在另一个线程中完成的，而不是应用程序。<br>Message可以通过<code>gst_bus_timed_pop_filtered()</code>函数和其兄弟姐妹同步获取，也可以通过signal异步获取。应用程序应该始终关注总线，去获取错误以及其他回放相关的问题。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔记主要参照GStreamer官方tutorial，之前的一篇&lt;a href=&quot;/posts/413bb42a/&quot;&gt;文章&lt;/a&gt;里最后一个例子写的是一个通过uri自动建立Pipeline的代码。这里主要内容是关于实例化每个元素并连接起来来手动建立Pipeline。&lt;br&gt;
    
    </summary>
    
      <category term="TX1入坑" scheme="http://dfine.tech/categories/TX1%E5%85%A5%E5%9D%91/"/>
    
    
      <category term="Linux" scheme="http://dfine.tech/tags/Linux/"/>
    
      <category term="GStreamer" scheme="http://dfine.tech/tags/GStreamer/"/>
    
      <category term="TX1" scheme="http://dfine.tech/tags/TX1/"/>
    
  </entry>
  
</feed>
