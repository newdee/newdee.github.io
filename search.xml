<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小工具(三)]]></title>
    <url>%2Fposts%2Fa64e7c3f%2F</url>
    <content type="text"><![CDATA[竟然真的有后续！！！(Again) 花里胡哨的命令行监视器bashtop作用基本上就跟top差不多，不过视觉效果还不错。对比一下，top命令: bashtop命令: 其中，最上面是CPU资源使用情况，左侧是内存和网络资源使用情况，右边是和top一样的进程状态，可以使用方向键来选择进程，或者翻页键来翻页，按f可以filter需要找的进程。在选中进程之后，可以使用回车键查看该进程详细信息，t和k健可以terminate或者kill进程，i可以中断进程(interrupt)。按q退出，按ESC可以跳回主界面，如果不清楚命令或者快捷键，可以选择HELP查看，总之使用方法比top简单不少。缺点，就是感觉没有top出来的快，可能是因为要在terminal上绘图。 文件格式转换工具xxdxxd是linux上比较老的文件格式转换工具了，经常使用vim的在打开二进制文件的时候输入的!xxd就是这个命令，一般作用是将文件转为十六进制。12345678910111213141516171819202122Usage: xxd [options] [infile [outfile]] or xxd -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]]Options: -a toggle autoskip: A single '*' replaces nul-lines. Default off. -b binary digit dump (incompatible with -ps,-i,-r). Default hex. -C capitalize variable names in C include file style (-i). -c cols format &lt;cols&gt; octets per line. Default 16 (-i: 12, -ps: 30). -E show characters in EBCDIC. Default ASCII. -e little-endian dump (incompatible with -ps,-i,-r). -g number of octets per group in normal output. Default 2 (-e: 4). -h print this summary. -i output in C include file style. -l len stop after &lt;len&gt; octets. -o off add &lt;off&gt; to the displayed file position. -ps output in postscript plain hexdump style. -r reverse operation: convert (or patch) hexdump into binary. -r -s off revert with &lt;off&gt; added to file positions found in hexdump. -s [+][-]seek start at &lt;seek&gt; bytes abs. (or +: rel.) infile offset. -u use upper case hex letters. -v show version: "xxd V1.10 27oct98 by Juergen Weigert". 文件转十六进制最简单的方式是xxd file,会在终端输出转换后该文件的十六进制内容，使用重定向或者管道可以写到文件或作用于其他输入。如果文件比较大，可能转换比较慢，而且很多并不是我们需要的话，可以使用-s或者-l参数。-s参数如上所示，“start at bytes abs”，从指定位置开始转换。-l参数则是指定要转换内容的长度。 二进制文件的比较如果要比较两个二进制文件内容是否一致，可以借助于xxd命令。例如，需要比较两个原始的yuv格式视频文件是否一致，比如两种方式通过h264解码出来的文件，平常的diff命令是无法完成的，可以先利用xxd命令转成十六进制后再进行比较。123xxd a.yuv &gt; a.hexxxd b.yuv &gt; b.hexdiff a.hex b.hex 之所以举这个例子，是因为yuv是原始视频数据，比如一个1920x1080的h264编码后的视频大小只有8M多，但是其对应的解码后的yuv大小则可能有1.1G多，而使用xxd转成十六进制文件之后，体积可以达到4.5G，直接用diff命令比较费时，而且用vim打开还容易卡死。而通常只需要比较其中一部分可以判断出解码的文件是否正常，这时候就可以在xxd命令转换的时候加上-l或者-s参数，指定比较的文件位置和长度，可以很快的得到结果。 当然，比较方式也不是绝对的，对于视频文件，使用ffmpeg也可以查看许多详细信息。 应用代理工具proxychains这个其实很早以前打算说的，不过忘记了。作用有点像chrome里的SwitchyOmega之类的扩展程序，不同的是，SwitchyOmega是针对特定网页选择本地的代理端口和协议，proxychains是针对某个命令或者应用选择本地代理端口和协议。安装方法比较简单，ubuntu下直接使用apt命令可以安装:1sudo apt install proxychains 安装好之后，配置文件放在/etc目录下的proxychains.conf文件，修改里面的协议和端口即可。使用方式是直接在命令前加上proxychains,这样只对该命令代理，不影响其他应用。比如使用ubuntu的snap命令下载软件时，通常国内会比较慢，如果有代理，则可以使用:1proxychains sudo snap install xxx 其实很多工具也不是啥新鲜玩意，不过有时候确实挺实用的，不过仅仅对工具而言，没有任何性质，怎么用在于个人。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>bashtop</tag>
        <tag>xxd</tag>
        <tag>proxychains</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机小述]]></title>
    <url>%2Fposts%2F79707c4f%2F</url>
    <content type="text"><![CDATA[看了看，好像自己确实是太懒了，不过虽然这样，说的时候还是要把锅甩给疫情的，想起以前接触相机这么久了，不如就还记得的一点东西，介绍一下，水一点东西，混一次提交。不过不知道有没有帮助，不是介绍什么拍摄三要素（快门、光圈、感光度）的控制，也不是什么九宫格拍摄法之类的，说实话，那些五花八门的拍摄方法我也不太熟悉,就讲讲相机结构。 传感器类型图像传感器主要有两种，线阵和面阵，平时看到的线阵相机和面阵相机就是因为用的Sensor类型不同。线阵Sensor以CCD为主，一行的数据可以到几K甚至几十K，但是高度叧有几个像素，行频很高，可以到每秒几万行，适合做非常高精度、宽画幅的扫描。面阵Sensor，包含CCD和CMOS，单行数据宽度远小于线阵，优点是成像快，一次可以成像很多行，即单次扫描的像素高度比线阵高很多。另外开发简单，成像快，不用进行每行数据的拼接。而且价格便宜不少，这个大概是应用更广泛的决定性条件。 快门类型CMOSCMOS传感器的大致结构如图，由于其感光方式不同，因此有两种类型快门。 Rolling Shutter（滚动快门）滚动快门在感光时是逐行进行的，从第一行开始，一边曝光一边输出图像，一直滚动到最后一行,模数转换器则是逐行共用。这样，实际上每一行曝光的时间点会不一样，时间上存在一个位移，这样导致每行图像会有一些位移偏差，特别是当对象是高速运动物体时更明显，会导致图像的扭曲变形。这种变形和平时拍摄运动物体的拖影不一样，拖影是由于拍摄物体运动速度太快，而且曝光时间设置太长造成，会带有一些图像模糊。滚动快门的变形是每行时间上的不同步拍摄而造成的变形，图像清晰度不会受到影响。 Global Shutter（全局快门）为了改善这种变形，则可以在每个像素处增加采样保持单元或者模数转换器。增加采样保持单元可以短暂保存得到的模拟数据，再等待模数转换器进行逐行转换，转换期间可以继续进行拍摄。而这种方案会浪费比较多的CMOS面积来摆放这些用来短暂保存的像素，使得填充系数降低，而且采样保持单元还引入了新的噪声源。因此在每个像素处增加模数转换器则是一种新的方案(如索尼做的)，每个像素采集到了就可以直接转换，不用等待，实现真正意义上的全局快门。 CCDCCD(电荷耦合器件)的结构大致如图，其结构决定了CCD具有“免费全局快门”的优点，所有像素在同一时刻曝光，所有像素同时移入传输寄存器，曝光完成后，每个像素被串行传输到单个模数转换器中，因此其传输帧率受限于单个像素数字化速率和传感器中的像素数量。 光学尺寸光学尺寸是指其感光区域的大小，通常高分辨率的面阵相机或者线阵相机的相机芯片尺寸要大于低分辨率的，其尺寸没有特定标准，是有其分辨率和像素大小决定的。从理论上讲，可以有无数种类型，只要价格到位。尺寸通常用感光元件的对角线来表示，单位是英寸，不过由于历史原因，这里的1英寸是16mm，不是25.4mm。常见的有1/4”、1/3”、1/2.5”、1/2.3”、1/2”、2/3”、1”、1.1”等。介绍光学尺寸的原因是，通常为相机选择镜头的时候要考虑到，镜头靶面尺寸要配合其光学尺寸。 靶面尺寸靶面尺寸，或者靶面直径，单位也是英寸，理想情况下，1/2”的镜头应该安装在1/2”的光学芯片上，这样可以尽可能的利用靶面，但是如果安装在2/3”的芯片上，由于感光区域大于感光范围，那么感光区域中无法感光的部分则会在最终的图像中出现暗角或者晕影。不过如果采用2/3”的 镜头匹配1/2”的芯片，则可以完全利用光学尺寸，实际上使用大的镜头可以形成更大的靶面，图像从中心到边缘的锐化可以保持一致，但这种情况下，很大一部分罢免无法使用，造成浪费。图像的大小是有光学尺寸决定的，而镜头越大，则价格越贵，如果想节约点，对于比较小的光学尺寸，还是选择较小的镜头。 镜头接口镜头接口是连接镜头和相机的接口，有螺纹接口和卡口两类。比较常见的C口、CS口等都是螺纹接口。最常见的C口和CS口的工业相机，接口实际上比较相似，也有其转换环，因为它们的接口直径、螺纹间距都一样，只是法兰距不同。C接口的法兰距是17.526mm，CS接口的法兰距为12.5mm。因此所谓转接环，就是一个5mm左右的垫圈了。此外，螺纹接口还有M12、M45、M58等，具体规格在需要的时候查询即可，这里不在赘述。至于卡口相机，平常见到的单反基本上都是卡口，如尼康的F口或者佳能的EF口，这俩外观上也不容易区分，不过F口的法兰距比EF口的要长。 分辨率分辨率，泛指量测或显示系统对细节的分辨能力。相机制造商一般直接用像素数目表示分辨率，实际上这是分辨率上限。因为这种情况，是当镜头能够解析像素大小时候才成立。只有使用高分辨率镜头，才能最终得到高分辨率图像。镜头的分辨率通常通过每毫米线对数衡量，表示每毫米中可以相互分离的行的数量。每毫米线对数越多，分辨率越高，镜头质量越好。镜头分辨率确定了可以解析的像素大小，方便起见，一般情况下直接指定镜头可以解析的百万像素数，当镜头分辨率可以完全解析感光元件的所有像素点时，则可以获得最高分辨率。表示镜头分辨率性能的指标有MTF曲线（调制传递函数），描述了镜头从图像中心到边缘的分辨率性能，通常可以找制造商要到这些曲线。 焦距焦距是镜头光学中心和焦点之间的距离，通常长焦镜头适合拍远景，但视场小；短焦适合拍广角，常用的鱼眼或者微距镜头就是。 光圈光圈的参数通常用F Number来表示，是焦距与光圈直径的比值，表示光圈全开时的宽度。光圈的选择直接影响的是进光量，最终影响的是图像质量和亮度。F值越高，则光圈越小，最终感光元件获得的进光量越少，反之亦然。通常可以根据光源亮度调整。 减小光圈，可以减少相机光晕效果，景深越大，不过光圈太小，容易产生衍射模糊。 帧存和缓存带帧存功能的相机，是指该相机内部具有保存一帧完整图像的能力，当传输带宽不够或者不稳定时，由于缓存了整个图像帧，所以仍然可以断点续传之后重建图像。带缓存功能的相机，是指该相机内部具有缓存一部分图像数据的能力，但是无法缓存一整个帧，当传输带宽不够或者不稳定时候，有可能造成缓存溢出，最后无法重建图像从而造成丢帧等问题。平常见到的工业相机一般都是带缓存的，不一定有帧存，在结构和价格上也有区别。只带缓存的相机结构简单，价格便宜。 此外，还有一些简单的参数，如相机图像的帧率FPS，图像的亮度、饱和度、对比度等等，由于比较常见，顾名思义，就不继续赘述。先偷个懒，改天想到了啥，再续狗尾。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Cameras</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四元数与旋转矩阵]]></title>
    <url>%2Fposts%2Fdc13723b%2F</url>
    <content type="text"><![CDATA[在计算物体旋转时，如相机标定中的旋转矩阵R，通常都是以三维矩阵表示，三个自由度分别是绕三个坐标轴的旋转角度，但在Unity中，或者像colmap中,都是以四元数(Quaternion)来表示三维旋转的。实际上是复平面向量与实数域矩阵的一个转换关系，这里推导一下。 二维情况一维数轴上的复数对应于一个二维实数空间，比如一个二维空间坐标为 $(x,y)$ 的复数表示为 $x + yi$ 。给定两个复数 $z1 = a + bi$, $z2 = c +di$, 其乘积可以表示为:$$ z1z2 = (a+bi)(c+di) = (ac-bd)+(ad+bc)i $$对于向量$z2$,与$z1$的乘积可以表示为矩阵形式，即：$$\begin{bmatrix}a &amp; -b \\b &amp; a \\\end{bmatrix}\cdot z2$$如果将$z2$也看做一个变换表示成矩阵形式，则$$z1z2 =\begin{bmatrix}a &amp; -b \\b &amp; a \\\end{bmatrix}\cdot\begin{bmatrix}c &amp; -d \\d &amp; a \\\end{bmatrix}$$ 此时满足交换律。 二维旋转设向量模长为1，即$\sqrt[2]{a^2 + b ^2} =1$，则$a = cos\theta, b=sin\theta$, 则对一个向量$\vec{v}=x+yi$,其乘积为$\vec{v} \dot z = (xcos\theta -ysin\theta) +(xsin\theta +ycos\theta)i$, 设向量$\vec{v}$的模为r，则$\vec{v}\cdot \vec{z} = r(cos\theta_1cos\theta_2 -sin\theta_1sin\theta_2)+r(cos\theta_1sin\theta_1 + sin\theta_1cos\theta_2)i = rcos(\theta_1 +\theta_2) +rsin(\theta_1 + \theta_2) i $可以看出，一个单位的二维向量，或一维复数，可以表示成一个旋转变换，即逆时针旋转$\theta$角。 所以二维的旋转矩阵可以很直观的求得:$$\begin{bmatrix}cos\theta &amp; -sin\theta \\sin\theta &amp; cos\theta \\\end{bmatrix}$$ 极坐标形式其实将复数表示成极坐标形式，欧拉公式将三角函数和复平面关联起来，于是可以很直接的将$ e^{i\theta} = cos\theta + isin\theta$带入，角度旋转即$$ e^{i\theta_1} * e^{i\theta_2} = e^{i(\theta_1 + \theta_2)}$$ 三维情况先看向量的旋转: 将向量$\vec{v}$绕旋转轴$\vec{u}$旋转$\theta$角。将$\vec{v}$分解成两个正交向量的和，分别是平行于$\vec{u}$和垂直于$\vec{u}$的向量，记为$\vec{v_{||}}$和$\vec{v_\bot}$,平行的向量旋转不变，因此只需要考虑垂直向量即可。对于$\vec{v_{||}}$，其实就是在$\vec{u}$上的正交投影，因此有$\vec{v_{||}} = \frac{\vec{u}\cdot \vec{v}}{||\vec{u}||^2} \vec{u}$,设$\vec{u}$为单位向量，则可以表示为$\vec{v_{||}} = (\vec{u}\cdot \vec{v})\vec{u}$ 。所以，$$\vec{v_\bot} = \vec{v} - \vec{v_{||}} = \vec{v} - (\vec{u}\cdot \vec{v})\vec{u}$$因为$\vec{v_\bot}$和$\vec{u}$垂直，所以旋转可以转化成二维平面的旋转，构造一个向量$\vec{w} = \vec{u} \times \vec{v}$,如图所示， 所以旋转后的向量为$$\begin{aligned} \vec{v_\bot}^\prime &amp; = \vec{v_\bot}cos\theta + \vec{w}sin\theta \\ &amp; = \vec{v_\bot}cos\theta + \vec{u} \times \vec{v_\bot} sin\theta \end{aligned}$$最后旋转后的向量为 $$ \begin{aligned} \vec{v}^\prime &amp; = \vec{v_{||}} + \vec{v_\bot}^\prime \\ &amp; = \vec{v_{||}} + \vec{v_\bot}cos\theta + \vec{u} \times \vec{v_\bot} sin\theta \\ &amp; = (\vec{u}\cdot \vec{v})\vec{u} + \vec{v_\bot}cos\theta + \vec{u} \times \vec{v_\bot} sin\theta \\ &amp; = (\vec{u}\cdot \vec{v})\vec{u} + (\vec{v} - (\vec{u}\cdot \vec{v})\vec{u} )cos\theta + \vec{u} \times (\vec{v} - (\vec{u}\cdot \vec{v})\vec{u}) sin\theta \\ &amp; = \vec{v}cos\theta +(1-cos\theta)(\vec{u}\cdot \vec{v})\vec{u} +(\vec{u}\times \vec{v}))sin\theta \end{aligned}$$ 四元数四元数可以看做一个四元向量，或是有三个虚部的复数，如$q = a + bi+cj+dk$,也可以写成矩阵形式，$$\vec{q} =\begin{bmatrix}a \\b \\c \\d \\\end{bmatrix}$$ 如三维坐标轴的顺序，复数相乘有，$$ij =k \\jk =i \\ki =j$$令$q1 = a + bi+cj+dk$, $q2 = e + fi+gj+hk$则左乘$q1$可以为$$\begin{aligned}q1q2 &amp; = ae + a f i + agj + ahk + \\&amp; bei − b f + bgk − bhj + \\&amp; cej − c f k − cg + chi + \\&amp; dek + d f j − dgi − dh \\&amp; = ( ae − b f − cg − dh )+ \\&amp; ( be + a f − dg + ch ) i \\&amp; ( ce + d f + ag − bh ) j \\&amp; ( de − c f + bg + ah ) k\end{aligned}$$ 矩阵形式可以写成，$$q1q2 =\begin{bmatrix}a &amp; -b &amp; -c &amp; -d \\b &amp; a &amp; -d &amp; c \\c &amp; d &amp; a &amp; -b \\d &amp; -c &amp; b &amp; a\end{bmatrix}\begin{bmatrix}e \\f \\g \\h \\\end{bmatrix}$$四元数向量不满足交换律，右乘会有一些区别。 Graßmann积将四元数的虚部表示成一个向量，即$ q1 = [a,\vec{v}]$，$q2 = [e, \vec{u}]$，其中，$\vec{v} = bi+cj+dk$，$\vec{u} = fi+gj+hk$。则左乘$q1$可以化简成$$q1q2 = [ ae − \vec{v} \cdot \vec{u} , a\vec{u} + e\vec{v} + \vec{v} \times \vec{u} ]$$这个结果也被称为 Graßmann 积。这样，当a和e为零时，两者乘积可以写成，$$ q1q2 = [− \vec{v} \cdot \vec{u}, \vec{v} \times \vec{u} ]$$同纯虚数的说法，这时q1和q2叫纯四元数。 共轭性质与二元虚数类似，四元数的共轭也是将虚部方向取反，即 $q^* = a - bi - cj - dk$,则 $$\begin{aligned}qq^* &amp; = [s,\vec{v}] \cdot [s,-\vec{v}] \\ &amp; = [s^2 - \vec{v} \cdot (-\vec{v}), s(-\vec{v}) + s\vec{v} + \vec{v}\times(-\vec{v})] \\&amp; = [s^2 + \vec{v} \cdot \vec{v}, \vec{0}] \\\end{aligned}$$ 实部平方与虚部平方和，即该向量的模的平方,最后虚部为零，所以 $$\begin{aligned}qq^* &amp; = [s^2 + \vec{v} \cdot \vec{v}, \vec{0}] \\&amp; = s^2 + |\vec{v}|^2 \\&amp; = a^2 + b^2 + c^2 +d^2 \\\end{aligned}$$ 由于q与其共轭的积最后是个标量，为其模长，所以该乘法是满足交换律的。即$qq^* = q^*q = |q|^2$。这样，$$q^*q = |q|^2 \\\frac{q^*}{|q|^2}q =1$$则可以发现$q^{-1} = \frac{q^*}{|q|^2}$ 满足$q^{-1}q = qq^{-1} =1$,即为该四元数的逆。 而单位四元数的逆即为其共轭四元数。 三维旋转旋转轴$\vec{u}$不妨设为单位向量，与之前的旋转类似，$$ \vec{v’} = \vec{v’_{||}} +\vec{v’_\bot} = \vec{v_{||}} +\vec{v’_\bot}$$之前计算过正交与旋转轴的向量旋转得到的结果，$$\vec{v’_\bot} = \vec{v_\bot}cos\theta + (\vec{u}\times \vec{v_\bot})sin\theta$$设u,v都是纯四元数，即$u = [0,\vec{u}]$,$v = [0,\vec{v}]$,两个纯四元数的Graßmann积为$$uv_\bot = [− \vec{v_\bot} \cdot \vec{u}, \vec{v_\bot} \times \vec{u} ] = [ 0, \vec{v_\bot} \times \vec{u} ] = \vec{v_\bot} \times \vec{u} $$也是一个纯四元数。所以，$$\begin{aligned}v’_\bot &amp; = v_\bot cos\theta + (u v_\bot)sin\theta \\&amp; = (cos\theta + usin\theta)v_\bot\end{aligned}$$令四元数$q = (cos\theta + usin\theta)v_\bot$，则$ v’_\bot = qv_\bot$所以对于垂直于旋转轴的向量，旋转$\theta$角度之后的向量可以用四元数的乘法来获得， 用向量表示为$q = [cos\theta, \vec{u}sin\theta]$由于$\vec{u}$是单位向量，所以$$||q|| = cos^2\theta + ||\vec{u}||^2 sin^2\theta =1 $$同样的表示方式，$qqv_\bot = q(qv_\bot)$几何上表示旋转两次，因此有$qqv_\bot = (cos2\theta + usin2\theta)v_\bot $所以最后旋转之后的四元数，$$\begin{aligned}v’ &amp; = v’_{||} + v’_\bot \\&amp; = v_{||} + qv_\bot \\&amp; = pp^{-1}v_{||} + ppv_\bot \\&amp; = pp^*v_{||} + ppv_\bot\end{aligned}$$其中，$p = [cos(\frac{\theta}{2}),\vec{u}sin(\frac{\theta}{2})]$,是旋转半角的单位向量，因此$q=p^2$。 交换性质：由之前的Graßmann积，上式中，将q写成向量形式，$q = [\alpha, \beta\vec{u}]$$$ \begin{aligned}qv_{||} &amp; = [\alpha, \beta \vec{u}] \cdot [0,\vec{v}_{||}] \\&amp; = [-\beta \vec{u} \cdot \vec{v}_{||} , \alpha \vec{v}_{||} + \beta \vec{u} \times \vec{v}_{||}] \\&amp; = [-\beta \vec{u} \cdot \vec{v}_{||} , \alpha \vec{v}_{||}] \\\end{aligned}$$右乘，$$ \begin{aligned}v_{||}q &amp; = [0,\vec{v}_{||}] \cdot [\alpha, \beta \vec{u}] \cdot \\&amp; = [-\beta \vec{u} \cdot \vec{v}_{||} , \alpha \vec{v} +\vec{u} \times \vec{v}_{||}] \\&amp; = [-\beta \vec{u} \cdot \vec{v}_{||} , \alpha \vec{v} ] \\&amp; = qv_{||}\end{aligned}$$ 再看垂直部分，$$ \begin{aligned}qv_\bot &amp; = [\alpha, \beta \vec{u}] \cdot [0,\vec{v}_{}] \\&amp; = [-\beta \vec{u} \cdot \vec{v}_\bot , \alpha \vec{v}_\bot + \beta \vec{u} \times \vec{v}_\bot] \\&amp; = [0, \alpha \vec{v}_\bot + \beta \vec{u} \times \vec{v}_\bot] \\\end{aligned}$$ 右乘共轭，$$ \begin{aligned}v_\bot q^* &amp; = [0,\vec{v}_\bot] \cdot [\alpha, -\beta \vec{u}] \cdot \\&amp; = [-\beta \vec{u} \cdot \vec{v}_\bot , \alpha \vec{v}_\bot + \beta \vec{u} \times \vec{v}_\bot] \\&amp; = [0, \alpha \vec{v}_\bot + \beta \vec{u} \times \vec{v}_\bot] \\&amp; = qv_\bot\end{aligned}$$ 所以旋转之后的结果可以化简为$$\begin{aligned}v’ &amp; = pp^*v_{||} + ppv_\bot \\&amp; = pv_{||}p^* + pv_\bot p^* \\&amp; = p(v_{||} + v_\bot) p^* \\&amp; = pvp^*\end{aligned}$$ 实际上，从计算过程可以看出，对于平行分量，乘$pp^*$，实际上是没有变化，对于垂直分量，乘$pp$,旋转了$\frac{\theta}{2} + \frac{\theta}{2} = \theta$角度。因此可以用旋转半角的四元数乘法来表示绕单位向量$\vec{u}$的旋转。 矩阵形式单位向量$p= [cos(\frac{\theta}{2}), \vec{u}sin(\frac{\theta}{2})]$,以通用四元数方式表示为$p = a + bi + cj + dk$其中$a=cos(\frac{\theta}{2}), b=u_x sin(\frac{\theta}{2}),c=u_y sin(\frac{\theta}{2}), b=u_z sin(\frac{\theta}{2})$写成矩阵形式，之前说了四元数的矩阵形式左乘和右乘有点区别，左乘矩阵为$$L=\begin{bmatrix}a &amp; -b &amp; -c &amp; -d \\b &amp; a &amp; -d &amp; c \\c &amp; d &amp; a &amp; -b \\d &amp; -c &amp; b &amp; a\end{bmatrix}$$ 右乘的矩阵等同于左乘矩阵$$R = \begin{bmatrix}a &amp; -b &amp; -c &amp; -d \\b &amp; a &amp; -d &amp; -c \\c &amp; -d &amp; a &amp; b \\d &amp; c &amp; -b &amp; a\end{bmatrix}$$ 所以有， $$\begin{aligned}qvq^* &amp; = L(q)R(q^*)v \\&amp; =\begin{bmatrix}a &amp; -b &amp; -c &amp; -d \\b &amp; a &amp; -d &amp; c \\c &amp; d &amp; a &amp; -b \\d &amp; -c &amp; b &amp; a \\\end{bmatrix}\begin{bmatrix}a &amp; b &amp; c &amp; d \\-b &amp; a &amp; -d &amp; c \\-c &amp; d &amp; a &amp; -b \\-d &amp; -c &amp; b &amp; a \\\end{bmatrix}v \\&amp; =\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1-2c^2-2d^2 &amp; 2bc-2ad &amp; 2ac+2bd \\0 &amp; 2bc+2ad &amp; 1-2b^2-2d^2 &amp; 2cd -2ab \\0 &amp; 2bd-2ac &amp; 2ab+2cd &amp; 1-2b^2-2c^2 \\\end{bmatrix}v \\\end{aligned}$$ 矩阵最外圈不会有任何影响，所以可以得出向量$\vec{v}$绕单位向量旋转轴$\vec{u}$旋转的三维矩阵变换，即 $$\vec{v’} =\begin{bmatrix}1-2c^2-2d^2 &amp; 2bc-2ad &amp; 2ac+2bd \\2bc+2ad &amp; 1-2b^2-2d^2 &amp; 2cd -2ab \\2bd-2ac &amp; 2ab+2cd &amp; 1-2b^2-2c^2 \\\end{bmatrix}\vec{v}$$ 其中$a=cos(\frac{\theta}{2}), b=u_x sin(\frac{\theta}{2}),c=u_y sin(\frac{\theta}{2}), b=u_z sin(\frac{\theta}{2})$。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Quaternion</tag>
        <tag>Mathpix</tag>
        <tag>Pi-hole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小工具(二)]]></title>
    <url>%2Fposts%2Fd8bd5c14%2F</url>
    <content type="text"><![CDATA[竟然真的有后续！！！ 选中区和剪贴板工具XClipXClip工具可以非常方便的操作，清空剪贴板，高效的复制粘贴等，直接从apt商店就可以直接安装(测试所用Ubuntu环境)。 输出选中区和剪贴板内容选中区是指用鼠标选中区域的内容，在Ubuntu下有个快捷的复制粘贴方式就是利用选中区，通常鼠标中键是粘贴选中区内容。用xclip输出选中区内容命令: 1xclip -o 如果要读取系统剪贴板的内容，可以加个参数: 1xclip -selection clipboard -o 或者简写为: 1xclip -sel c -o 输出到文件 12xclip -o &gt; filexclip -sel c -o &gt;file 读入到选中区和剪贴板平时用鼠标和Ctrl C\V或者Ctrl Shift C\V即可完成一般的复制粘贴，但有大量文字时，满满的移动鼠标就显得比较繁琐，利用xlip可以不借助鼠标比较方便的实现。 12xclip -i filexclip -sel -c -i file 其他几种形式: 123456echo "Hello Dog" | xclipecho "Hello Dog" | xclip -sel cxclip &lt; filexclip -sel c &lt; filexclip filexclip -sel c file 图像转LaTeX工具Mathpix可以将包含公式的图像直接转化为LaTeX语法。 1sudo snap install mathpix-snipping-tool 可以使用键盘快捷键 Ctrl+Alt+M 开始使用 Mathpix 截图,它会立即将图中公式转换为 LaTeX 语法并保存在剪贴板中。 然而现在开始收费了，免费版的一个月只能用50次。 广告拦截工具Pi-hole与传统的浏览器广告拦截插件不同，声称是通过个人Linux硬件进行全网广告拦截，通过DNS污染实现，具体仓库在此。 安装方式很多，最直接就是curl直接拉脚本运行: 1curl -sSL https://install.pi-hole.net | bash 安装完成后可以配置路由器来使所有的经过动态主机分配协议(DHCP)的主机使用Pi-hole作为其DNS服务器，来确保该网络所有的主机都可以进行广告拦截。配制方法在此。 如果路由器不支持DNS设置，可以禁用DHCP后，使用Pi-hole的内置DHCP服务器。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Mathpix</tag>
        <tag>Pi-hole</tag>
        <tag>Xclip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[私有办公服务搭建]]></title>
    <url>%2Fposts%2F8c1f2c30%2F</url>
    <content type="text"><![CDATA[鉴于Microsoft Office通常体积臃肿，而且只在Windows下能用。虽然LibOffice开源且免费，适用于各个平台，但碍于接触到的多是Microsoft Office的文档，打开时经常格式很乱，于是考虑搭建一种服务，可以在浏览器中处理文档，类似于Google Docs或者Office Online. Office服务搭建目前已经有比较优秀的DzzOffice了,而且开源，仓库地址在此，可以在此处查看演示。可以自己搭建一个，另外该仓库也提供了Docker部署版本。克隆仓库之后直接使用docker-compose up -d即可部署。 12345git clone https://github.com/zyx0814/dzzoffice.gitcd dzzofficegit checkout docker chmod 777 -R data dzz configdocker-compose up 不过目前编译，会出现一些问题: Build php error:1ERROR: http://dl-cdn.alpinelinux.org/alpine/v3.4/main: temporary error (try again later)` 原因主要在两个方面： 一是本机Docker的DNS设置： 1sudo vim /etc/docker/deamon.json 将DNS修改正确；另一个问题是alpine镜像的DNS问题，测试一下：1docker run -it --rm php:7.1.0-fpm-alpine sh -c " ping dl-cdn.alpinelinux.org" 显示bad address. 在php的Dockerfile中加一行，然后重启服务 123docker run -it --rm php:7.1.0-fpm-alpine sh -c "echo nameserver 8.8.8.8 &gt; /etc/resolv.conf &amp;&amp; ping dl-cdn.alpinelinux.org"sudo systemctl daemon-reloadsudo systemctl restart docker Php compose error:1234567composer global require --no-progress "fxp/composer-asset-plugin:~1.2"[RuntimeException]No composer.json present in the current directory, this may be the cause of the following exception. [Composer\Downloader\TransportException] Content-Length mismatch, received 549815 bytes out of the expected 1180102 同样修改Dockerfile，安装完compose之后，添加一行： 1composer config -g repo.packagist composer https://packagist.phpcomposer.com Build pma error:1/bin/bash apk not found 可能是镜像更新了，里面用的ubuntu amd64环境，是apt-get安装，修改pma的Dockerfile，指定一个稍老的版本即可。 至此，服务搭建成功。 服务配置数据库用户名和密码在部署环境之前，可以在docker-compose.yml中配置，然后在浏览器中打开localhost开始进行配置。 登录之后，需要进行配置，添加应用，比如office，如添加onlyoffice，可以先装一个onlyoffice的服务: 1docker run -i -t -d --name onlyoffice -p 8000:80 onlyoffice/documentserver 然后在应用库中添加onlyoffice，设置api地址， 1http://YOUR_SERVER_ADDRESS:8000/web-apps/apps/api/documents/api.js 然后就可以编辑文档了。 绘图服务部署类似如Visio的工具，目前体验比较好的有DrawIO，也是开源的，可以直接部署到自己的服务器上，在浏览器中绘图，快速轻便,易于分享。 1docker run -it --rm --name="draw" -p 8080:8080 -p 8443:8443 jgraph/draw.io 在浏览器中打开指定端口地址即可开始绘制。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Office</tag>
        <tag>DzzOffice</tag>
        <tag>DrawIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小工具(一)]]></title>
    <url>%2Fposts%2F778cc776%2F</url>
    <content type="text"><![CDATA[太久没回来了，其实很多次想写但是无法静下心来，思绪如开始停更的三月里乱飞的柳絮，总感觉经历了很多，但却没有力气吐出一个字。终于处暑，昔时聚在一起的人们也已经走得差不多了，终于也想起了，该随便写点什么了。 就推荐一些小工具吧，这段时间发现的，感觉挺有意思的。以后也不知道会不会继续，先假设是个连续剧吧，写完拖更的那种。 FlashCards一个类似单词卡的小工具，也可以用来放代码，示例仓库FlashCards方法很简单，直接用Docker启动，可以放在自己的电脑上，也可以放在自己的服务器上，挂一个端口，然后可以Web端远程访问。另外，单词数据可以直接上传Github仓库，环境不需要。这样随时随地，就是一个私人的Note？搭好之后访问大概是这样: 终端美化LSD主要功能是将Linux下的ls命令输出结果美化一下，不同的文件类型会有不同的图标，不过目前颜色还不支持修改。大概效果如下: 仓库地址在此。不过需要安装NerdFonts Tree2dotx就是将树形结构描述转化为DOT描述。 DOT语言是一种文本图形描述语言，可用于画有向无向图、流程图，语法比较简单，网上一搜就有，这里不做介绍。比如将当前目录下的文件转成关系图，使用tree2dotx工具,命令为：1tree | tree2dotx &gt; out.dot GraphvizGraphviz(Graph Visualization Software)是一个由AT&amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形,官网在这,可以从DOT文件生成图像，常见的有png/gif/svg等。如果将之前的树形目录保存为关系图，只需要继续将上面的命令重定向即可。 1tree | tree2dotx | dot -Tpng -o list.png 保存为list.png文件，大致就是这个样子: Gprof一个代码性能分析工具，结合Gdb可以很方便的分析所写的代码。主要方式是在使用gdb编译时加上-pg参数，然后正常运行程序，最后会出现一个gmon.out的文件，里面就是各个函数的信息。结合Graphviz，可以得到函数关系调用图。1gprof -b ./test gmon.out | gprof2dot | dot -Tpng -o test.png 其中gprof2dot工具可以通过pip安装。最后结果如下: 里面有各个函数调用次数、运行时间等情况，保存为svg也可以在浏览器中看。 EMMMM, To be continued…]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>flashcards</tag>
        <tag>lsd</tag>
        <tag>tree2dotx</tag>
        <tag>graphviz</tag>
        <tag>gprof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图床搭建]]></title>
    <url>%2Fposts%2Ff7ade587%2F</url>
    <content type="text"><![CDATA[周末回来发现博客里的图片全成了码云的个性403了，原来是因为很多公共的图床存活不了多少年，而且当图不再使用时，不便于回收，所以在图床选择这方面，纠结了很久。后来Github认为在其上传图片获取外链并不算滥用，但是Github在国内的速度比较慢，对于背景图来说，就是肉眼可见的卡了。好在当时发现了Coding和码云，于是在码云(Gitee)上用其Issue页上传图片做图床。然而不幸的是，大概他们是觉得滥用了，于是被防盗链了。 图床搭建然后又像以前一样，对比了很多现有的图床，依然没找到能安心存放的地方。于是想到手里还有VPS，便打算搭建一个了。最开始是一个同学送的天翼云，估计是办宽带送的，结果发现80和443端口全被封了，问客服说要备案才行，想着备案就备案吧，然而当看到备案要填的资料时，立马放弃了。另一个就是Vultr上的，国外的云主机商相比于国内，条件限制宽了不少，不用动不动就实名或者备案，虽不会发表什么不当言论，但吃相看着令人难受。现有图床挺多的，目前打算用一个开源的荔枝图床,有现成的Docker镜像，界面比较美观，官网在这。 Docker环境安装其实云主机还好，如果觉得官方的Docker下载太慢，也有Daocloud的CDN加速的镜像，直接一条命令就可以完成:1curl -sSL https://get.daocloud.io/docker | sh 等安装完成之后，就可以拉取镜像了，1docker pull kdelfour/lychee-docke 或者直接试运行，看看效果:1docker run -it -d -p 80:80 kdelfour/lychee-docke 这时，在本地浏览器输入云主机的IP，就可以看到一个基本的界面了。完整的命令是：1docker run -it -d -p 80:80 -v /your-path/uploads/:/uploads/ -v /your-path/data/:/data/ -v /your-path/mysql/:/mysql/ kdelfour/lychee-docker 分别挂载上传图片的uploads文件夹、data文件夹和数据库储存的mysql文件夹，并映射80端口。这时候再登陆该地址，会提示要初始化一些配置，可以用官方提供的配置：1234url : localhostdatabase name : lycheeuser name : lycheeuser password : lychee 然后就是创建用户名和密码了，创建成功，图床已经初步建成。 但是现在直接做图床，看到的链接都是丑陋的IP和http字段组成的地址，干干巴巴，麻麻赖赖的，一点都不圆润。所以接下来就要盘它了。一方面是IP更换为域名，另一方面是HTTP更换为更为安全的HTTPS。 域名申请为IP申请一个域名，然后配置DNS，将域名直接以A类指向云主机IP即可。过一段时间应该就可以在本地看到域名解析生效：1$dig $YourUrl 然后直接在浏览器输入域名即可访问。 HTTPS支持要将HTTP转为HTTPS主要有两个步骤，一个是申请证书，一个是安装证书。 SSL证书申请偶然发现了FreeSSL这个网站，申请证书是真的方便，还有一个支持各大平台的客户端KeyManager，可以直接在里面申请Let’s Encrypt证书或者TrustAsia证书，一般前者半年，后者一年，因为比较懒，所以选后者。在里面申请证书后，会有两种方法验证，一种是DNS验证，另一种是文件验证。对于DNS验证，它会给你一串字符，让你到DNS解析设置里添加一个TXT解析，并粘贴为该字串。但是验证结果是香港和美国通过了，大陆总是验证失败，提示CNAME超时。因此选择文件验证了。要将文件放在网站中进行验证，需要将其拷进Docker中，或者直接Docker容器中拷出来。1Docker cp $YourContainer:/var/www/lychee/ www/lychee/ 然后将SSL验证文件放入该文件夹中重新挂载:1docker run -it -d -p 80:80 -v /root/images/uploads/:/uploads/ -v www/lychee/:/var/www/lychee/ -v data/:/data/ -v mysql/:/mysql/ kdelfour/lychee-docker 然后就可以验证成功了，之后可以生成证书并下载Nginx证书。 Nginx配置修改接下来就是容器配置了，将HTTP转换为HTTPS。 SSL证书安装首先将生成的证书放到网站的某个目录中，一个公钥和一个私钥。然后修改Docker容器的Nginx配置文件，也可以将其从容器中拷贝出来，再作修改：1docker cp $YourContainer:/etc/nginx/ nginx/ 然后进入nginx/sites-enabled目录，修改lychee文件。加入HTTPS的端口以及SSL证书的地址：123456789listen 443 ssl; server_name localhost; keepalive_timeout 70; ssl on; ssl_certificate /etc/nginx/sslkey/server.pem; ssl_certificate_key /etc/nginx/sslkey/key.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; HTTP跳转当使用HTTP访问时，直接跳转到HTTPS，有很多方法，这里使用497的错误码实现跳转：在Nginx的Server配置中加上 1error_page 497 https://$YourSite/ 然后重新挂载容器，此时需要指定HTTPS协议的443端口，以及Nginx配置文件目录： 1docker run -it -d -p 80:80 -p 443:443 -v nginx/:/etc/nginx/ -v uploads/:/uploads/ -v www/lychee/:/var/www/lychee/ -v data/:/data/ -v mysql/:/mysql/ kdelfour/lychee-docker 此时即可正常访问图床，示例如下：]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>图床</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本用法]]></title>
    <url>%2Fposts%2F29103606%2F</url>
    <content type="text"><![CDATA[目前版本控制系统比较流行的就是SVN和Git了，相比较而言，Git有分布式的优势，对网络依赖性更低，但SVN简单，这一条就有很强的生存能力了。用Git已经好几年了，不过很长一段时间只是在用clone pull add commit push这些类Ctrl+C/V的命令(Office中)，连操作Head指针实现Ctrl+Z/Y都没怎么用，想起去年收到了Leancloud的10X程序员笔记本，里面附页还写着几行Git命令，突然觉得有些陌生了。 也只是突然想到，回忆一下，当是补上多年前未肯作的笔记了。 基本文件操作检查文件状态Git检查文件状态可以使用git status,可以看到已经提交的修改和未提交的修改:1234567891011121314On branch masterYour branch is up to date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: source/_drafts/git.md modified: source/talks/index.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: source/_drafts/git.md 使用git diff可以查看尚未暂存的文件的修改: 1234567891011121314151617181920@@ -1,4 +1,26 @@...+Git检查文件状态可以使用`git status`,可以看到已经提交的修改和未提交的修改: +On branch master+Your branch is up to date with 'origin/master'.++Changes to be committed:+ (use "git reset HEAD &lt;file&gt;..." to unstage)++ modified: source/_drafts/git.md+ modified: source/talks/index.md++Changes not staged for commit:+ (use "git add &lt;file&gt;..." to update what will be committed)+ (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)++ modified: source/_drafts/git.md++使用`git diff`可以勘察尚未暂存的文件的修改: \ No newline at end of file 另外加上--cached或者--staged(新版支持)参数，可以直接查看已暂存的和上次提交时的差异。123456789101112131415git diff --stageddiff --git a/source/_drafts/git.md b/source/_drafts/git.mdindex b220f55b..ce996f92 100644--- a/source/_drafts/git.md+++ b/source/_drafts/git.md@@ -1 +1,4 @@-title: Git用法+title: Git基本用法++目前版本控制系统比较流行的就是SVN和Git了，相比较而言，Git有分布式的优势，对网络依赖性更低，但SVN简单，这一条就有很强的生存能力了。用Git已经好几年了，不过很长一段时间只是在用`clone pull add commit push`这些类`Ctrl+C/V`的命令(Office中)，连操作Head指针实现`Ctrl+Z/Y`都没怎么用，想起去年收到了Leancloud的`10X`程序员笔记本，里面附页还写着几行Git命令+#\ No newline at end of filediff --git a/source/talks/index.md b/source/talks/index.mdindex d13db982..63515f47 100644 基本文件操作除去系统自带的mv或者rm命令，Git也有自己的git mv和git rm命令，在Git仓库中，后者不仅仅是对文件做了前者的操作，也在工作目录中做了前者的操作。如git rm在删除文件后，也从跟踪文件清单中删除了该文件(使用--cached只是从暂存区中删除，使用-f同时也删除文件)，以后不会再跟踪该文件，而rm命令的操作记录依然会被记录在跟踪文件清单中。一个简单的例子，先创建一个文件:1touch test 此时未放入暂存区，直接删除就可以，Git也不会记录，但是如果Git已经跟踪了该文件，则直接删除状态为:12345678910111213141516171819git add test rm testgit statusOn branch masterYour branch is up to date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: source/_drafts/git.md new file: testChanges not staged for commit: (use "git add/rm &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: source/_drafts/git.md deleted: test 如果使用git rm test，可以看到:12345678910111213141516git rm testgit statusOn branch masterYour branch is up to date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: source/_drafts/git.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: source/_drafts/git.md 可以看到，test文件的记录已经被删除了。同样，git mv也是一样的类型，git mv file1 file2相当于:123mv file1 file2git rm file1git add file2 查看提交历史查看每次的提交历史可以直接使用git log，可以看到每次的提交记录。另外，加上-p参数可以展开每次提交的内容差异，加上-{d}可以指定显示最近次数的差异，如-2显示最近两次提交的差异。加上--since或者--until可以限制时间查询，如可以用git long --since=2.weeks显示最近两周的修改。加上--word-diff可以进行单词层面的对比，加上--graph以ASCII图形表示的分支合并历史。如果只想看每次提交的简略信息，可以加上-stat参数。另外，可以使用--pretty指定展示提交历史的格式，如用oneline将每个提交放在一行显示(--pretty常用参数有oneline，short，full，fuller和format(后跟指定格式))。 撤销操作仅修改提交信息如果提交信息写错了，或者有些文件漏掉了未添加到暂存区，可以使用amend指令重新提交:123git commit -m "add test"git add testgit commit --amend 这样就完成了提交信息的修改。 取消暂存区文件如果想取消暂存区的某个文件的暂存，有两种方法。一是上面的git rm --cached直接将文件从暂存区中删除，实际文件不受影响。另外一个是HEAD指针的操作。HEAD可以理解为指向当前分支的指针，指向该分支最近一次的调用，操作HEAD指针即可实现版本回退等操作。这里直接使用reset命令，将某个文件重置到最近一次提交时的状态:1git reset HEAD test 因为上次test未暂存，所以相当于从暂存区中取消该文件。 撤销对文件的修改使用git checkout -- file可以撤销上次提交以来，对某个文件的所有修改，本质上是拷贝了上次提交时的该文件来覆盖它，因此对该文件做的任何修改都会消失。该命令需要谨慎使用，最好的方式是通过分支的保存进度来恢复。Git中所有已经提交的东西基本上都是可以恢复的，但未暂存的就不属于Git恢复的范畴了。 远程仓库Git主要是在本地修改好了再推送到远程仓库，实际上对远程仓库的操作比较少，就一些基本的推拉行为。 查看远程仓库。直接使用git remote即可查看当前的远程仓库，加上-v选项可以以详细模式查看。 添加远程仓库。直接使用git remote add &lt;shortname&gt; &lt;url&gt;，将仓库名和地址添加即可。 从远程仓库抓取数据。有两种需求，一种是只从远程仓库拉取数据，但并不合并到当前分支，可以使用git fetch &lt;remotename&gt;命令。另外，使用git clone获取的远程仓库会自动归于origin名下。另一种，需求是自动抓取并合并到当前分支，可以使用git pull命令。 推送数据到远程仓库。基本操作，git push &lt;remotename&gt; &lt;branch&gt;。 查看远程仓库信息。 1git remote show &lt;remote-name&gt; 远程仓库的删除和重命名。 删除远程仓库: git remote rm &lt;remotename&gt; 重命名远程仓库： git remote rename &lt;orignname&gt; &lt;newname&gt; 标签Git可以给历史中的某个提交打上标签，以示其重要性，如v1.0等。 列出标签列出已有标签，可以直接使用git tag命令，加上-l参数可以过滤选项。如 1git tag -l 'v1.0.1*' 创建标签标签分为轻量标签和附注标签，轻量标签如其名轻量，只是一个特定提交的引用，本质上是将提交校验和存储到一个文件中，没有保存其他任何信息，因此创建也比较简单。附注标签则是Git数据库中的一个完整对象，是可以被校验的。附注标签通常包含打标签者的姓名、邮件地址、日期、标签信息等，并可以使用GPG(GNU Privacy Guard)签名及验证。 创建附注标签: 最简单的方式是使用tag的-a选项: 1git tag -a v1.1 -m "new test version" 查看标签:123git tag v1.0v1.1 其中，-m是存储在标签中的信息，是必填内容。使用git show也可以看到标签信息与对应的提交信息。 创建轻量标签: 轻量标签的创建不需要任何选项，直接提供标签名字即可。 1git tag v1.11 查看标签:1234git tagv1.0v1.1v1.11 此时用git show只能看到标签的提交信息，没有额外信息。 后期上标签也可以对过去的提交上标签，使用git log --pretty=oneline时可以看到每次提交的校验和，如某次校验和是e0c29751bf13be3df3b5030cc589685752bd9fb6,则可以通过该校验和给该次提交打上标签:1git tag -a v0.8 e0c2975 实际只需要部分校验和即可。 分享标签通常情况，git push并不会将标签推送到服务器上，需要通过显示命令才能分享标签到远程仓库。1git push origin &lt;tagname&gt; 如果要一次性推送所有本地新增标签到服务器上，则可以使用--tags参数:1git push origin --tags 删除标签删除本地仓库的标签，可以使用:1git tag -d &lt;tagname&gt; 如果要同时删除远程标签，则需要使用git push &lt;remotename&gt; :refs/tags/&lt;tagname&gt;来更新远程仓库标签。 标签检出可以使用git checkout命令查看某个标签指向的文件版本。但会使仓库处于头指针分离(“detacthed HEAD”)的状态：在”头指针分离“状态下，如果做了某些更改然后提交他们，标签不会发生变化，但新的提交不属于任何分支，也无法访问，除非确切的提交哈希。所以如果要进行更改，通常需要创建一个新分支:12git checkout -b newversion v1.12 Switched to a new branch 'newversion' 如果继续对newversion分支做改动，该分支的提交指针会继续向前移动，就不是原来的v1.12标签了。 分支Git好用很大原因是其极具优势的分支模型，使得分支处理方式更为轻量。在使用git commit新建一个提交对象前，Git会先计算每一个子目录的校验和，然后在Git仓库将这些目录保存为一个Tree对象，然后就可以创造一个提交对象，并包含了指向这个Tree对象的指针。Git使用blob类型的对象存储此次保存的快照。关于Git的树结构，可以用Git官方仓库中的一张图说明:这是首次提交后的结构图，此时Git仓库中有五个对象(五个校验和)，最右侧的是三个存储文件快照的blob对象，中间是记录目录结构和blob对象索引的树对象，最左侧是包含指向书对象的指针和所有提交信息的提交对象。此时因为是第一次提交，相当于祖先提交，提交对象中没有父对象，但之后的所有提交对象中，都会多一个父对象指针，指向上次提交。Git分支在本质上是一个指向最新提交对象的指针，每次提交操作之后，指针都会更新到最新提交。 分支就是某个提交对象往回看的历史。 使用git branch可以列出所有的分支，加上--merged或--no-merged可以显示已合并或未合并的分支。 分支创建Git使用master作为默认的分支名，如果要创建分支，可以使用branch选项。1git branch &lt;branchname&gt; 但此时只是新建了一个分支，并未将当前工作分支切换过去。Git确定当前工作的分支是使用HEAD指针，HEAD指针指向哪个分支，当前就在哪个分支工作。也可以使用git log -decorate命令查看各个分支当前所指的对象。 分支切换切换分支即修改HEAD指针指向，可以使用chenkout命令实现。1git checkout &lt;branchname&gt; 在每次提交后，HEAD指针会随着当前分支一起向前移动以保证以后分支能正确切换回来。或者直接使用命令:1git checkout -b &lt;branchname&gt; 可以在新建分支的同时切换到该分支，-b可以理解为branch，相当于:12git branch &lt;branchname&gt;git checkout &lt;branchname&gt; 分支合并在某个分支上进行操作，使得该分支指针向前移动后，如果要将该分支合并到其他分支，则可以切换到其他分支进行merge操作:1git merge &lt;branchname&gt; 当两个分支没有需要解决的分歧时，可以直接合并。 删除分支当分支不再使用时，可以删除:1git branch -d &lt;branchname&gt; 对于未合并的分支，直接删除会失败，可以使用-D强制删除。 冲突合并如果合并的两个分支，并不是直接祖先关系，两个分支在其共同祖先分支上都做了修改，如果修改没有冲突，如修改的都是不同的文件，则Git会自动新建一个提交，将共同祖先分支以及两个要合并的分支共同合并建立一个新的提交。此时Git会自行决定选取哪个提交作为最优的共同祖先。但是如果两个不同分支都对同一个文件做了修改，在合并时就会引起冲突，因为Git不知道到底该对这个文件做如何操作。此时Git会先暂停下来，等待用户解决冲突。这种情况在平时也经常会遇到，如在本地对某个远程仓库做了修改，但是远程仓库在此之前已经在另一台电脑上做了push操作，这时使用pull操作就会自动抓取并合并到当前分支，如果存在冲突，pull时就会提示哪个文件修改冲突，并等待用户解决。此时，可以使用git status查看状态。解决冲突后可以重新使用git add将其标记为冲突已解决。 远程分支远程引用是指向远程仓库的指针，包括分支、标签等，可以通过git ls-remote &lt;remotename&gt;查看远程引用的完整列表，或者通过git remote show &lt;remote&gt;查看远程分支的更多信息。远程跟踪则是指向远程分支状态的引用，只有当与远程仓库通信时，它们会自动移动。用户无法手动修改其状态。可以使用git fetch命令将远程仓库中的内容拉取到本地，同事远程跟踪会更新到新的远程分支状态。当本地与远程的工作出现分叉之后，合并到本地分支时，依然会考虑是否有冲突的问题，解决方式和其他冲突分支合并一样。 推送本地分支使用git push将本地分支推送到远端:1git push origin test 等价于1git push origin test:test Git会自动将test名字展开为refs/heads/test:refs/heads/test。 跟踪分支使用checkout可以实现对分支的跟踪：1git checkout --track origin/test 通常可以新建一个本地分支来跟踪拉取的远程分支:1git checkout -b sf origin/test 也可以使用-u或--set-upstream-to选项来直接设置已有的本地分支来跟踪拉取的远程分支:1git branch -u origin/test 另外，可以使用git branch -vv命令查看设置的所有跟踪分支。 合并分支可以使用git fetch拉取分支后再使用git merge合并到本地分支，也可以直接使用git pull拉取并合并到本地分支。但是有时候git pull会显得有些佛性，难以理解，最简单的方式是fetch与merge的组合。 删除分支删除远程分支可以使用:1git push origin --delete test 或者直接将空分支推送到远端覆盖远端分支即可：1git push origin :&lt;remotebranch&gt; 变基这个是个有趣的用法，自从有了变基，Github就变成了Gayhub (逃 )。啊呸！当然不是这个原因。变基是一种整合分支的方法，通常整合分支有两种方法：合并和变基。合并(merge)之前已经经常用到了，主要就是将一个分支合并到另一个上。而变基(rebase)则是将一个分支里提交的修改在另一个分支上重放一边，也就是走别人的路，让别人说去吧。一个基本的例子如下：12git checkout branch1git rebase branch2 此时，Git会先找到这两个分支的分叉点（即最近共同祖先），然后从分叉点开始，将branch1所经历的操作，给branch2也体验一下。然后回到branch2,进行一次快进合并：12git checkout branch2git merge branch1 其实就这个例子来看，变基和合并没有任何区别，但这样可以保证在向远程分支推送时保持提交历史的简洁。另外，变基可以放到其他分支进行，并不一定非得依据分化之前的分支。可以从一个特性分支里再分出一个特性分支，然后跳过前面的特性分支，将后者与主分支进行变基，可以使用--onto选项。1git rebash --onto master branch1 branch2 即取出branch2分支，找到branch1和branch2的分离点，然后在master分支上重放其共同祖先之后的修改。然后就可以将变基后的分支快进合并到master分支上:12git checkout mastergit merge branch2 剩下的也可以将branch1合并到master中:1git rebase master branch1 然后快进合并master分支:12git checkout mastergit merge branch1 之后就可以删除无用的分支了。 变基风险因为人人都可以编辑，所以一旦分支中的对象提交发布到公共仓库，就千万不要对该分支进行变基，不然其他人不得不重新将手里的工作和你的提交进行整合，接下来你也要重新拉取他们的提交进行整合，引入太多不必要的麻烦。总之用官方一句加粗的话说: 不要对在你的仓库外有副本的分支执行变基。 其他操作别名和Linux的alias命令一样的意思，也是方便在git中快速操作。1234$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status 设置别名后，通过 git co即可实现git checkout命令。 储藏当不想提交现在的工作状态，又想切换到别的分支进行工作，可以先将当前状态出藏起来。储藏(Stash)可以获取工作目录的中间状态——也就是修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。使用git stash list可以查看当前储藏的列表。如果之后要恢复储藏的状态，可以使用：1git stash apply Git则会默认恢复最近一次的储藏，如果想应用更早的储藏，则可以通过名字指定，如：1git stash apply stash@&#123;2&#125; 此时对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。可以通过运行git stash apply命令时带上一个--index的选项来告诉命令重新应用被暂存的变更。apply选项只尝试应用储藏的工作,但储藏的栈上仍然有该储藏。可以通过运行git stash drop，加上希望移除的储藏的名字来移除该储藏，或者直接通过git stash pop来重新应用储藏并在此之后快速删除栈上的储藏。 取消储藏如果要取消之前所应用的储藏的修改，可以通过取消该储藏的补丁达到该效果:1git stash show -p stash@&#123;0&#125; | git apply -R 如果没有指定储藏名称，则会自动选择最近的储藏:1git stash show -p | git apply -R 从储藏中创建分支在储藏一个工作状态后，继续在该分支上工作，最后还原储藏的时候可能会引起合并冲突，此时可以新建一个储藏分支简化工作。1git stash branch &lt;branchname&gt; 此时Git会创建一个新的分支，检出储藏工作时的所处的提交，重新应用，如果成功，则丢弃储藏。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Telegram接管聊天消息]]></title>
    <url>%2Fposts%2Fb03b049f%2F</url>
    <content type="text"><![CDATA[虽有Web微信的简陋功能，虽有electronic的外观封装，但每次登陆实在太麻烦，以及很多功能被限制，表情无法接收等，被鹅厂放弃的Linux用户对微信的体验大概确实不好。 关于Telegram关于Telegram(电报)，直接引用维基上的介绍: Telegram是一个跨平台的即时通信软件，它的客户端是自由及开放源代码软件，但是它的服务器是专有软件。用户可以相互交换加密与自毁消息，发送照片、影片等所有类型文件。官方提供手机版（Android、iOS、Windows Phone）、桌面版（Windows、macOS、Linux）和网页版等多种平台客户端；同时官方开放应用程序接口，因此拥有许多第三方的客户端可供选择，其中多款内置中文。 这个是俄国的社交服务VK的创始者杜洛夫兄弟的作品，Telegram Messenger LLP是独立的非营利公司，与VK也没啥关系，所有的宗旨只在于保证聊天和隐私安全。但不接受监管的软件通常过的不是太好，追求绝对的隐私安全，以至于其在各个国家遭受了被封锁的命运。其他国家暂且不论，因为不肯交出密钥，连俄罗斯媒体监管机构都请求法庭再全国范围内封锁该软件。抛开这些原因不谈，就技术方面，其良好的功能体验，开源的客户端以及开放的应用程序接口，已经领先于绝大多数同类APP了。Tencent基本是属于放弃Linux用户的一类，后来新注册的微信号连网页版都无法使用，虽然嫌弃通常是相互的，但微信之类的产品用的人太多，粘性太大，有时候不得不用其交流，等网页版每次都要扫一下也是麻烦，所以直接使用Telegram的机器人来收发微信消息。 环境安装聚合社交平台这方面，EFB做的不错，而且也有了现成的Docker镜像（由royx提供），使得环境搭建更为简单。另外，需要一台能访问外网的主机，主要是能访问TG(Telegram)服务器。然后安装Docker:1curl -sSL https://get.daocloud.io/docker | sh 安装好之后，就可以拉取镜像了:1docker pull royx/docker-efb 配置TG Bot主要方式是通过登陆网页版微信，然后将微信消息通过Bot发送及接受。首先需要配置TG Bot: 搜索并找到@botfather机器人，然后发送指令:/newbot 给Bot起个名字。 给机器人起用户名，以bot结尾 获取机器人的Token 设置Bot隐私权限: 默认Bot可能无法接收非/开头的消息，所以需要设置隐私权限。向该机器人发送指令/setprivacy，选择刚刚创建的机器人，点Disable即可。 允许将Bot添加进群组: 给机器人发送指令/setjoingroups,选择enable。 允许Bot提供指令列表: 给机器人发送指令/setcommand，输入以下内容： 12345678help - 显示命令列表.link - 将远程会话绑定到 Telegram 群组chat - 生成会话头recog - 回复语音消息以进行识别info - 显示当前 Telegram 聊天的信息.unlink_all - 将所有远程会话从 Telegram 群组解绑.update_info - 更新群组名称和头像extra - 获取更多功能 获取TG ID搜索另外一个机器人@get_id_bot，点击start即可获得TG ID。 配置EFB新建一个config.py文件保存机器人信息，输入以下内容:12345678910111213master_channel = 'plugins.eh_telegram_master', 'TelegramChannel'slave_channels = [('plugins.eh_wechat_slave', 'WeChatChannel')]eh_telegram_master = &#123; "token": "12345678:QWFPGJLUYarstdheioZXCVBKM", "admins": [13456782], "bing_speech_api": ["xxx", "xxx"], "baidu_speech_api": &#123; "app_id": 0, "api_key": "xxx", "secret_key": "xxx" &#125;&#125; 在其中输入之前所获得的token，以及将admin后的内容换成TG ID。其余xxx的内容是语音识别API，想要的可以申请，没有的也无所谓。然后新建一个tgdata.db文件，为空即可。 启动EFB容器指定配置文件和数据文件的地址，启动容器:1234docker run -d --restart=always --name=ehforwarderbot \ -v $(pwd)/config.py:/opt/ehForwarderBot/config.py \ -v $(pwd)/tgdata.db:/opt/ehForwarderBot/plugins/eh_telegram_master/tgdata.db \ royx/docker-efb 然后通过docker logs查看容器输出内容，应该可以看到一个二维码，用微信扫一扫即可登录。 机器人使用登陆成功即可正常使用机器人收发微信消息，默认情况下，所有的微信消息以及公众号消息，全都是通过那个机器人发送的，看起来会比较乱。如果需要单独跟某个人聊天，一种方法是在你创建的机器人中发送/chat 好友名，然后机器人会给一段消息，回复那个消息就可以将消息发送给指定的联系人。但是略显麻烦，聊天不多的人可以这样。另一种方法是单读创建一个TG群组，然后将名称命名为你要聊天的好友名，将机器人拉进来。然后向你所创建的机器人发送指令/link 好友名，将与该好友的聊天绑定到你所创建的群组中，即可如微信一般发送以及接收消息，且可以发送TG的自定义贴纸表情。 (后加)接管QQ消息此外，使用EFB工具也可以托管QQ消息，方法挺多，这里依然采用最简单的容器方法。和接管微信消息一样，需要创建一个机器人获取Token，也可以就用微信机器人，不过为了方便管理，就直接另外创建一个机器人了。然后直接使用EFB和酷Q的efb-qq-coolq-docker项目中的配置，仓库在这.然后修改两个配置文件: 12345vim ehforward_config/profiles/default/blueset.telegram/config.yamltoken: "你的机器人token"admins:- 你的tgid 和 1234vim docker-compose.yml- VNC_PASSWD=你的密码- COOLQ_ACCOUNT=你的qq账号 执行docker-compose up -d,然后打开ip:9801完成登录操作。但目前直接登录后，login可以成功，却无法获取到friends，借用blue-bird1的解决方法，修改bot容器中的配置： 123docker exec -it efb-qq-coolq-docker_bot_1 /bin/ashvi /usr/local/lib/python3.6/site-packages/efb_qq_slave/Clients/CoolQ/CoolQ.py 将第329行和第512行的调用赋值改为绝对赋值: 1res = &#123;"good": True, "online": True&#125; 然后重启容器即可。 1docker restart efb-qq-coolq-docker_bot_1 此时即可正常收发QQ消息。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Telegram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hashcat密码破解]]></title>
    <url>%2Fposts%2Fb0550b46%2F</url>
    <content type="text"><![CDATA[拿到了一个被加密的Excel，要求输入密码才能打开，于是尝试了下密码破解方法。 AROP破解AROP(ADVANCED OFFICEPASSWORD RECOVERY)好像是比较主流的Office的破解工具，有收费版和免费版，区别在于密码长度是否超过4字节。用了一个虚拟机跑了一下，字典查询没有，于是暴力破解，嗯，破解速度比较令人绝望，毕竟是CPU在跑。将该Excel文件解压之后，可以发现里面包含DataSpace、EncryptedPackage以及EncryptionInfo等文件，打开EncryptionInfo文件，可以看到里面加密的一些信息:12&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;encryption xmlns="http://schemas.microsoft.com/office/2006/encryption" xmlns:p="http://schemas.microsoft.com/office/2006/keyEncryptor/password" xmlns:c="http://schemas.microsoft.com/office/2006/keyEncryptor/certificate"&gt;&lt;keyData saltSize="16" blockSize="16" keyBits="256" hashSize="64" cipherAlgorithm="AES" cipherChaining="ChainingModeCBC" hashAlgorithm="SHA512" saltValue="tLnK9YHGccHAgMyj9Nuwmg=="/&gt;&lt;dataIntegrity encryptedHmacKey="wF7fTyyf/qhB8Vg+8fvQcspTyuR7cc2+yjIyuEAF0O8avnv0LxYhw+DaVmikzCbFDjLgFCAj6+C6m6iJdhuknA==" encryptedHmacValue="IK7Xc7/e0AVLERogsLvFl912xsbhw+oRKd/ABUwE5vw5iQtcAkM0K0rjz+gB8UlDDJlGbQx0HOKWypF3EDbqcA=="/&gt;&lt;keyEncryptors&gt;&lt;keyEncryptor uri="http://schemas.microsoft.com/office/2006/keyEncryptor/password"&gt;&lt;p:encryptedKey spinCount="100000" saltSize="16" blockSize="16" keyBits="256" hashSize="64" cipherAlgorithm="AES" cipherChaining="ChainingModeCBC" hashAlgorithm="SHA512" saltValue="wisEIaAFG08tJoh3tD0Bqw==" encryptedVerifierHashInput="ZMMqH6NC6xpnsH8zBXtfyA==" encryptedVerifierHashValue="mEcTV0662f/U1+nndKsBiv+L/CsAusbw+So+pA4g8TBKq70rNYy7nkZk+tYB6M/fFZdBfRH4363GRI4m8WPk6Q==" encryptedKeyValue="xUZ5hE+Tzhim5YcUf7KOA5Z1jAG+cTaOGRd859sCkPA="/&gt;&lt;/keyEncryptor&gt;&lt;/keyEncryptors&gt;&lt;/encryption&gt; 其中，采用的是AES算法，有盐(salt,指随机的数据，加入到哈希的过程中，加大破解难度)，hash算法是SHA512,spinCount=100000经过了100000次的迭代操作，想直接逆向破解，实在太难。字典尝试无效，只能暴力破解，但是随着密码长度增加，以及字母数字、特殊字符的引入，破解难度指数增长。对于纯小写字母的6位密码，复杂度为$26^6 = 308915776$次，七位则超过了80亿次，指望这个靠CPU计算的软件，实际希望不大，跑了半天后放弃了。 Hashcat破解 Hashcat号称世界上最快的密码破解，世界上第一个和唯一的基于GPGPU规则引擎，免费多GPU（高达128个GPU），多哈希，多操作系统（Linux和Windows本地二进制文件），多平台（OpenCL和CUDA支持），多算法，资源利用率低，基于字典攻击，支持分布式破解等等。 嗯，暴力破解的话，只能考虑使用GPU跑，这时，开源的hashcat就是一个不错的选择。 获取文件hash值使用hashcat破解office，先需要获取文件的hash值，网上有现成的工具office2join.py，然后用python运行，参数加上该office文件即可。123python office2john.py ../test.xlsx test.xlsx:$office$*2013*100000*256*16*c22b0421a0051b4f2d268877b43d01ab*64c32a1fa342eb1a67b07f33057b5fc8*984713574ebad9ffd4d7e9e774ab018aff8bfc2b00bac6f0f92a3ea40e20f130 可以看到，加密方式为office2013，将第一个冒号后面的字串复制到一个新文件中保存即可。 hashcat破解知道加密方式后，需要找到对应的破解模式，首先使用--help看一下帮助:1./hashcat64.bin --help 可以看到office的加密模式有以下几种:1234567899700 | MS Office &lt;= 2003 $0/$1, MD5 + RC4 | Documents9710 | MS Office &lt;= 2003 $0/$1, MD5 + RC4, collider #1 | Documents9720 | MS Office &lt;= 2003 $0/$1, MD5 + RC4, collider #2 | Documents9800 | MS Office &lt;= 2003 $3/$4, SHA1 + RC4 | Documents9810 | MS Office &lt;= 2003 $3, SHA1 + RC4, collider #1 | Documents9820 | MS Office &lt;= 2003 $3, SHA1 + RC4, collider #2 | Documents9400 | MS Office 2007 | Documents9500 | MS Office 2010 | Documents9600 | MS Office 2013 | Documents 所以，office2013选择-m 9600，然后开始破解：1./hashcat64.bin -a 3 -m 9600 --session test -o found.txt hash.txt ?l?l?l?l?l?l?l 其中，-a表示破解模式，3是暴力破解，--session test是将该次破解进程命名，可有可无，但之后如果要中断再恢复，则可以使用进程名恢复。-o found.txt是将找到的结果输出到指定文件中，hash.txt是之前保存hash码的文件，最后是一串正则表达式，有?l?u?d?s，分别表示小写字母、大写字母、数字、和特殊字符。该例子表示暴力破解七位小写字母的密码。 但由于不确定位数，先从简单的开始，破解从1到8位的小写字母：1./hashcat64.bin -a 3 -m 9600 -o found.txt hash.txt --increment --increment-min 1 --increment-max 8 ?l?l?l?l?l?l?l?l 其中，--increment-min 1 --increment-max 8即如本身含义。然后查看一下显卡运行情况：12345678910111213141516171819202122232425Tue Mar 12 14:57:13 2019+-----------------------------------------------------------------------------+| NVIDIA-SMI 410.78 Driver Version: 410.78 CUDA Version: 10.0 ||-------------------------------+----------------------+----------------------+| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC || Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. ||===============================+======================+======================|| 0 GeForce RTX 208... Off | 00000000:18:00.0 Off | N/A || 90% 80C P2 247W / 250W | 2341MiB / 10989MiB | 94% Default |+-------------------------------+----------------------+----------------------+| 1 GeForce RTX 208... Off | 00000000:3B:00.0 Off | N/A || 90% 80C P2 248W / 250W | 2341MiB / 10989MiB | 95% Default |+-------------------------------+----------------------+----------------------+| 2 GeForce RTX 208... Off | 00000000:86:00.0 Off | N/A || 91% 81C P2 247W / 250W | 2341MiB / 10989MiB | 95% Default |+-------------------------------+----------------------+----------------------++-----------------------------------------------------------------------------+| Processes: GPU Memory || GPU PID Type Process name Usage ||=============================================================================|| 0 1852 C ./hashcat64.bin 2331MiB || 1 1852 C ./hashcat64.bin 2331MiB || 2 1852 C ./hashcat64.bin 2331MiB |+-----------------------------------------------------------------------------+ 如果中途有事，可以先暂停一下，然后跑完后再过来继续破解：123456789101112131415161718192021222324252627282930./hashcat64.bin --restoreSession..........: testStatus...........: CrackedHash.Type........: MS Office 2013Hash.Target......: $office$*2013*100000*256*16*c22b0421a0051b4f2d26887...20f130Time.Started.....: Wed Mar 13 14:28:19 2019 (9 hours, 37 mins)Time.Estimated...: Thu Mar 14 00:05:48 2019 (0 secs)Guess.Mask.......: ?l?l?l?l?l?l?l [7]Guess.Queue......: 1/1 (100.00%)Speed.#1.........: 19777 H/s (8.49ms) @ Accel:64 Loops:16 Thr:256 Vec:1Speed.#2.........: 19260 H/s (8.66ms) @ Accel:64 Loops:16 Thr:256 Vec:1Speed.#3.........: 19438 H/s (8.60ms) @ Accel:64 Loops:16 Thr:256 Vec:1Speed.#*.........: 58475 H/sRecovered........: 1/1 (100.00%) Digests, 1/1 (100.00%) SaltsProgress.........: 2025455616/8031810176 (25.22%)Rejected.........: 0/2025455616 (0.00%)Restore.Point....: 74645504/308915776 (24.16%)Restore.Sub.#1...: Salt:0 Amplifier:17-18 Iteration:7520-7536Restore.Sub.#2...: Salt:0 Amplifier:0-1 Iteration:99984-100000Restore.Sub.#3...: Salt:0 Amplifier:6-7 Iteration:53776-53792Candidates.#1....: efmfogr -&gt; ehdazntCandidates.#2....: svtdyyl -&gt; srhqbksCandidates.#3....: lnkkjnt -&gt; ljnziblHardware.Mon.#1..: Temp: 77c Fan: 87% Util: 94% Core:1635MHz Mem:6800MHz Bus:16Hardware.Mon.#2..: Temp: 77c Fan: 87% Util: 93% Core:1695MHz Mem:6800MHz Bus:16Hardware.Mon.#3..: Temp: 77c Fan: 87% Util: 94% Core:1725MHz Mem:6800MHz Bus:16Started: Wed Mar 13 14:27:42 2019Stopped: Thu Mar 14 00:05:50 2019 最后大概半天吧，跑出来结果如下:1$office$*2013*100000*256*16*c22b0421a0051b4f2d268877b43d01ab*64c32a1fa342eb1a67b07f33057b5fc8*984713574ebad9ffd4d7e9e774ab018aff8bfc2b00bac6f0f92a3ea40e20f130:semicjj 冒号后面的就是密码。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
        <tag>Hashcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker博客环境封装及自动化部署]]></title>
    <url>%2Fposts%2F6b278ddb%2F</url>
    <content type="text"><![CDATA[说来惭愧，也不记得有几次立flag要把博客坚持下去的，看看上一篇的时间，一拖又是这么久了。为了不至于彻底沦落成上班摸鱼，下班看剧的MADAO（并非在说长谷川先生），还是想去舒适区外面逛逛。自动化部署并不是什么难事，记得以前网上就可以找到一堆TravisCI的教程。不过记得去年暑假时候使用Docker封装了博客环境，以便能在新系统上使用(Ubuntu 16.04 =&gt; 18.04)，同时也是为了防止博客插件以及npm的更新引起问题。 容器内构建环境关于Docker容器的储存结构以及基本介绍，之前貌似有一篇文章已经说了一些了，这里不再赘述。通过镜像构建容器很简单，docker run imagename即可，由于是博客，可以把本地的blog目录挂在进去，并映射里面的端口，即加上-v /Blog:/Blog 和-p 4000:4000，其他设置自己怎么喜欢怎么来。个人是直接从Docker Hub官方仓库中的ubuntu:16.04镜像来启动容器的，可以使用docker pull，也可以使用docker run命令来启动容器。然后是安装一些必要的软件：12345678apt update &amp;&amp; apt install -y vim git python wget gcc g++wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | shgit config --global user.email "ABCDEFG@qq.com" &amp;&amp; \git config --global user.name "username" &amp;&amp; \source ~/.profilenvm install v9.2.1 &amp;&amp; \npm install hexo-cli -g &amp;&amp; \npm install gulp -g 首先安装必要的环境，然后安装npm的包管理工具nvm，然后配置git账号，并安装特定版本的node，在安装之前先确认之前可以运行的时候的node版本即可。剩下的就是安装hexo和gulp（博客资源压缩工具，优化用）。为了hexo能够直接deploy，配置免密登录密钥并添加到github中。1ssh-keygen -t rsa -P "" 拷贝/root/.ssh/id_rsa.pub文件中内容到github的SSH-KEY中即可。然后删掉博客中的node_modules/文件夹和db.json文件，重新安装。1npm install 之后便可以正常在本地访问博客了。 构建镜像容器直接构建在之前环境配置好之后，退出容器，将该容器打包成镜像。1docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 可加参数有-a authorname 添加作者信息，-m message添加说明文字，如:1docker commit -a "Lilei &amp;&amp; Hanmeimei" -m "blog image" CONTAINER_ID REPOSITORY:TAG 后面添加容器ID或者容器名都可以，然后添加你要上传到DockerHub的仓库名以及版本标签(TAG如果为空，默认为latest) 通过Dockerfile构建将之前的指令写入Dockerfile文件，然后建立镜像即可。 123456789101112FROM ubuntu:16.04MAINTAINER giteverRUN apt update &amp;&amp; apt install -y vim git python wget gcc g++ make &amp;&amp; \ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh ENV NVM_DIR /root/.nvmCOPY ssh /root/.sshRUN git config --global user.email "ABCDEFG@qq.com" &amp;&amp; \ git config --global user.name "username" &amp;&amp; \ . $NVM_DIR/nvm.sh &amp;&amp; \ nvm install v9.2.1 &amp;&amp; \ npm install hexo-cli -g &amp;&amp; \ npm install gulp -g 其中MAINTAINER是作者名字，FROM是使用的镜像来源，然后安装环境，和之前一样。最后使用Docker build命令构建镜像。需要说一点的是，通过Dockerfile构建的镜像不能直接使用ssh-keygen命令生成免密密钥，因为每次构建镜像时都会执行一次生成指令，如果之后版本需要修改，Dockerfile中需要加入其他指令，那么原来可以免密的镜像，生成后会变的无法登陆。最明显的就是使用ssh的方式的hexo deploy和github 仓库的访问，故而将已经可以免密的.ssh/文件夹直接拷贝进来。 1docker build -t gitever/blog:ci . 使用-t指令是指定之后要上传到Docker Hub的镜像仓库名。然后等待一会，会显示构建完成，使用docker images便可以查看之前直接在容器中构建的镜像和使用Dockerfile构建的镜像。通常使用Dockerfile构建镜像体积会更小，因为Docker的分层存储方式，由于在容器内通常会做很多多余的无用指令，所以直接commit构建的体积很容易变得臃肿。之后就是上传镜像： 1docker push gitever/blog:ci Docker自动化部署其实在镜像制作完成后，即可以使用镜像启动容器，然后使用博客环境了。上传镜像之后，可以在不同电脑上使用该博客环境，也不会有环境冲突的问题。但是每次都要挂载本地目录到容器中(因为博客目录体积较大，直接放入容器中体积太大，而且博客会更新，容器不能保存，只能重新制作镜像，使得效率低下)。也许是觉得在不同电脑上都要下载镜像启动容器显得麻烦，或者觉得每次都要手动generate、push和deploy显得麻烦，便开始打算使用Docker自动化部署。首先去DockerHub创建一个仓库用来自动化部署，仓库创建需要绑定github账号，然后将博客的源文件仓库链接至该镜像仓库，如下图所示。 不过也不一定要链接至博客源文件仓库，可以新建一个仓库，将Dockerfile上传至该仓库，每次push该仓库触发博客自动更新也可以。直接使用博客源文件仓库则是每次写好文章push上去便直接触发更新了。然后在本地的博客源文件（或新仓库）添加一个Dockerfile记录要自动更新的指令。 12345678910FROM gitever/blog:ciMAINTAINER giteverADD .git/ /.git/RUN git clone YourRepoUrl /Blog &amp;&amp;\ . $NVM_DIR/nvm.sh &amp;&amp; \ cd /Blog &amp;&amp; \ npm install &amp;&amp; \ hexo cle &amp;&amp; \ gulp &amp;&amp; \ hexo d 然后git add .以及使用commit和push上传至git仓库即可触发。其中，ADD一个变化的值，保证之后的构建不使用缓存，不然即使仓库更新了，容器里的仓库也不会更新。其实不用每次git clone，git的优点就是差异性存储，所以可以之前依然可以使用缓存，节省时间，将后续操作设置成不使用缓存。 123456789101112FROM gitever/blog:ciMAINTAINER giteverRUN git clone YourRepoUrl /Blog &amp;&amp;\ . $NVM_DIR/nvm.sh &amp;&amp; \ npm install &amp;&amp; \ADD .git/ /.git/RUN cd /Blog &amp;&amp; \ . $NVM_DIR/nvm.sh &amp;&amp; \ git pull &amp;&amp; \ hexo cle &amp;&amp; \ gulp &amp;&amp; \ hexo d 另一种方式，直接将当前仓库中的文件添加到容器中: 12345678910111213141516171819FROM gitever/blog:ciMAINTAINER giteverRUN mkdir /Blog COPY _config.yml /BlogCOPY package* /Blog/COPY gulpfile.js /BlogCOPY scaffolds/ /Blog/scaffoldsRUN cd /Blog &amp;&amp; \ . $NVM_DIR/nvm.sh &amp;&amp; \ npm install ADD themes/ /Blog/themesADD source/ /Blog/sourceADD .git/ /Blog/.git/RUN cd /Blog &amp;&amp; \ . $NVM_DIR/nvm.sh &amp;&amp; \ git pull &amp;&amp; \ hexo cle &amp;&amp; \ gulp &amp;&amp; \ hexo d 这种方式，每次修改文件后都将整个文件夹添加到容器中，文件夹比较大的话会花比较多的时间。另一方面，因为Docker层层有缓存，所以第一种方式也只有第一次较慢。最后观察触发是否成功以及最后输出结果是否在预期内。上述涉及到ADD和COPY区别，COPY只是简单的复制，ADD支持下载URL，并支持解压，并具有判断其ADD的src功能。因此，在没有特殊需求时，尽量使用COPY提高效率，上述使用ADD .git/是为了让Docker Daemon判断git仓库是否更新了，如果更新了，则不使用缓存，这样，后续的git pull才能真正获取更新并最终更新到网站上。 此外，还可以添加.dockerignore文件来忽略一些容器中你不用的文件以提高速度。容器加载时会默认将当前目录下所有文件打包传给Docker Daemon，比如就是node_modules文件夹。没有写的太细，长篇累牍容易给看客压力，step by step操作一番，不填坑也不会有印象，也并不会达到对容器熟悉的效果。因为容器的方便性，我曾不断向人安利，但也许是推荐的对象不适合，用的人貌似不多，记得以前也答应过人把Docker封装环境的详细过程写写，现在算是应诺了，希望还能帮人节省一点时间。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小聊乐理]]></title>
    <url>%2Fposts%2Fd48d9dba%2F</url>
    <content type="text"><![CDATA[很久啦，不止一个人说我写的太无聊，确实我又不是什么有趣的主儿。孤芳自赏，历来惯了。不过生活多点味道也挺好，技术博客里也不需要太多技术，毕竟技术应该寄生在人身上，而不是博客里。——今天偶尔尝试一下别的内容了。 不知道有没有人对音乐感兴趣，然而不为盈利，也非是为了悦人而作，也只是突然想写，写便罢。 节拍拍子是音乐里最基础的节奏单位，经常听到的电音里面的那些”咚-咚-咚–”就是一拍一拍的。一定数量的拍可以构成节，如传统的 $\frac{4}{4}$ 下面的4表示4分音符为一拍，上面的4表示一小节拍4下。另外，拍子的速度则是每分钟拍多少下，即beats per minute(bpm)。时值则是音符持续时间长短，比如2分拍的时值就是4分拍的2倍。 琴键钢琴一共88键，其实结构很简单，如果从数学的角度考虑，其实也都很容易记住。我画了一下：恩，画得好累～虽然花了点时间，但实际上手绘就比较快了，钢琴一共88个键，左音低，右音高。其中，最右边的是小字5组C,即($C^5$)，最左边的则是大字2组A，即($A^2$)。中间从小字组往左分别是大字组和大字一组，往右是小字一组到小字五组。每组为CDEFGAB七个白健，键盘中相邻两个键相差为半音，如B和C之间相差即为半音，而C和D之间，由于中间存在一个黑键，因此相差为一个全音。黑键没有独立的名字，分别根据相邻的白健命名，如C和D之间的黑键称为C#或者D♭,其中sharp(#)表示升调，♭符号表示降调。 中央C关于中央C，即最中间组的C，图中从大字二组到小字五组一共有九个组，中央组就是第五组了，也就是小字一组C，有的也称之为$C^5$。 音程音程，即两个音之间的高低关系，可以理解为两个音之间的距离。与两个音之间的半音数有关。半音数和音程之间的关系，如下表所示： 半音数 0 1 2 3 4 5 6 7 8 9 10 11 12 音程 纯一度 小二度 大二度 小三度 大三度 纯四度 增四/减五度 纯五度 小六度 大六度 小七度 大七度 纯八度 嗯，可以简要从数学方面分析一下。为此，我再画两个组,从C到A，重复两次： 虽然说规律一致，我还是一个一个分析吧： 图中最远的距离是从C回到C，即CDEFGABC，看做数列的话，项数为8，因此最高度数是8。由于钢琴这8度一组，七个白键五个黑键，不断循环。不管怎样，8度必然是这么多白健和黑键，半音数就是$7+5=12$。之所以叫纯八度，是为了和大小增减音程区分开来。非纯音程的原因通常是黑键位置导致的实际值不等于整度数。 同时按两次相同位置的C，他们之间的半音数为0，项数为1，只有一度，也不存在由于黑键导致的大于或者等于1的度数，因此是纯一度。 再看从C到D，度数为2，但是中间有一个黑键，因此半音数相差为1+1=2，此时称之为大二度。物理上，两个白键之间最多有一个黑键。因此半音数相差为1或者2，为了区分这两种情况，同样是2度音程，有黑键情况，半音数较多称之为大二度，无黑键情况称之为小二度。 度数为3的情况，如从C到E，中间有两个黑键，半音数为$2+2=4$，而物理上，度数为3的情况也有两种，一种是中间有一个黑键，一种是中间有两个黑键，这就导致了实际半音数会相差1。同样的方法，以大小度数来记，三个白键之间最多有两个黑键，此时称之为大三度；最少有一个黑键，此时称之为小三度。 度数为4的情况，如从C到F，中间有两个黑键，此时半音数为3+2=5。其实通常情况下四个白键之间都有两个黑键。只有一种情况，就是从F到B，中间有三个黑键，此时半音数为6。因此，当半音数为5，即通常情况下，半音数为5，度数为4的称之为纯四度。半音数为6，度数为4的称之为增四度。 度数为5的情况，与度数为4的情况类似。如从C到G，中间通常都有三个黑键，半音数为4+3=7。称之为纯五度。只有一种情况，即，从D到G，中间只有两个黑键，半音数为6，但由于度数为6，所以此时称之为减五度。 度数为6的情况，与度数为3的情况类似。如从C到A，中间有4个黑键，半音数为5+4=9。而度数为6的情况，白键之间的黑键数量也有两种，如从E到C，中间有三个黑键，半音数为8。同样的记法，半音数8，度数为6的称之为小六度；半音数9，度数为6的称之为大六度。 最后看度数为7的情况，如从C到A。也是类似，七个白键之间的黑键可能为4或者5，因此半音数可能为10或者11。半音数为10，度数为7的称之为小七度；半音数为11，度数为7的称之为大七度。 表中，增四度和减五度之间的距离都是6个半音，即三个全音，因此增四度减五度都成为三全音。 音程转位音程转位就是从一个组的调转到下一个组的该调。如CDE转位后为EFGABC。从数列方面看，也有一些规律。因为七个白键一组，所以从一个音会到下个组的本音，之间项数为8，距离为7。但转位之后，如从C-E与E-C，中E出现两次，所以最后一共有9个度数。故转位之后度数之和为9。而这一组白键中，黑键数量永远为5，因此转位之后，音程互补。对于大音程，转为之后成为小音程。增音程，转位之后成为减音程。 协和音程主观感受吧，大致是觉得听起来比较协调，就觉得是协和音程。主要分为4类： 完全协和音程 纯一度、纯八度 协和音程 纯四度、纯五度 不完全协和音程 大/小三度、大/小六度 不协和音程 大/小二度、大/小七度、增四度、减五度 调音调，记得初中物理里解释为声音频率的高低，其实大致也是这种感觉吧。直观的感觉是高音轻短细，低音中长粗。图中琴键每七个音阶一组，即CDEFGAB，调有大小之分。 大调以一个C大调为例，如表所示： C大调 C D E F G A B C 距离 全音 全音 半音 全音 全音 全音 全音 半音 选取任意一组琴键，图中可以看到，一个大调包含了七个白健，五个黑键，除了中间的EF两个白健之间没有黑键，其余的从C开始到B，中间都有黑键。因此除了EF之间是相差半音，其余都是相差全音。另外，由于一组七个循环都是从白健开始，首位白健之间也是没有黑键的，因此如果从C回到C，最后B和C之间也是相差半音。大调特征即是如此，即三和七为半音，其余为全音，所谓的“全全半全全全半”。以此方式，则D大调为： D大调 D E F# G A B C# D 距离 全音 全音 半音 全音 全音 全音 全音 半音 表中F和C处为了保持半音和全音的距离，因此写作了F#和C#。虽然F#和G♭是一样的，但在这里，为了保持相邻两音度数为2，因此只能写作F#。如果写作G♭，则G♭和G之间只有一度音，少了F调，无法成为全音。C#的原因也是一样。（主要是写法不同）另外，有个关于升号调和降号调的一个表格： 升号调 G D A E B F# C# 降号调 F B♭ E♭ A♭ D♭ G♭ C♭ 以此方式，可以看一下F大调： F大调 F G A B♭ C D E F 距离 全音 全音 半音 全音 全音 全音 全音 半音 以上述方式理解或者直接查升号调降号调表格，中可以看到，F属于降号调表示。 稳定音各音之间，稳定性是有差异的，最稳定的音为主音，如C大调主音为C，各音的稳定性如下： 最稳定 1 5 3 6 2 4 7 最不稳定 稳定音 稳定音 稳定音 不稳定音 不稳定音 不稳定音 不稳定音 而各音会有倾向性，即不稳定的音听起来会倾向于进行到稳定音上。其中2级倾向于进行到1级，4级倾向于进行到3级，6级倾向于进行到5级，7级倾向于进行到1级。 和弦和弦是一些音的结合，先看几个基本的三度叠置和弦: 大三和弦： 如从C-E-G，C和E之间存在两个黑键，三度白键之间最多也就两个黑键，因此CE之间是大三度。E和G之间有一个黑键，故EG是小三度。这种大三度+小三度的和弦称之为大三和弦，称之为$Cmaj$，简写为C。其中，C称之为根音，E和G相对于根音分别是3和5度（算上根音本身），因此称之为三音和五音。 小三和弦： 与大三和弦相对。如从D-F-A,D和F之间是小三度，F和A之间是大三度，DFA则被成为小三和弦。记作$Cminor$，简写为Dm。即小三度+大三度。 减三和弦： 如从B-D-F，是小三度+小三度，称之为减三和弦，记作Bdim，简写为$B^。$。 从琴键结构可以看出，只算白键的话，两个大三度不可能连续在一起，即大三度+大三度，通常采用黑键表示，即所谓的增三和弦（增三和弦属于极不协和的和弦）。 大七和弦(大大七和弦)： 如从C-E-G-B，即大三度+小三度+大三度，此时称之为大七和弦，或称为大大七和弦。简写为CM7。 属七和弦：如GBDF，大三和弦+小七度，即大三度+小三度+小三度。写作Gdom7，简写为G7。 小大七和弦：如EGBD#，小三和弦+大七度，即小三度+大三度+大三度。记作${Emin}^{Maj7}$，间协作${Em}^{M7}$。 和弦转位将三音或者五音、七音放在最下面时(即作为低音)，构成和弦转位。如CEG和弦： 和弦转位 CEG EGC GCE 位置 原位 第一转位 第二转位 记法 C C/E C/G 同样的，如大七和弦： 和弦转位 CEGB EGBC GBCE BCGE 位置 原位 第一转位 第二转位 第三转位 记法 CM7 CM7/E CM7/G CM7/B 五度循环圈看这名字，可以大致想一下，一组键包括7个白键，5个黑键，加起来是12个键，如果要五度循环，那么最小公倍数为60，因此应该是12组，从C开始算，最后才能回到C，完成一个循环。纯五度协和程度仅次于纯一度和纯八度。五度循环圈如图所示： 图中字母可以看做和弦根音，也可以看作单个的音，也可以看作调式主音。如从C大调的所有纯五度音程为：C-G,G-D,D-A,A-E,E-B,F-C。与五度循环圈中位置一致。外圈和内圈作等音转换，如C#等于D♭，圈里有三个半音。通过五度循环圈，可以很容易的写出和弦音。 调式音级调式七个音级使用罗马数字表示，每个调式和音级关系如下表： C D E F G A B C I II III IV V VI VII I 主 上主 中 下属 属 下中 导 主 主要可以由琴键理解。C上方是D，因此D称之为上主音。C下方是B，称为导音。然后主音上方纯五度，即G处是属音。C下方纯五度为下属音，即F处。主音和属音中间的音称为中音，即E处。主音和下属音中间的称为下中音，即A处。 小调自然小调通常大调与小调区别，再直观感受上是，大调比较欢快、明朗，小调忧郁、悲伤。再音阶结构上区别如下: C大调 C D E F G A B C c小调 C D E♭ F G A♭ B♭ C I II III IV V VI VII I 全 半 全 全 半 全 全 如表中所示，大调和小调的区别在III级音和VI、VII级处，其中最主要的区别在于三级音，也成为调式特性音。主音相同，三级音的特性是使小调悲伤的主要原因。此外，音阶结构相对于大调的“全全半全全全半”，为“全半全全半全全”。 关系大小调比较一下C大调和a小调： C大调 C D E F G A B a小调 A B C D E F G a小调再琴键上全是白健，构成音和C大调一样，只是主音不同。此时这两者称之为关系大小调：a小调是C大调的关系小调，C大调是a小调的关系大调。通常构成音相同的大小调称为关系大小调，大调六级音为小调主音，小调三级音为大调主音。还是用数学方法证明一下： 小调音阶 全 半 全 全 半 全 全 大调音阶 全 全 半 全 全 全 半 将大小调音阶对比，可以看出，在平移两度之后，小调音阶与大调音阶一致。从表中可以得到，大调的关系小调在其下方小三度处（相差2度）。小调调号使用关系大调调号。画在五度循环圈里如下: 自然音程和变化音程自然音程：大调（或者自然小调）中，任何两个音构成的音程都属于自然音程。之前所分析的音程均为自然音程，共四大类，14种。 自然音程 纯音程 纯一度 纯四度 纯五度 纯八度 大音程 大二度 大三度 大六度 大七度 小音程 小二度 小三度 小六度 小七度 三全音 增四度 减五度 除了自然音程之外的，都属于变化音程，也有四类： 增音程（除增四度） 减音程（除减五度） 倍增音程 倍减音程 具体关系可由图表示： 图中可以看出，纯音程和大音程，在度数不变情况下，增加一个半音可得到增音程，再增加一个半音，可以得到倍增音程。如下表所示： F-G 大二度 F-G# 增二度 F-Gx 倍增二度 减音程和倍减音程类似：对于纯音程和小音程，在度数不变情况下，减少一个半音可以得到减音程，在减少一个半音可以得到倍减音程。 G#-A 小二度 G#-A♭ 减二度 G#-A♭♭ 倍减二度 纯音程可以变为增音程、倍增音程和减音程、倍减音程。但由于纯一度的半音数为0，所以纯一度没有减音程和倍减音程。 小调变体小调与大调区别主要在于音阶，自然小调变体有和声小调和旋律小调。 I II III IV V VI VII I a自然小调 A B C D E F G A a和声小调 A B C D E F G# A a旋律小调 A B C D E F# G# A 大调与小调之间的关系: I II III IV V VI VII I C大调 C D E F G A B C c自然小调 C D E♭ F G A♭ B♭ C c和声小调 C D E♭ F G A♭ B C c旋律小调 C D E♭ F G A B C 从表中可以看出，大调与同主音的主要区别在三级音，将大调三级音降半音，可以得到旋律小调，再将六级音降半音可以得到和声小调，再将七级音降半音就可以得到自然小调了。]]></content>
      <categories>
        <category>乐理</category>
      </categories>
      <tags>
        <tag>乐理</tag>
        <tag>和弦</tag>
        <tag>音律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LXD搭设服务器]]></title>
    <url>%2Fposts%2F325daa6a%2F</url>
    <content type="text"><![CDATA[主要是想搭设几台服务器，希望用户环境能隔离，相互安装和配置环境不影响，也希望不至于发生有了sudo权限就把别人的都删了的情况。同时也希望所有用户都能使用服务器上的硬件设备如GPU，且都能上网。如果采用虚拟机技术，则硬件只能独占，不能共享，且开销大，另外一旦确定了所需分配的资源就成了固定开销，无论虚拟机中资源利用率如何。而另一方面，容器技术的特点则是资源共享，基本不占用硬件资源，所以考虑使用容器技术来实现用户环境隔离。目前最流行的容器技术还是Docker，但Docker更适合于单个应用环境的部署，对于用户来说，希望在相互隔离时候也能用到服务器资源，更希望是一个虚拟机，而不是一个应用环境。目前Linux上主要有LXC和LXD，Docker以前就是用的LXC的Runtime，而LXD也只是一个提供了REST API的LXC容器管理器而已，其仓库地址在此。因此打算使用LXD来搭建这个服务器。 初始化首先是下载LXD容器，如果是Ubuntu16.04里的apt软件仓库，最高应该是2.x的版本，如果要支持LXD容器内GPU的数据处理，至少版本为3.0.好在从16.04时候引进了另一个软件包管理工具，之前一篇文章有所介绍，即使用snap软件包管理工具。查看版本：1234567$ ▶ snap find lxdName Version Publisher Notes Summarylxd-demo-server 0+git.f3532e3 stgraber - Online software demo sessions using LXDlxd 3.6 canonical✓ - System container manager and APInova ocata james-page - OpenStack Compute Service (nova)satellite 0.1.2 alanzanattadev - Advanced scalable Open source intelligence platformnova-hypervisor ocata james-page - OpenStack Compute Service - KVM Hypervisor (nova) 可以看到已经到3.6了，直接下载就行snap install lxd。安装好后应该就可以直接使用了,第一部是初始化LXD的环境，使用lxd init。如果出现permission denied之类的问题，可以加sudo，嫌麻烦可以将当前用户加入LXD组内：1sudo usermod add -aG lxd $&#123;USER&#125; 然后注销重新登录就行了。在初始化之前，需要安装几个工具，一个是ZFS，是LXD默认的后端存储工具，另一个是Bridge管理工具，LXD自身也带网桥创建功能，默认创建网桥会自动创建局域网私有地址并分配DHCP地址至虚拟网卡。1sudo apt install zfsutils-linux bridge-utils 初始化过程如下：1lxd init 所有提示注意一下是否创建网桥时候选择no就行，其余基本可以使用默认配置。如果不用管外网远程登录，可以直接全选默认。然后拉取一个镜像，如：1lxc launch ubuntu:16.04 test 拉取成功启动了就可以使用lxc list看到容器了。使用lxc exec test -- ${command}命令在容器内执行命令。如:1lxc exec test bash 这时可以进入容器内的bash。然后通过配置好第一个容器，将其作为模板，制作出多个虚拟主机。 显卡配置在此之前，需要宿主机上安装显卡驱动和CUDA，具体过程不做赘述。先关闭容器lxc stop test，然后将显卡设备添加到容器中：1lxc config device add test gpu gpu 该命令是添加所有显卡，也可以手动指定显卡id。然后启动容器，安装显卡驱动：12lxc exec test bashapt update 可以直接参考宿主机的显卡驱动，查看一下宿主机显卡驱动版本，可以使用nvidia-smi或者sudo dpkg -l |grep nvidia查看，然后回到容器，使用apt install nvidia-XXX-dev安装。如果安装成功，即可以使用nvidia命令查看显卡。123456789101112131415161718192021222324nvidia-smi+-----------------------------------------------------------------------------+| NVIDIA-SMI 390.30 Driver Version: 390.30 ||-------------------------------+----------------------+----------------------+| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC || Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. ||===============================+======================+======================|| 0 Quadro P4000 Off | 00000000:02:00.0 Off | N/A || 46% 37C P0 28W / 105W | 0MiB / 8118MiB | 0% Default |+-------------------------------+----------------------+----------------------+| 1 Quadro P4000 Off | 00000000:03:00.0 Off | N/A || 46% 40C P0 28W / 105W | 0MiB / 8119MiB | 0% Default |+-------------------------------+----------------------+----------------------+| 2 Quadro P4000 Off | 00000000:82:00.0 Off | N/A || 46% 40C P0 28W / 105W | 0MiB / 8119MiB | 0% Default |+-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+| Processes: GPU Memory || GPU PID Type Process name Usage ||=============================================================================|| No running processes found |+-----------------------------------------------------------------------------+ CUDA版本和TensorFlow版本由用户自己选择，默认不安装。 网络配置这个是最麻烦的，如果需要访问外网的话。目前个人方法如下： lxc创建网桥先使用lxc创建一个网桥，网桥地址应该与本地电脑在一个网段，这样桥接后本地其他电脑才可以远程访问该容器。假如本地各电脑IP为192.168.1.xxx，则：1lxc network create lxd0 ipv4.address=192.168.1.10/24 其他可使用默认配置，具体各项参数见官方说明。然后使用bridge管理工具将网桥连接至本地网卡，假如本地网卡为enp1s0，则：1sudo brctl addif lxd0 enp1s0 添加之后可以使用brctl show命令查看。 宿主机路由这时可能出现宿主机无法上网的问题，原因是访问网络时，数据包都默认转发到新建网桥地址，而不是默认网关地址，所以需要添加一条路由表：1sudo route add default gw 192.168.1.1 可以解决本地宿主机上网问题。 重新初始化关闭容器后再次使用lxd init初始化容器环境，主要是为容器选择默认网桥，这时只用修改一项配置Would you like to configure LXD to use an existing bridge or host interface? (yes/no) [default=no]，改为yes，然后输入新建网桥名lxd0即可。 分配静态地址然后重新启动容器并进入bash，修改网络配置文件：1vim /etc/network/interfaces 添加12345auto eth0iface eth0 inet staticaddress 192.168.1.11gateway 192.168.1.1netmask 255.255.255.0 重启网络服务1/etc/init.d/networking restart 如果IP还不变，那就重启宿主机。 修改DNS通常到上一步已经可以上网了，默认域名解析服务地址是网桥地址，你也可以改为自定义的DNS地址，如114.114.114.114。最通常的方法是修改/etc/resolv.conf文件中的nameserver。但重启后会失效。以下是永久修改DNS的方法，通常在搭建过程中不需要用到。 修改Resolvconf配置修改/etc/resolvconf/resolv.conf.d目录下的base，在里面修改DNS服务器地址即可。 修改DHCP配置另一个方法是修改DHCP配置文件，1vim /etc/dhcp/dhclient.conf 可以看到，12#supersede domain-name "fugue.com home.vix.com"; #prepend domain-name-servers 127.0.0.1; 去掉前面的#，将域名服务器改成自己的就可以了。 ssh配置如果希望用户能远程访问容器，除了网络配置之外，还需要修改一下ssh配置。默认禁止root用户登录，容器创建默认用户也是root用户，里面有个ubuntu用户，未初始化。既然虚拟主机交给用户，即把root也给用户了，所以先设置允许root用户登录，如不需要可以让用户自行更改。1vim /etc/ssh/sshd_config 将其中的PermitRootLogin prohibit-password改为PermitRootLogin yes，以及ChallengeResponseAuthentication no改为ChallengeResponseAuthentication yes。然后为root用户设置密码：1passwd root 另外可以编辑ssh登录用户的欢迎信息，通过编辑/etc/update-motd.d/目录下的00-header和01-hepler-text中的内容即可完成。最后，重启ssh服务，1/etc/init.d/ssh restart 挂载共享目录最后需要在主机上创建一个文件夹，用于各个容器与主机共享，文件传输之类，虽然主机lxc已经有pull和push方法从主机和容器之间拷贝文件，但共享目录会显得更为方便，即便在容器之间也可以相互访问。1lxc config device add mycontainer sharedtmp disk path=/tmp/share_on_lxc source=/tmp/share_on_host 其中，path和source的地址可以自己定义。到这里，基本结束。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>LXD</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Time Machine]]></title>
    <url>%2Fposts%2Fa0c49a8e%2F</url>
    <content type="text"><![CDATA[Docker是个好东西，或者说容器是个好东西。毕竟回忆里的昨天,我再也回不去。但容器可以。 Docker存储方式还是先说一下Docker容器的储存结构，容器镜像采用的是分层存储的方式，下面是一个Ubuntu16.04的镜像结构。 也可以在命令行观察，在拉取的时候也可以看到结果：123456789$ ▶ docker pull ubuntu:16.0416.04: Pulling from library/ubuntu3b37166ec614: Already exists504facff238f: Already existsebbcacd28e10: Already existsc7fb3351ecad: Already exists2e3debadcbf7: Already existsDigest: sha256:45ddfa61744947b0b8f7f20b8de70cbcdd441a6a0532f791fd4c09f5e491a8ebStatus: Downloaded newer image for ubuntu:16.04 其中，每层表示的是与上一层的差异，而不是直接操作底层镜像，这样，当使用其他基于此镜像制作的镜像时，就不必整个拉取或者复制过来，因为它们很多的底层镜像是一样的。Docker镜像采用的是共享存储方式，当拉取一个镜像时，会首先获取所有层的信息，如果该镜像层本地已经有了，就不用下载，只需要下载所需要的镜像层。 在使用镜像建立容器时候，会在最上面一层镜像上建立一个可写层，即容器层。当在容器中所有的操作都会被保存在这个可写层，如果直接删除容器，则可写层就会被删除，即使利用相同镜像重新建立容器，之前的所有操作也不会被保存。镜像层都是只读的，基于此安全性，所有的容器都可以访问底层镜像，所以一次可以利用同一镜像建立多个容器。最后完成修改封装成新的容器的时候，也只是在原来的镜像层之上又加了一层而已。镜像的这种共享存储方式可以极大地提高资源利用效率，而差异存储也是文件管理的主流之选。 说到这个，想起来目前有个PWD(Play with Docker)的网站，可以直接在里面体验docker，地址在这。进去就可以创建一个Docker playground。 利用Docker运行CUDA和TensorFlow在电脑上配置CUDA或者TensorFlow啥的，经常因为各种版本不同导致一大堆问题，于是就想看看可不可以利用Docker去解决这个问题，每次直接打开封装好的镜像就行了，让Docker里的环境去使用GPU，不用去配环境，也不用在电脑上装啥别的软件。然后发现NVIDIA也在Docker上稍微封装了一下，弄了个Nvidia-docker命令，基本命令与docker命令一样，唯一的区别是普通的Docker无法使用GPU，所以Nvidia-docker等效于命令docker --runtime=nvidia。 要使用GPU，首先也要安装好显卡驱动，怎么安装这里不做赘述，通常安装成功是可以看到的。 当然，Docker肯定要先装好。 Nvidia Docker然后就是安装Nvidia封装的Docker来调用GPU了，具体可以参照NVIDIA/nvidia-docker页面。 如果之前有安装1.0版本的Nvidia-docker的，需要先卸载： 123# If you have nvidia-docker 1.0 installed: we need to remove it and all existing GPU containersdocker volume ls -q -f driver=nvidia-docker | xargs -r -I&#123;&#125; -n1 docker ps -q -a -f volume=&#123;&#125; | xargs -r docker rm -fsudo apt-get purge -y nvidia-docker 没有的话可以直接略过。然后添加仓库地址重定向到镜像源文件中，再更新软件源。 1234567# Add the package repositoriescurl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \ sudo apt-key add - distribution=$(. /etc/os-release;echo $ID$VERSION_ID) curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \ sudo tee /etc/apt/sources.list.d/nvidia-docker.list sudo apt-get update 然后直接安装即可。123# Install nvidia-docker2 and reload the Docker daemon configurationsudo apt-get install -y nvidia-docker2sudo pkill -SIGHUP dockerd CUDA测试首先运行一个cuda的镜像，进入bash中，123docker run --runtime=nvidia -it --name cuda --rm nvidia/cuda:9.0-base /bin/bashroot@c1d523d61051:/#root@c1d523d61051:/# 这里将容器命名为cuda方便操作，需要选择runtime为nvidia，或者直接使用nvidia-docker命令。然后输入nvidia-smi就可以看到是否成功调用显卡了。1234567891011121314151617root@c1d523d61051:/# nvidia-smi Thu Oct 11 07:51:19 2018 +-----------------------------------------------------------------------------+| NVIDIA-SMI 384.130 Driver Version: 384.130 ||-------------------------------+----------------------+----------------------+| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC || Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. ||===============================+======================+======================|| 0 GeForce GTX 1080 Off | 00000000:01:00.0 On | N/A || 0% 44C P8 14W / 200W | 867MiB / 8110MiB | 0% Default |+-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+| Processes: GPU Memory || GPU PID Type Process name Usage ||=============================================================================|+-----------------------------------------------------------------------------+ TensorFlow测试刚刚也说了，如果要使用GPU，需要在docker命令中加上–runtime=nvidia或者直接使用nvidia-docker命令。这里就直接使用nvidia-docker命令了，12 $ ▶ nvidia-docker run -it -d --name tensor -p 8888:8888 tensorflow/tensorflow 9c7db93b36788acf61a20f52cb187f32e0d6018f7e8da031a30fa135252a4896 查看容器内信息，1234567891011docker logs tensor[I 08:01:55.452 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret [I 08:01:55.465 NotebookApp] Serving notebooks from local directory: /notebooks[I 08:01:55.465 NotebookApp] The Jupyter Notebook is running at:[I 08:01:55.465 NotebookApp] http://(9c7db93b3678 or 127.0.0.1):8888/?token=64e73aaba8febd5539fae22201c7b7cea1b8578cc1413850[I 08:01:55.465 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).[C 08:01:55.466 NotebookApp]Copy/paste this URL into your browser when you connect for the first time,to login with a token:http://(9c7db93b3678 or 127.0.0.1):8888/?token=64e73aaba8febd5539fae22201c7b7cea1b8578cc1413850 打开浏览器窗口，输入localhost:8888/?token=64e73aaba8febd5539fae22201c7b7cea1b8578cc1413850，可以看到一个Jupyter的界面。 在里面可以编辑及运行python程序，或者使用终端操作： 12345678910$ ▶ docker exec -it tensor /bin/bashroot@9c7db93b3678:/notebooks# ls1_hello_tensorflow.ipynb 2_getting_started.ipynb 3_mnist_from_scratch.ipynb BUILD LICENSEroot@9c7db93b3678:/notebooks# pythonpython python2 python2.7 python3 python3.5mpython-config python2-config python2.7-config python3.5 python3mroot@9c7db93b3678:/notebooks# pythonPython 2.7.12 (default, Dec 4 2017, 14:50:18)[GCC 5.4.0 20160609] on linux2Type "help", "copyright", "credits" or "license" for more information. 关于Docker的Runtime一个容器运行需要制定规范、Runtime、管理和定义工具、镜像仓库、运行OS等环节。容器的Runtime是容器运行时的一些规范，主要任务是和操作系统的kernel协作来提供容器的运行环境，由OCI（Open Container Initiative,由Google，Docker、CoreOS、IBM、微软、红帽等于2015年联合发起的组织）维护。主要包括容器的文件系统包(Filesystem Bundle)，容器的运行和生存周期Runtime and Lifecycle)，容器配置文件(Container Configuration file)，以及Linux的运行和配置文件(Linux Runtime, Linux Container Configuration)等。目前Linux上最原始的容器Runtime是LXC，即Linux Container，最初Docker也是用LXC作为Runtime，后来Docker基于libcontainer开发了自己的Runtime，即runC。谷歌也基于Docker的Runtime发布了Kubernetes，后来CoreOS开发了独立的rkt作为运行容器的Runtime。而与容器相对的就是虚拟机了，目前虚拟机的Runtime如runV，看名字就知道是要与runC分庭抗礼的。此外Intel也弄了一个Clear containers的Runtime，也可以对接容器。基于Hyper runV和Clear containers，Openstack又新起了一个Kata Containers，目前已经可以在snap商店看到了，才出来没多久，地址在这。 利用Docker搭建私有云盘安装这里使用的是一个开源的云存储方案OwnCloud来搭建私有云盘。首先可以搜一下Dockerhub中的镜像，docker search owncloud可以看到结果： 其中第一个就是官方的镜像了，直接docker pull owncloud:8.1拉取就行。或者也可以直接docker run，本地没有它会去Dockerhub下载。 1docker run -d -p 80:80 owncloud:8.1 其中，-d表示后台运行，-p用来映射端口。也可以直接用-it前台打开tty直接操作。这时候可以在浏览器中看到了，输入localhost就可以看到登陆界面，大致是下面的样子： 运行配置其中数据保存在/var/www/html/data目录中，默认是使用SQLite用于数据存储，但对于较大的或者使用桌面客户端同步文件时，并不推荐SQLite，可以考虑最流行的MySQL。其他数据库需要外部安装。在运行时可以使用-v选项来将本地磁盘挂载到容器中数据保存的位置，即/var/www/html/中。 1-v /&lt;mydatalocation&gt;:/var/www/html 分的更细一点，可以添加三项，设置命令： 123-v /&lt;mydatalocation&gt;/apps:/var/www/html/apps installed / modified apps-v /&lt;mydatalocation&gt;/config:/var/www/html/config local configuration-v /&lt;mydatalocation&gt;/data:/var/www/html/data the actual data of your ownCloud 数据库配置外部数据库配置有几种方法，第一个是使用Owncloud自己提供的OCC工具(OwnCloud Console)来配置，使用docker exec执行:1docker exec -u www-data some-owncloud php occ status 另外的就是用Docker的工具了，Docker Stack或者Docker Compose来配置。首先需要编辑一个yml配置文件，如stack.yml或compose.yml，名字随便起，然后加入数据库配置:1234567891011121314151617181920212223242526# ownCloud with MariaDB/MySQL## Access via "http://localhost:8080" (or "http://$(docker-machine ip):8080" if using docker-machine)## During initial ownCloud setup, select "Storage &amp; database" --&gt; "Configure the database" --&gt; "MySQL/MariaDB"# Database user: root# Database password: example# Database name: pick any name# Database host: replace "localhost" with "mysql"version: '3.1'services: owncloud: image: owncloud:8.1 restart: always ports: - 8080:80 volumes: - "/home/newdee/Downloads/owncloud/:/var/www/html/" mysql: image: mysql:5.6 restart: always environment: MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: owncloud MYSQL_USER: first MYSQL_PASSWORD: 123456 最后运行docker stack deploy -c stack.yml owncloud (or docker-compose -f compose.yml up)即可。此时可以发现有两个容器正在运行:1234 $ ▶ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8499dc015bc8 owncloud:8.1 "/entrypoint.sh apac…" 15 minutes ago Up 12 minutes 0.0.0.0:8080-&gt;80/tcp owncloud_owncloud_16e145ebcca20 mysql:5.6 "docker-entrypoint.s…" 15 minutes ago Up 12 minutes 3306/tcp owncloud_mysql_1 然后在浏览器输入http://localhost:8080可以看到登陆界面，登录信息填yml文件中的信息就行。 登陆成功就可以看到登陆界面了。然后就可以网页上传下载了，还可以生成分享链接。上传下载地址位于挂载的目录中。没有机子也可以去试试VPS，自己搭一个私有云盘用来平时备份下载。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CUDA</tag>
        <tag>Docker</tag>
        <tag>TensorFlow</tag>
        <tag>OwnCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不满就折腾小记]]></title>
    <url>%2Fposts%2F9dfc9fe0%2F</url>
    <content type="text"><![CDATA[又不记得有多久没来了。稀里糊涂的过着日子，稀里糊涂的毕了业。很多事都是历久愈艰，所以很多习惯才没法坚持下去，对于博客这种需要长期维护的事情来说也当是如此。然而，还是又回来试图挣扎一下了。 其实这已经是第二篇博文了，第一篇写了很多废话，因为再重装系统换上了Ubuntu18.04之后，发现怎么都没法配好博客环境。很多东西都在变化，系统升级了，nodejs升级了，hexo升级了，连next啥的都升级了，当初在里面乱改插件的，现在对于重建是已经近乎绝望的心态了。 但是喜欢挣扎，删了该博客目录，重新从以前备份的博客仓库克隆下来重新搭建，还是搭不好，之前写好的文章，也不小心随着那个博客目录涅槃了。后来尝试了使用Docker来重现当时的博客环境，花了些时间，但好在成功了，以后也不必再因为博客环境再花费太多时间了。 暂别基佬紫笔记本重装了Ubuntu18.04，首先是改了下基佬紫的登陆界面，毕竟这种颜色陪伴了我太多年，学校的校花貌似都是这种颜色，毕竟一直看着也很无聊，其实这种小事，网上教程挺多的。因为Ubuntu18.04拥抱了Gnome，里面的很多登陆或者开机都是以样式文件存储，是挺方便改的了，但目前只想改这个，其余的以后再说。 由于gnome的缘故，采用了css样式文件保存登陆界面样式，所以只需要简单修改/etc/alternatives/gdm3.css或者/usr/share/gnome-shell/theme/.ubuntu.css文件即可。这两个字虽然位置不同，实际上是一个文件，对其中一个的修改会立刻反映到另一个文件上，如果同时打开，则会有下面的警告: 主要就是修改#lockDialogGroup的样式了，可以改成想要的颜色，也可以换成喜欢的图片，随便都行。 另外就是安装输入法了，还是习惯用的搜狗输入法，毕竟Linux下没几个好用的，安装完之后再语言管理栏添加以下语言和输入法就可以用了，没太多要说的。记得取消Only Show那个选项，然后添加就行。然后安装主题，还是用tweak工具，去gnome主题页面选择喜欢的下载下来应用就行了。 还有个小问题就是，安装了Ubuntu 18.04之后，截图工具有点问题了，每次截完图直接保存了，没有跳出复制还是保存的窗口，不过好在也不是什么大问题，以后用快捷键就可以解决。 统计计数不蒜子回来发现站点统计也挂了，后来去不蒜子页面看了下，发现了这样一段话： 因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！ 那没办法了，只好将原来不蒜子插件里的js源地址改一下。还有Vim手动编译以支持Python，Tmux手动编译，Powerline设置，等等，还是重复以往的工作，都挺无聊的，不过好在发现了一个有趣的网址，数字之门，可以免费提供各种云端镜像，有点像Docker，比如想学习Linux，各种化学分子软件，以及TensorFlow之类的软件，里面都有现成的镜像，不用自己配环境，适用于练习。 关于Gnome-shell扩展具体扩展部分可以参看Gnome的wiki页面,主要了解了一下它的透明效果:LookingGlass。可以使用JavaScript语言控制gnome-shell的界面。Ubuntu 18.04 Gnome支持Alt F2快速启动命令， 然后输入lg即可打开界面。 其中第一个是Evaluator，就是脚本执行界面，里面可以直接运行JavaScript，可以使用tab补全。第二个是Windows，里面会显示当前电脑里的所有窗口，用鼠标点击可以看到。剩下一个就是它的扩展了，里面会列出当前系统所安装的所有扩展，有错的话也会显示出来。 外网问题另一个问题就是使用Google学术以及其他完全不相关的事了。目前ss安全性已经大不如前了，主要还是ssr，有两种方式安装。 简洁版1234wget https://newdee.cf/ssrsudo chmod +x ssrsudo mv ssr /usr/local/binssr install 配置 1sudo vim /usr/local/share/shadowsocksr/config.json 里面填上服务器的信息，然后使用ssr start，再在系统或者浏览器中配置代理端口即可。 GUI版去项目页面安装然后使用dpkg安装，再用apt修复一下，基本是可以打开的，和win版本的操作类似，可以添加订阅地址。 V2ray现在兴起的另一种加密方式，可见其项目页面，下载解压 123sudo mkdir /etc/v2ray/sudo cp vpoint_vmess_freedom.json /etc/v2ray/config.jsonsudo mkdir -p /var/log/v2ray 编辑config.json文件，之后运行 1sudo ./v2ray 直接运行程序，V2Ray默认会在当前文件夹寻找名为 config.json 的配置文件并运行。或者移动到系统文件夹下运行: 12345sudo mkdir /etc/v2ray /usr/v2ray /var/log/v2ray # 创建目录sudo mv v2ray v2ctl geoip.dat geosite.dat -t /usr/bin/ # 移动文件touch /etc/v2ray/config.json # 仅创建配置文件的空文件sudo mv systemd/v2ray.service /etc/systemd/system/sudo systemctl enable v2ray 不过我放弃了，不知道是不是系统版本原因，目前该项目问题也比较多，暂时求稳。 其他其他的vpn主要如Windscribe，跨平台vpn，Linux版本下载地址 12345678910sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key FDC247B7echo 'deb https://repo.windscribe.com/ubuntu zesty main' | sudo tee /etc/apt/sources.list.d/windscribe-repo.listsudo apt-get updatesudo apt-get updatewindscribe loginwindscribe connectwindscribe --help 不过免费的速度都不怎么样，试过也放弃了。如果有账号的话，直接安装openvpn就可以了： 1sudo apt-get install openvpn network-manager-openvpn network-manager-openvpn-gnome 另外，对于有IPv6的代理来说，可以设置浏览器的优先级。如Firefox设置IPv6优先：输入about:config，并找到以下两项做相应修改： 12network.dns.disableIPv6 设置成 falsenetwork.http.fast-fallback-to-IPv4 设置成 false Snap软件包管理Ubuntu里新起的一种软件包管理方式，好像在16.04中开始引入。命令方式与apt类似，管理方式与docker容器类似，各个应用程序之间相对独立。与apt管理方式相比，s可以较好解决了应用之间的依赖问题便于管理，另一方面会占用较多磁盘空间，当apt方式无法下载所需的应用时，也可以选择使用snap方式下载。 Docker重建最后说说被博客折腾得心力交瘁时候的救星，Docker是一个容器技术已经不想多说，主要是环境隔离且独立的特点，非常适用于各种项目的平台迁移。已经不用再在自己电脑上安装nodejs和nvm来惹这些麻烦了，毕竟是好事。 主要方式是通过努力回忆，记起当时的各个软件的版本，然后用同样的系统去重建一遍，基本可以成功。由于npm和各个插件的版本已经在package.json和package-lock.json文件里了，按照里面的版本，利用nvm安装，然后删掉node_modules文件夹，使用npm重新安装即可跑起来。关于Docker的镜像构建，可以通过Docker commit和Dockerfile文件两种方式完成，前者可以直接从tty中构建，后者则可以实现自动部署。Docker教程网上太多，官方的也简明易上手，不知道有没有再写一篇关于Docker的笔记，而且网上也有很多已经写好了的镜像，是可以直接用的。最后，使用-p映射端口后，用-v挂载博客目录，然后写了这篇文章来做个测试。 终于找到家了~]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>Ubuntu</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GStreamer笔记五: Media Formats and Pad Capabilities]]></title>
    <url>%2Fposts%2F79fb69ed%2F</url>
    <content type="text"><![CDATA[此次所述有关pad功能。关于pad，前面已有简单介绍，pad功能是GStreamer的一个基本元素，由于框架会自动处理他们，所以大多数时候它们是不可见的。本次主要了解的是关于pad功能的检索。 基本概念Pads之前已经说过，pad相当于一个接口，允许信息通过或者离开一个元素。Pad的功能(Capabilities或者简写为Cap)指定哪种信息可以通过pad。例如“分辨率为320x200像素，每秒30帧的RGB视频”，或“每采样音频16位，每秒44100采样率的5.1声道”，甚至压缩格式如mp3或h264等。Pad可以支持多种功能(如一个video sink可以支持不同类型的RGB或者YUV格式的视频)，而且功能也可以指定范围(如一个audio sink可以支持每秒1-48000个采样的采样率)。但从pad到pad的实际信息必须仅有一个明确指定的类型。两个相连的pad通过一个协商过程达到一个共同的类型，从而使其pad功能变得固定(仅有一种类型，不包含范围)。要让两个元素连接在一起，他们的能力必须有一个公共子集，否则不可能相互理解。这也是能力的主要目标。应用程序开发人员通常会通过将元素连接到一起来构建管道（如果使用playbin之类的全部元素，则程度较低）。在这种情况下需要知道元素的Pad Caps，或者至少知道当GStreamer拒绝连接两个协商错误的元素时它们的Caps是什么。 Pad templatesPad是从pad模板创建的，pad模板表示了pad可能具有的所有功能。模板可用于创建一些相似的pad，并且允许早期拒绝元素之间的连接：如果其pad模板的功能没有公共子集（相交为空），则无需进一步协商。pad模板可视为协商过程第一步。随着过程的演变，实际的Pads被实例化并且其能力被提炼，直到它们被固定（或者协商失败）。 Capabilities examples一个能力的例子如下:1234567891011SINK template: 'sink' Availability: Always Capabilities: audio/x-raw format: S16LE rate: [ 1, 2147483647 ] channels: [ 1, 2 ] audio/x-raw format: U8 rate: [ 1, 2147483647 ] channels: [ 1, 2 ] 如代码中所示，该pad是一个接收端(sink)，且一直可用。它支持两种媒体，包括整数格式的原始音频（audio/x-raw）：带符号的16位小端 1和无符号8位。 方括号表示一个范围：例如，通道数从1到2不等。12345678SRC template: 'src' Availability: Always Capabilities: video/x-raw width: [ 1, 2147483647 ] height: [ 1, 2147483647 ] framerate: [ 0/1, 2147483647/1 ] format: &#123; I420, NV12, NV21, YV12, YUY2, Y42B, Y444, YUV9, YVU9, Y41B, Y800, Y8, GREY, Y16 , UYVY, YVYU, IYU1, v308, AYUV, A420 &#125; video/x-raw表示这个信号源输出原始视频。它支持多种尺寸和帧率，以及一组YUV格式（大括号列表表示）。所有这些格式都表示图像平面的不同的填充和下采样。 Last remarks可以使用gst-inspect-1.0工具了解所有GStreamer元素的Caps。一些元素查询底层硬件支持的格式，并相应地提供他们的pad功能（通常进入READY或更高状态时在这样做）。 因此，显示的能力可能因平台而异，也可能从一次执行到下一次执行就变了（即使这种情况很少）。本次将会实例化两个元素（这次通过其工厂函数），显示其pad模板，连接它们并设置管道播放。 在每次状态改变时，sink元素的Pad的功能会被显示，所以可以观察到协商如何进行直到Pad Caps固定。 Pad功能实例一个普通的有关pad caps的例子如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;gst/gst.h&gt;/* Functions below print the Capabilities in a human-friendly format */static gboolean print_field (GQuark field, const GValue * value, gpointer pfx) &#123; gchar *str = gst_value_serialize (value); g_print ("%s %15s: %s\n", (gchar *) pfx, g_quark_to_string (field), str); g_free (str); return TRUE;&#125;static void print_caps (const GstCaps * caps, const gchar * pfx) &#123; guint i; g_return_if_fail (caps != NULL); if (gst_caps_is_any (caps)) &#123; g_print ("%sANY\n", pfx); return; &#125; if (gst_caps_is_empty (caps)) &#123; g_print ("%sEMPTY\n", pfx); return; &#125; for (i = 0; i &lt; gst_caps_get_size (caps); i++) &#123; GstStructure *structure = gst_caps_get_structure (caps, i); g_print ("%s%s\n", pfx, gst_structure_get_name (structure)); gst_structure_foreach (structure, print_field, (gpointer) pfx); &#125;&#125;/* Prints information about a Pad Template, including its Capabilities */static void print_pad_templates_information (GstElementFactory * factory) &#123; const GList *pads; GstStaticPadTemplate *padtemplate; g_print ("Pad Templates for %s:\n", gst_element_factory_get_longname (factory)); if (!gst_element_factory_get_num_pad_templates (factory)) &#123; g_print (" none\n"); return; &#125; pads = gst_element_factory_get_static_pad_templates (factory); while (pads) &#123; padtemplate = pads-&gt;data; pads = g_list_next (pads); if (padtemplate-&gt;direction == GST_PAD_SRC) g_print (" SRC template: '%s'\n", padtemplate-&gt;name_template); else if (padtemplate-&gt;direction == GST_PAD_SINK) g_print (" SINK template: '%s'\n", padtemplate-&gt;name_template); else g_print (" UNKNOWN!!! template: '%s'\n", padtemplate-&gt;name_template); if (padtemplate-&gt;presence == GST_PAD_ALWAYS) g_print (" Availability: Always\n"); else if (padtemplate-&gt;presence == GST_PAD_SOMETIMES) g_print (" Availability: Sometimes\n"); else if (padtemplate-&gt;presence == GST_PAD_REQUEST) &#123; g_print (" Availability: On request\n"); &#125; else g_print (" Availability: UNKNOWN!!!\n"); if (padtemplate-&gt;static_caps.string) &#123; GstCaps *caps; g_print (" Capabilities:\n"); caps = gst_static_caps_get (&amp;padtemplate-&gt;static_caps); print_caps (caps, " "); gst_caps_unref (caps); &#125; g_print ("\n"); &#125;&#125;/* Shows the CURRENT capabilities of the requested pad in the given element */static void print_pad_capabilities (GstElement *element, gchar *pad_name) &#123; GstPad *pad = NULL; GstCaps *caps = NULL; /* Retrieve pad */ pad = gst_element_get_static_pad (element, pad_name); if (!pad) &#123; g_printerr ("Could not retrieve pad '%s'\n", pad_name); return; &#125; /* Retrieve negotiated caps (or acceptable caps if negotiation is not finished yet) */ caps = gst_pad_get_current_caps (pad); if (!caps) caps = gst_pad_query_caps (pad, NULL); /* Print and free */ g_print ("Caps for the %s pad:\n", pad_name); print_caps (caps, " "); gst_caps_unref (caps); gst_object_unref (pad);&#125;int main(int argc, char *argv[]) &#123; GstElement *pipeline, *source, *sink; GstElementFactory *source_factory, *sink_factory; GstBus *bus; GstMessage *msg; GstStateChangeReturn ret; gboolean terminate = FALSE; /* Initialize GStreamer */ gst_init (&amp;argc, &amp;argv); /* Create the element factories */ source_factory = gst_element_factory_find ("audiotestsrc"); sink_factory = gst_element_factory_find ("autoaudiosink"); if (!source_factory || !sink_factory) &#123; g_printerr ("Not all element factories could be created.\n"); return -1; &#125; /* Print information about the pad templates of these factories */ print_pad_templates_information (source_factory); print_pad_templates_information (sink_factory); /* Ask the factories to instantiate actual elements */ source = gst_element_factory_create (source_factory, "source"); sink = gst_element_factory_create (sink_factory, "sink"); /* Create the empty pipeline */ pipeline = gst_pipeline_new ("test-pipeline"); if (!pipeline || !source || !sink) &#123; g_printerr ("Not all elements could be created.\n"); return -1; &#125; /* Build the pipeline */ gst_bin_add_many (GST_BIN (pipeline), source, sink, NULL); if (gst_element_link (source, sink) != TRUE) &#123; g_printerr ("Elements could not be linked.\n"); gst_object_unref (pipeline); return -1; &#125; /* Print initial negotiated caps (in NULL state) */ g_print ("In NULL state:\n"); print_pad_capabilities (sink, "sink"); /* Start playing */ ret = gst_element_set_state (pipeline, GST_STATE_PLAYING); if (ret == GST_STATE_CHANGE_FAILURE) &#123; g_printerr ("Unable to set the pipeline to the playing state (check the bus for error messages).\n"); &#125; /* Wait until error, EOS or State Change */ bus = gst_element_get_bus (pipeline); do &#123; msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS | GST_MESSAGE_STATE_CHANGED); /* Parse message */ if (msg != NULL) &#123; GError *err; gchar *debug_info; switch (GST_MESSAGE_TYPE (msg)) &#123; case GST_MESSAGE_ERROR: gst_message_parse_error (msg, &amp;err, &amp;debug_info); g_printerr ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message); g_printerr ("Debugging information: %s\n", debug_info ? debug_info : "none"); g_clear_error (&amp;err); g_free (debug_info); terminate = TRUE; break; case GST_MESSAGE_EOS: g_print ("End-Of-Stream reached.\n"); terminate = TRUE; break; case GST_MESSAGE_STATE_CHANGED: /* We are only interested in state-changed messages from the pipeline */ if (GST_MESSAGE_SRC (msg) == GST_OBJECT (pipeline)) &#123; GstState old_state, new_state, pending_state; gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state); g_print ("\nPipeline state changed from %s to %s:\n", gst_element_state_get_name (old_state), gst_element_state_get_name (new_state)); /* Print the current capabilities of the sink element */ print_pad_capabilities (sink, "sink"); &#125; break; default: /* We should not reach here because we only asked for ERRORs, EOS and STATE_CHANGED */ g_printerr ("Unexpected message received.\n"); break; &#125; gst_message_unref (msg); &#125; &#125; while (!terminate); /* Free resources */ gst_object_unref (bus); gst_element_set_state (pipeline, GST_STATE_NULL); gst_object_unref (pipeline); gst_object_unref (source_factory); gst_object_unref (sink_factory); return 0;&#125; 所需要的库只有gstreamer-1.0。 代码分析print_field, print_caps和print_pad_templates简单的以友好的格式显示了caps的结构，更多的GstCaps内部结构组织可以阅读GStreamer的关于Pad Caps的文档。1234567891011121314151617181920212223/* Shows the CURRENT capabilities of the requested pad in the given element */static void print_pad_capabilities (GstElement *element, gchar *pad_name) &#123; GstPad *pad = NULL; GstCaps *caps = NULL; /* Retrieve pad */ pad = gst_element_get_static_pad (element, pad_name); if (!pad) &#123; g_printerr ("Could not retrieve pad '%s'\n", pad_name); return; &#125; /* Retrieve negotiated caps (or acceptable caps if negotiation is not finished yet) */ caps = gst_pad_get_current_caps (pad); if (!caps) caps = gst_pad_query_caps (pad, NULL); /* Print and free */ g_print ("Caps for the %s pad:\n", pad_name); print_caps (caps, " "); gst_caps_unref (caps); gst_object_unref (pad);&#125; gst_element_get_static_pad函数从给定的元素中检索命名的pad。这个pad是静态的，因为它总是存在于元素中。有关Pad可用性的更多信息，可以阅读有关Pads的GStreamer文档。然后调用gst_pad_get_current_caps来检索pad的当前caps，它可以是固定的或不固定的，具体取决于协商过程的状态。甚至可能不存在，这种情况下调用gst_pad_query_caps来检索当前可接受的pad caps。当前可接受的caps将成为处于NULL状态的pad模板的caps，但可能会在以后的状态中更改，因为可能会查询实际的硬件功能。然后将这些功能打印出来:123456789101112131415/* Create the element factories */source_factory = gst_element_factory_find ("audiotestsrc");sink_factory = gst_element_factory_find ("autoaudiosink");if (!source_factory || !sink_factory) &#123; g_printerr ("Not all element factories could be created.\n"); return -1;&#125;/* Print information about the pad templates of these factories */print_pad_templates_information (source_factory);print_pad_templates_information (sink_factory);/* Ask the factories to instantiate actual elements */source = gst_element_factory_create (source_factory, "source");sink = gst_element_factory_create (sink_factory, "sink"); 之前直接使用gst_element_factory_make函数创建了元素，并跳过了关于工厂的讨论。GstElementFactory负责实例化由其工厂名称标识的特定类型的元素。可以使用gst_element_factory_find来创建一个类型为“videotestsrc”的工厂，然后通过gst_element_factory_create使用它实例化多个“videotestsrc”元素。gst_element_factory_make实际上是gst_element_factory_find+gst_element_factory_create的快捷方式。Pad模板已经可以通过工厂来访问，所以一旦工厂被创建，它们就会被打印出来。跳过管道的创建以及开始，转到State-Changed消息处理：1234567891011case GST_MESSAGE_STATE_CHANGED: /* We are only interested in state-changed messages from the pipeline */ if (GST_MESSAGE_SRC (msg) == GST_OBJECT (pipeline)) &#123; GstState old_state, new_state, pending_state; gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state); g_print ("\nPipeline state changed from %s to %s:\n", gst_element_state_get_name (old_state), gst_element_state_get_name (new_state)); /* Print the current capabilities of the sink element */ print_pad_capabilities (sink, "sink"); &#125; break; 该段代码在每次Pipeline状态发生改变时简单的打印出当前的pad caps。可以在输出中看到初始caps（pad模板的caps）是如何逐步完善直至完全固定（包含无范围单一类型）。 1.对于整型/长整型等数据类型，小端与大端相反，按照从低地址到高地址的顺序存放数据的高位字节到低位字节。 ↩]]></content>
      <categories>
        <category>TX1入坑</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GStreamer</tag>
        <tag>TX1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSreamer笔记四: GUI Toolkit Integration]]></title>
    <url>%2Fposts%2F40a79901%2F</url>
    <content type="text"><![CDATA[主要是关于如何将GStreamer集成到图形用户界面(GUI)工具箱中。基本上当GUI工具箱处理用户界面时，GStreamer主要负责媒体播放。其中两个库必须交互的部分是最有趣的两个部分，即:指导GStreamer将视频输出到GTK+的窗口中并将用户操作转发给GStreamer。需要解决的问题有: 告诉GStreamer如何将视频输出到特定窗口，而不是自己创建窗口； 如何使用GStreamer的信息持续刷新GUI； 如何从GStreamer的多个线程更新GUI(这是大多数GUI工具包中被禁止的操作)； 一个只订阅感兴趣的消息而不是通知所有人的机制。 关于GTK+这里将使用GTK+工具包构建媒体播放器，这些概念亦适用于其他工具包如QT。关键是告诉GStreamer将视频输出到所选择的窗口。具体机制取决于操作系统(或者窗口系统)，但GStreamer为平台独立性提供了一个抽象层。这种独立性来自GstVideoOverlay接口，它允许应用程序告诉视频接收器(sink)应该接收渲染的窗口的处理程序。Gstreamer所使用的是GObject 接口。GObject的接口是元素可以实现的一组函数，包括GstVideoOverlay等。具体介绍如下: A GObject interface (which GStreamer uses) is a set of functions that an element can implement. If it does, then it is said to support that particular interface. For example, video sinks usually create their own windows to display video, but, if they are also capable of rendering to an external window, they can choose to implement the GstVideoOverlay interface and provide functions to specify this external window. From the application developer point of view, if a certain interface is supported, you can use it and forget about which kind of element is implementing it. Moreover, if you are using playbin, it will automatically expose some of the interfaces supported by its internal elements: You can use your interface functions directly on playbin without knowing who is implementing them! 另一个问题是，GUI工具包通常只允许主（或应用）线程来操作图形“小部件”，而GStreamer通常会派生多个线程来处理不同的任务。从回调函数中调用GTK +函数通常会失败，因为回调函数在调用线程中执行，并不需要在主线程中。这个问题可以通过回调函数在GStreamer总线上发布消息来解决: 主线程接收消息并做出相应反应。这里已经注册了一个handle_message函数，每次在总线上出现一条消息时都会调用这个函数，这迫使我们解析每条消息，看看我们是否对其感兴趣。本例中使用了一种不同的方法来为每种消息注册一个回调，所以解析更少，代码更少。 GTK+播放器示例一个简单的基于playbin的带GUI的媒体播放器如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380#include &lt;string.h&gt;#include &lt;gtk/gtk.h&gt;#include &lt;gst/gst.h&gt;#include &lt;gst/video/videooverlay.h&gt;#include &lt;gdk/gdk.h&gt;#if defined (GDK_WINDOWING_X11)#include &lt;gdk/gdkx.h&gt;#elif defined (GDK_WINDOWING_WIN32)#include &lt;gdk/gdkwin32.h&gt;#elif defined (GDK_WINDOWING_QUARTZ)#include &lt;gdk/gdkquartz.h&gt;#endif/* Structure to contain all our information, so we can pass it around */typedef struct _CustomData &#123; GstElement *playbin; /* Our one and only pipeline */ GtkWidget *slider; /* Slider widget to keep track of current position */ GtkWidget *streams_list; /* Text widget to display info about the streams */ gulong slider_update_signal_id; /* Signal ID for the slider update signal */ GstState state; /* Current state of the pipeline */ gint64 duration; /* Duration of the clip, in nanoseconds */&#125; CustomData;/* This function is called when the GUI toolkit creates the physical window that will hold the video. * At this point we can retrieve its handler (which has a different meaning depending on the windowing system) * and pass it to GStreamer through the VideoOverlay interface. */static void realize_cb (GtkWidget *widget, CustomData *data) &#123; GdkWindow *window = gtk_widget_get_window (widget); guintptr window_handle; if (!gdk_window_ensure_native (window)) g_error ("Couldn't create native window needed for GstVideoOverlay!"); /* Retrieve window handler from GDK */#if defined (GDK_WINDOWING_WIN32) window_handle = (guintptr)GDK_WINDOW_HWND (window);#elif defined (GDK_WINDOWING_QUARTZ) window_handle = gdk_quartz_window_get_nsview (window);#elif defined (GDK_WINDOWING_X11) window_handle = GDK_WINDOW_XID (window);#endif /* Pass it to playbin, which implements VideoOverlay and will forward it to the video sink */ gst_video_overlay_set_window_handle (GST_VIDEO_OVERLAY (data-&gt;playbin), window_handle);&#125;/* This function is called when the PLAY button is clicked */static void play_cb (GtkButton *button, CustomData *data) &#123; gst_element_set_state (data-&gt;playbin, GST_STATE_PLAYING);&#125;/* This function is called when the PAUSE button is clicked */static void pause_cb (GtkButton *button, CustomData *data) &#123; gst_element_set_state (data-&gt;playbin, GST_STATE_PAUSED);&#125;/* This function is called when the STOP button is clicked */static void stop_cb (GtkButton *button, CustomData *data) &#123; gst_element_set_state (data-&gt;playbin, GST_STATE_READY);&#125;/* This function is called when the main window is closed */static void delete_event_cb (GtkWidget *widget, GdkEvent *event, CustomData *data) &#123; stop_cb (NULL, data); gtk_main_quit ();&#125;/* This function is called everytime the video window needs to be redrawn (due to damage/exposure, * rescaling, etc). GStreamer takes care of this in the PAUSED and PLAYING states, otherwise, * we simply draw a black rectangle to avoid garbage showing up. */static gboolean draw_cb (GtkWidget *widget, cairo_t *cr, CustomData *data) &#123; if (data-&gt;state &lt; GST_STATE_PAUSED) &#123; GtkAllocation allocation; /* Cairo is a 2D graphics library which we use here to clean the video window. * It is used by GStreamer for other reasons, so it will always be available to us. */ gtk_widget_get_allocation (widget, &amp;allocation); cairo_set_source_rgb (cr, 0, 0, 0); cairo_rectangle (cr, 0, 0, allocation.width, allocation.height); cairo_fill (cr); &#125; return FALSE;&#125;/* This function is called when the slider changes its position. We perform a seek to the * new position here. */static void slider_cb (GtkRange *range, CustomData *data) &#123; gdouble value = gtk_range_get_value (GTK_RANGE (data-&gt;slider)); gst_element_seek_simple (data-&gt;playbin, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, (gint64)(value * GST_SECOND));&#125;/* This creates all the GTK+ widgets that compose our application, and registers the callbacks */static void create_ui (CustomData *data) &#123; GtkWidget *main_window; /* The uppermost window, containing all other windows */ GtkWidget *video_window; /* The drawing area where the video will be shown */ GtkWidget *main_box; /* VBox to hold main_hbox and the controls */ GtkWidget *main_hbox; /* HBox to hold the video_window and the stream info text widget */ GtkWidget *controls; /* HBox to hold the buttons and the slider */ GtkWidget *play_button, *pause_button, *stop_button; /* Buttons */ main_window = gtk_window_new (GTK_WINDOW_TOPLEVEL); g_signal_connect (G_OBJECT (main_window), "delete-event", G_CALLBACK (delete_event_cb), data); video_window = gtk_drawing_area_new (); gtk_widget_set_double_buffered (video_window, FALSE); g_signal_connect (video_window, "realize", G_CALLBACK (realize_cb), data); g_signal_connect (video_window, "draw", G_CALLBACK (draw_cb), data); play_button = gtk_button_new_from_icon_name ("media-playback-start", GTK_ICON_SIZE_SMALL_TOOLBAR); g_signal_connect (G_OBJECT (play_button), "clicked", G_CALLBACK (play_cb), data); pause_button = gtk_button_new_from_icon_name ("media-playback-pause", GTK_ICON_SIZE_SMALL_TOOLBAR); g_signal_connect (G_OBJECT (pause_button), "clicked", G_CALLBACK (pause_cb), data); stop_button = gtk_button_new_from_icon_name ("media-playback-stop", GTK_ICON_SIZE_SMALL_TOOLBAR); g_signal_connect (G_OBJECT (stop_button), "clicked", G_CALLBACK (stop_cb), data); data-&gt;slider = gtk_scale_new_with_range (GTK_ORIENTATION_HORIZONTAL, 0, 100, 1); gtk_scale_set_draw_value (GTK_SCALE (data-&gt;slider), 0); data-&gt;slider_update_signal_id = g_signal_connect (G_OBJECT (data-&gt;slider), "value-changed", G_CALLBACK (slider_cb), data); data-&gt;streams_list = gtk_text_view_new (); gtk_text_view_set_editable (GTK_TEXT_VIEW (data-&gt;streams_list), FALSE); controls = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0); gtk_box_pack_start (GTK_BOX (controls), play_button, FALSE, FALSE, 2); gtk_box_pack_start (GTK_BOX (controls), pause_button, FALSE, FALSE, 2); gtk_box_pack_start (GTK_BOX (controls), stop_button, FALSE, FALSE, 2); gtk_box_pack_start (GTK_BOX (controls), data-&gt;slider, TRUE, TRUE, 2); main_hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0); gtk_box_pack_start (GTK_BOX (main_hbox), video_window, TRUE, TRUE, 0); gtk_box_pack_start (GTK_BOX (main_hbox), data-&gt;streams_list, FALSE, FALSE, 2); main_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0); gtk_box_pack_start (GTK_BOX (main_box), main_hbox, TRUE, TRUE, 0); gtk_box_pack_start (GTK_BOX (main_box), controls, FALSE, FALSE, 0); gtk_container_add (GTK_CONTAINER (main_window), main_box); gtk_window_set_default_size (GTK_WINDOW (main_window), 640, 480); gtk_widget_show_all (main_window);&#125;/* This function is called periodically to refresh the GUI */static gboolean refresh_ui (CustomData *data) &#123; gint64 current = -1; /* We do not want to update anything unless we are in the PAUSED or PLAYING states */ if (data-&gt;state &lt; GST_STATE_PAUSED) return TRUE; /* If we didn't know it yet, query the stream duration */ if (!GST_CLOCK_TIME_IS_VALID (data-&gt;duration)) &#123; if (!gst_element_query_duration (data-&gt;playbin, GST_FORMAT_TIME, &amp;data-&gt;duration)) &#123; g_printerr ("Could not query current duration.\n"); &#125; else &#123; /* Set the range of the slider to the clip duration, in SECONDS */ gtk_range_set_range (GTK_RANGE (data-&gt;slider), 0, (gdouble)data-&gt;duration / GST_SECOND); &#125; &#125; if (gst_element_query_position (data-&gt;playbin, GST_FORMAT_TIME, &amp;current)) &#123; /* Block the "value-changed" signal, so the slider_cb function is not called * (which would trigger a seek the user has not requested) */ g_signal_handler_block (data-&gt;slider, data-&gt;slider_update_signal_id); /* Set the position of the slider to the current pipeline positoin, in SECONDS */ gtk_range_set_value (GTK_RANGE (data-&gt;slider), (gdouble)current / GST_SECOND); /* Re-enable the signal */ g_signal_handler_unblock (data-&gt;slider, data-&gt;slider_update_signal_id); &#125; return TRUE;&#125;/* This function is called when new metadata is discovered in the stream */static void tags_cb (GstElement *playbin, gint stream, CustomData *data) &#123; /* We are possibly in a GStreamer working thread, so we notify the main * thread of this event through a message in the bus */ gst_element_post_message (playbin, gst_message_new_application (GST_OBJECT (playbin), gst_structure_new_empty ("tags-changed")));&#125;/* This function is called when an error message is posted on the bus */static void error_cb (GstBus *bus, GstMessage *msg, CustomData *data) &#123; GError *err; gchar *debug_info; /* Print error details on the screen */ gst_message_parse_error (msg, &amp;err, &amp;debug_info); g_printerr ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message); g_printerr ("Debugging information: %s\n", debug_info ? debug_info : "none"); g_clear_error (&amp;err); g_free (debug_info); /* Set the pipeline to READY (which stops playback) */ gst_element_set_state (data-&gt;playbin, GST_STATE_READY);&#125;/* This function is called when an End-Of-Stream message is posted on the bus. * We just set the pipeline to READY (which stops playback) */static void eos_cb (GstBus *bus, GstMessage *msg, CustomData *data) &#123; g_print ("End-Of-Stream reached.\n"); gst_element_set_state (data-&gt;playbin, GST_STATE_READY);&#125;/* This function is called when the pipeline changes states. We use it to * keep track of the current state. */static void state_changed_cb (GstBus *bus, GstMessage *msg, CustomData *data) &#123; GstState old_state, new_state, pending_state; gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state); if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;playbin)) &#123; data-&gt;state = new_state; g_print ("State set to %s\n", gst_element_state_get_name (new_state)); if (old_state == GST_STATE_READY &amp;&amp; new_state == GST_STATE_PAUSED) &#123; /* For extra responsiveness, we refresh the GUI as soon as we reach the PAUSED state */ refresh_ui (data); &#125; &#125;&#125;/* Extract metadata from all the streams and write it to the text widget in the GUI */static void analyze_streams (CustomData *data) &#123; gint i; GstTagList *tags; gchar *str, *total_str; guint rate; gint n_video, n_audio, n_text; GtkTextBuffer *text; /* Clean current contents of the widget */ text = gtk_text_view_get_buffer (GTK_TEXT_VIEW (data-&gt;streams_list)); gtk_text_buffer_set_text (text, "", -1); /* Read some properties */ g_object_get (data-&gt;playbin, "n-video", &amp;n_video, NULL); g_object_get (data-&gt;playbin, "n-audio", &amp;n_audio, NULL); g_object_get (data-&gt;playbin, "n-text", &amp;n_text, NULL); for (i = 0; i &lt; n_video; i++) &#123; tags = NULL; /* Retrieve the stream's video tags */ g_signal_emit_by_name (data-&gt;playbin, "get-video-tags", i, &amp;tags); if (tags) &#123; total_str = g_strdup_printf ("video stream %d:\n", i); gtk_text_buffer_insert_at_cursor (text, total_str, -1); g_free (total_str); gst_tag_list_get_string (tags, GST_TAG_VIDEO_CODEC, &amp;str); total_str = g_strdup_printf (" codec: %s\n", str ? str : "unknown"); gtk_text_buffer_insert_at_cursor (text, total_str, -1); g_free (total_str); g_free (str); gst_tag_list_free (tags); &#125; &#125; for (i = 0; i &lt; n_audio; i++) &#123; tags = NULL; /* Retrieve the stream's audio tags */ g_signal_emit_by_name (data-&gt;playbin, "get-audio-tags", i, &amp;tags); if (tags) &#123; total_str = g_strdup_printf ("\naudio stream %d:\n", i); gtk_text_buffer_insert_at_cursor (text, total_str, -1); g_free (total_str); if (gst_tag_list_get_string (tags, GST_TAG_AUDIO_CODEC, &amp;str)) &#123; total_str = g_strdup_printf (" codec: %s\n", str); gtk_text_buffer_insert_at_cursor (text, total_str, -1); g_free (total_str); g_free (str); &#125; if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) &#123; total_str = g_strdup_printf (" language: %s\n", str); gtk_text_buffer_insert_at_cursor (text, total_str, -1); g_free (total_str); g_free (str); &#125; if (gst_tag_list_get_uint (tags, GST_TAG_BITRATE, &amp;rate)) &#123; total_str = g_strdup_printf (" bitrate: %d\n", rate); gtk_text_buffer_insert_at_cursor (text, total_str, -1); g_free (total_str); &#125; gst_tag_list_free (tags); &#125; &#125; for (i = 0; i &lt; n_text; i++) &#123; tags = NULL; /* Retrieve the stream's subtitle tags */ g_signal_emit_by_name (data-&gt;playbin, "get-text-tags", i, &amp;tags); if (tags) &#123; total_str = g_strdup_printf ("\nsubtitle stream %d:\n", i); gtk_text_buffer_insert_at_cursor (text, total_str, -1); g_free (total_str); if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) &#123; total_str = g_strdup_printf (" language: %s\n", str); gtk_text_buffer_insert_at_cursor (text, total_str, -1); g_free (total_str); g_free (str); &#125; gst_tag_list_free (tags); &#125; &#125;&#125;/* This function is called when an "application" message is posted on the bus. * Here we retrieve the message posted by the tags_cb callback */static void application_cb (GstBus *bus, GstMessage *msg, CustomData *data) &#123; if (g_strcmp0 (gst_structure_get_name (gst_message_get_structure (msg)), "tags-changed") == 0) &#123; /* If the message is the "tags-changed" (only one we are currently issuing), update * the stream info GUI */ analyze_streams (data); &#125;&#125;int main(int argc, char *argv[]) &#123; CustomData data; GstStateChangeReturn ret; GstBus *bus; /* Initialize GTK */ gtk_init (&amp;argc, &amp;argv); /* Initialize GStreamer */ gst_init (&amp;argc, &amp;argv); /* Initialize our data structure */ memset (&amp;data, 0, sizeof (data)); data.duration = GST_CLOCK_TIME_NONE; /* Create the elements */ data.playbin = gst_element_factory_make ("playbin", "playbin"); if (!data.playbin) &#123; g_printerr ("Not all elements could be created.\n"); return -1; &#125; /* Set the URI to play */ g_object_set (data.playbin, "uri", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm", NULL); /* Connect to interesting signals in playbin */ g_signal_connect (G_OBJECT (data.playbin), "video-tags-changed", (GCallback) tags_cb, &amp;data); g_signal_connect (G_OBJECT (data.playbin), "audio-tags-changed", (GCallback) tags_cb, &amp;data); g_signal_connect (G_OBJECT (data.playbin), "text-tags-changed", (GCallback) tags_cb, &amp;data); /* Create the GUI */ create_ui (&amp;data); /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */ bus = gst_element_get_bus (data.playbin); gst_bus_add_signal_watch (bus); g_signal_connect (G_OBJECT (bus), "message::error", (GCallback)error_cb, &amp;data); g_signal_connect (G_OBJECT (bus), "message::eos", (GCallback)eos_cb, &amp;data); g_signal_connect (G_OBJECT (bus), "message::state-changed", (GCallback)state_changed_cb, &amp;data); g_signal_connect (G_OBJECT (bus), "message::application", (GCallback)application_cb, &amp;data); gst_object_unref (bus); /* Start playing */ ret = gst_element_set_state (data.playbin, GST_STATE_PLAYING); if (ret == GST_STATE_CHANGE_FAILURE) &#123; g_printerr ("Unable to set the pipeline to the playing state.\n"); gst_object_unref (data.playbin); return -1; &#125; /* Register a function that GLib will call every second */ g_timeout_add_seconds (1, (GSourceFunc)refresh_ui, &amp;data); /* Start the GTK main loop. We will not regain control until gtk_main_quit is called. */ gtk_main (); /* Free resources */ gst_element_set_state (data.playbin, GST_STATE_NULL); gst_object_unref (data.playbin); return 0;&#125; Required libraries: gstreamer-video-1.0 gtk+-3.0 gstreamer-1.0所以此时编译需加上pkg-config --cflags --libs gstreamer-video-1.0 gtk+-3.0 gstreamer-1.0参数获取所需的头文件和库文件。如果提示找不到gtk+-3.0,则安装。sudo apt install build-essential libgtk-3-dev提示未安装gstreamer-video-1.0，则安装。sudo apt install libgstreamer-plugins-base1.0-dev该例将会打开一个GTK+窗口并显示一个伴有音频的电影。媒体来自于互联网，所以窗口可能需要几秒才能显示，具体取决于网速。该窗口有一些按钮来暂停、停止和播放电影，还有个滑块显示当前位置，可以拖动或者改变它。此外，关于流的信息显示在右边的一列上。 代码分析本例中，函数不再在使用之前定义，代码呈现的顺序也不总是和程序顺序相匹配。12345678#include &lt;gdk/gdk.h&gt;#if defined (GDK_WINDOWING_X11)#include &lt;gdk/gdkx.h&gt;#elif defined (GDK_WINDOWING_WIN32)#include &lt;gdk/gdkwin32.h&gt;#elif defined (GDK_WINDOWING_QUARTZ)#include &lt;gdk/gdkquartzwindow.h&gt;#endif 首先需要注意的是，现在并不是与平台完全无关的了，因为我们需要为所使用的窗口系统包含适当的头文件。幸运的是，没有那么多支持的窗口系统，所以X11 for Linux，Win32 for Windows和Quartz for Mac OSX这三行足够了。本例主要有回调函数组成，这些回调函数将从GStreamer或GTK+中调用。所以先看一下主函数，其中将会用到所有的回调函数。 12345678910111213141516171819202122232425int main(int argc, char *argv[]) &#123; CustomData data; GstStateChangeReturn ret; GstBus *bus; /* Initialize GTK */ gtk_init (&amp;argc, &amp;argv); /* Initialize GStreamer */ gst_init (&amp;argc, &amp;argv); /* Initialize our data structure */ memset (&amp;data, 0, sizeof (data)); data.duration = GST_CLOCK_TIME_NONE; /* Create the elements */ data.playbin = gst_element_factory_make ("playbin", "playbin"); if (!data.playbin) &#123; g_printerr ("Not all elements could be created.\n"); return -1; &#125; /* Set the URI to play */ g_object_set (data.playbin, "uri", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm", NULL); 标准的GStreamer和playbin管道创建，以及GTK+初始化。1234/* Connect to interesting signals in playbin */g_signal_connect (G_OBJECT (data.playbin), "video-tags-changed", (GCallback) tags_cb, &amp;data);g_signal_connect (G_OBJECT (data.playbin), "audio-tags-changed", (GCallback) tags_cb, &amp;data);g_signal_connect (G_OBJECT (data.playbin), "text-tags-changed", (GCallback) tags_cb, &amp;data); 我们希望在流上出现新标签(元数据)时收到通知，为了简单起见，将处理来自相同回调函数tag_cb的所有种类标签(视频、音频和文本)。然后创建GUI:12/* Create the GUI */create_ui (&amp;data); 所有的GTK+部件创建和信号注册都发生在这个函数中，它只包含GTK相关的函数调用，所以可以跳过它的定义。其所注册的信号传递用户命令，如下面在查看回调时所示。12345678/* Instruct the bus to emit signals for each received message, and connect to the interesting signals */ bus = gst_element_get_bus (data.playbin); gst_bus_add_signal_watch (bus); g_signal_connect (G_OBJECT (bus), "message::error", (GCallback)error_cb, &amp;data); g_signal_connect (G_OBJECT (bus), "message::eos", (GCallback)eos_cb, &amp;data); g_signal_connect (G_OBJECT (bus), "message::state-changed", (GCallback)state_changed_cb, &amp;data); g_signal_connect (G_OBJECT (bus), "message::application", (GCallback)application_cb, &amp;data); gst_object_unref (bus); 其中，gst_bus_add_watch函数用于注册用于接收所有的消息并发送给GStreamer总线。可以通过使用信号来达到更精细的粒度，这使得我们仅注册感兴趣的消息。通过调用gst_bus_add_signal_watch函数，我们指导总线在每次收到一个消息时发出一个信号。信号名称是message::detail，其中‘detail’是触发信号发出的消息。例如，当总线接收到EOS消息时，将发出一个名为message::eos的信号。例中仅使用信号描述(detail)来注册所感兴趣的消息。如果我们注册了一个消息的信号，我们将收到每个消息的通知，如gst_bus_add_watch函数所做的一样。为了使“bus watches”工作（无论是gst_bus_add_watch还是gst_bus_add_signal_watch），必须运行GLib主循环。这种情况下，它隐藏在GTK+主循环中。12/* Register a function that GLib will call every second */g_timeout_add_seconds (1, (GSourceFunc)refresh_ui, &amp;data); 在将控制移交给GTK+之前，使用g_timeout_add_seconds函数来注册另一个回调函数————超时，且每秒会被调用：用其从refresh_ui函数刷新GUI。在这之后，我们完成了建立并启动GTK+主循环。感兴趣的事件发生时，将从回调函数中重新获取控制权。每个回调函数都有不同的签名，具体取决于调用者。可以再信号的文档中查找签名(参数的含义和返回值)。123456789101112131415161718192021/* This function is called when the GUI toolkit creates the physical window that will hold the video. * At this point we can retrieve its handler (which has a different meaning depending on the windowing system) * and pass it to GStreamer through the VideoOverlay interface. */static void realize_cb (GtkWidget *widget, CustomData *data) &#123; GdkWindow *window = gtk_widget_get_window (widget); guintptr window_handle; if (!gdk_window_ensure_native (window)) g_error ("Couldn't create native window needed for GstVideoOverlay!"); /* Retrieve window handler from GDK */#if defined (GDK_WINDOWING_WIN32) window_handle = (guintptr)GDK_WINDOW_HWND (window);#elif defined (GDK_WINDOWING_QUARTZ) window_handle = gdk_quartz_window_get_nsview (window);#elif defined (GDK_WINDOWING_X11) window_handle = GDK_WINDOW_XID (window);#endif /* Pass it to playbin, which implements VideoOverlay and will forward it to the video sink */ gst_video_overlay_set_window_handle (GST_VIDEO_OVERLAY (data-&gt;playbin), window_handle);&#125; 在应用程序生命周期的这一点上，我们知道GStreamer应该呈现视频的窗口句柄（无论是X11的XID，Window的HWND还是Quartz的NSView）。我们只需从窗口系统中检索它，并使用gst_video_overlay_set_window_handle通过GstVideoOverlay接口将其传递给playbin。playbin将定位视频接收器并将处理程序传递给它，所以它不会创建自己的窗口并使用它。playbin和GstVideoOverlay将此过程简化了许多。1234567891011121314/* This function is called when the PLAY button is clicked */static void play_cb (GtkButton *button, CustomData *data) &#123; gst_element_set_state (data-&gt;playbin, GST_STATE_PLAYING);&#125;/* This function is called when the PAUSE button is clicked */static void pause_cb (GtkButton *button, CustomData *data) &#123; gst_element_set_state (data-&gt;playbin, GST_STATE_PAUSED);&#125;/* This function is called when the STOP button is clicked */static void stop_cb (GtkButton *button, CustomData *data) &#123; gst_element_set_state (data-&gt;playbin, GST_STATE_READY);&#125; 这三个回调函数是关于GUI的播放，暂停和停止按钮的，它们只需要将管道设置为相应的状态即可。值得注意的是，在STOP状态下，将管道状态设置为READY。可以将流水线一直带到NULL状态，但是会导致过渡慢一点，因为有些资源(如音频设备)需要重新释放重新获取。12345/* This function is called when the main window is closed */static void delete_event_cb (GtkWidget *widget, GdkEvent *event, CustomData *data) &#123; stop_cb (NULL, data); gtk_main_quit ();&#125; gtk_main_quit最终会在main中调用gtk_main_run来终止，并在这种情况下完成整个程序。这里，在停止管道(只是为了整洁)后，当主窗口关闭时调用它。 1234567891011121314151617/* This function is called everytime the video window needs to be redrawn (due to damage/exposure, * rescaling, etc). GStreamer takes care of this in the PAUSED and PLAYING states, otherwise, * we simply draw a black rectangle to avoid garbage showing up. */static gboolean draw_cb (GtkWidget *widget, cairo_t *cr, CustomData *data) &#123; if (data-&gt;state &lt; GST_STATE_PAUSED) &#123; GtkAllocation allocation; /* Cairo is a 2D graphics library which we use here to clean the video window. * It is used by GStreamer for other reasons, so it will always be available to us. */ gtk_widget_get_allocation (widget, &amp;allocation); cairo_set_source_rgb (cr, 0, 0, 0); cairo_rectangle (cr, 0, 0, allocation.width, allocation.height); cairo_fill (cr); &#125; return FALSE;&#125; 当有数据流时（处于PAUSED和PLAYING状态），视频接收器负责刷新视频窗口的内容。但其他情况下不会这样，所以必须我们自己来做: 例中我们是使用一个黑色的矩形填充窗口。 1234567/* This function is called when the slider changes its position. We perform a seek to the * new position here. */static void slider_cb (GtkRange *range, CustomData *data) &#123; gdouble value = gtk_range_get_value (GTK_RANGE (data-&gt;slider)); gst_element_seek_simple (data-&gt;playbin, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, (gint64)(value * GST_SECOND));&#125; 通过GStreamer和GTK+的协作，可以非常容易地实现一个复杂的GUI元素，如一个搜索条（或者允许搜索的滑块）。如果滑块被拖动到新位置，则告诉GStreamer使用gst_element_seek_simple查找该位置。 滑块已经设置，它的值代表秒。值得注意的是，一些性能和响应可以通过不去响应所有的单个用户的搜索请求来获得。由于搜索操作需要花费一些时间，所以在允许另一个搜索操作之前，更好的办法是等待一会(如半秒钟)。否则，如果用户疯狂的拖拽滑动条，应用程序看起来可能也没有响应，因为在一个新的搜索操作在队列中之前将不会允许任何搜索。 1234567/* This function is called periodically to refresh the GUI */static gboolean refresh_ui (CustomData *data) &#123; gint64 current = -1; /* We do not want to update anything unless we are in the PAUSED or PLAYING states */ if (data-&gt;state &lt; GST_STATE_PAUSED) return TRUE; 该函数将移动滑块以反映媒体当前的位置。如果我们不处于PLAYING状态，那么在这里没有任何事情可做（位置和持续时间查询通常会失败）。 123456789/* If we didn't know it yet, query the stream duration */if (!GST_CLOCK_TIME_IS_VALID (data-&gt;duration)) &#123; if (!gst_element_query_duration (data-&gt;playbin, GST_FORMAT_TIME, &amp;data-&gt;duration)) &#123; g_printerr ("Could not query current duration.\n"); &#125; else &#123; /* Set the range of the slider to the clip duration, in SECONDS */ gtk_range_set_range (GTK_RANGE (data-&gt;slider), 0, (gdouble)data-&gt;duration / GST_SECOND); &#125;&#125; 可以设置滑块的范围以防我们在不知情的情况下恢复clip的持续时间。 12345678910if (gst_element_query_position (data-&gt;playbin, GST_FORMAT_TIME, &amp;current)) &#123; /* Block the "value-changed" signal, so the slider_cb function is not called * (which would trigger a seek the user has not requested) */ g_signal_handler_block (data-&gt;slider, data-&gt;slider_update_signal_id); /* Set the position of the slider to the current pipeline positoin, in SECONDS */ gtk_range_set_value (GTK_RANGE (data-&gt;slider), (gdouble)current / GST_SECOND); /* Re-enable the signal */ g_signal_handler_unblock (data-&gt;slider, data-&gt;slider_update_signal_id);&#125;return TRUE; 查询当前的管道位置，并根据滑块设置其位置。这将会触发一个value-changed信号，我们可以通过其知道用户在拖动滑块。除非用户请求它们，否则我们不希望发生这种情况，所以在此操作期间，使用g_sinal_handler_block和g_signal_handler_unblock禁用value-changed的信号发出。该函数返回True将在之后保持其调用。如果返回FALSE，定时器将被删除。 12345678/* This function is called when new metadata is discovered in the stream */static void tags_cb (GstElement *playbin, gint stream, CustomData *data) &#123; /* We are possibly in a GStreamer working thread, so we notify the main * thread of this event through a message in the bus */ gst_element_post_message (playbin, gst_message_new_application (GST_OBJECT (playbin), gst_structure_new_empty ("tags-changed")));&#125; 这里是该例的重点。当媒体中发现新标签时，该函数将会从streaming线程中调用，即从一个应用程序线程(或主线程)之外的线程调用。我们这里希望做的是更新GTK+的部件来反映这个新的信息，但GTK+不允许主线程之外的其它线程的操作。解决方法是让playbin在总线上发布消息并返回给调用线程。在适当时候，主线程会接收到这个消息并更新GTK。gst_element_post_message函数使GStreamer元素将给定的消息发送到总线。gst_message_new_application函数创建一个新的应用程序类型的消息。GStreamer消息有不同的类型，且这种特殊类型将保留给应用程序:它会通过不受GStreamer影响的总线。类型列表可在GstMessageType文档中找到。消息可以通过嵌入的GstStructure提供额外的信息，GstStructure是一个非常灵活的数据容器。这里使用gst_structure_new创建一个新结构体，并将其命名为tags-changed，以避免在我们想发送其它应用程序消息时发生混淆。然后，一旦在主线程中，总线将会收到这个消息并发送message::application信号，该信号与application_cb函数关联:123456789/* This function is called when an "application" message is posted on the bus. * Here we retrieve the message posted by the tags_cb callback */static void application_cb (GstBus *bus, GstMessage *msg, CustomData *data) &#123; if (g_strcmp0 (gst_structure_get_name (gst_message_get_structure (msg)), "tags-changed") == 0) &#123; /* If the message is the "tags-changed" (only one we are currently issuing), update * the stream info GUI */ analyze_streams (data); &#125;&#125; 一旦确定它是标签变化(tag-changed)消息，则调用analyze_streams函数。其基本上从流中恢复标签，并将其写入GUI中的文本小部件中。虽然该例代码量较大，但所需的概念很少且很容易。最后效果图如下:]]></content>
      <categories>
        <category>TX1入坑</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GStreamer</tag>
        <tag>TX1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GStreamer笔记三: Time Management]]></title>
    <url>%2Fposts%2F58b8a847%2F</url>
    <content type="text"><![CDATA[主要是关于如何使用GStreamer中的时间相关工具，如查询Pipeline的位置或者持续时间等信息，以及寻找或者跳转到Stream中的不同位置——时间点的方法。 关于GstQueryGstQuery是GStreamer中用于查询element和pad信息的一种机制。此篇所用例中首先需要询问是否支持寻找(seek)，因为有一些源，如live stream，并不支持跳转。本例在确定支持跳转后，一旦电影播放10s后，就是用seek函数跳转到一个不同的时间点。在之前的例子中，一旦建立其了Pipeline并开始运行，主函数所做的事仅仅是坐等接收来自总线(bus)的ERROR或者EOS信息。这里将会修改这个函数来周期性的唤醒并查询Pipeline的位置，所以可以将其输出在屏幕上。有点类似于一个媒体播放器定期更新用户接口。最终，在stream持续时间改变后就会重新查询和更新。 Seeking示例一个有关seeking时间点的示例如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;gst/gst.h&gt;/* Structure to contain all our information, so we can pass it around */typedef struct _CustomData &#123; GstElement *playbin; /* Our one and only element */ gboolean playing; /* Are we in the PLAYING state? */ gboolean terminate; /* Should we terminate execution? */ gboolean seek_enabled; /* Is seeking enabled for this media? */ gboolean seek_done; /* Have we performed the seek already? */ gint64 duration; /* How long does this media last, in nanoseconds */&#125; CustomData;/* Forward definition of the message processing function */static void handle_message (CustomData *data, GstMessage *msg);int main(int argc, char *argv[]) &#123; CustomData data; GstBus *bus; GstMessage *msg; GstStateChangeReturn ret; data.playing = FALSE; data.terminate = FALSE; data.seek_enabled = FALSE; data.seek_done = FALSE; data.duration = GST_CLOCK_TIME_NONE; /* Initialize GStreamer */ gst_init (&amp;argc, &amp;argv); /* Create the elements */ data.playbin = gst_element_factory_make ("playbin", "playbin"); if (!data.playbin) &#123; g_printerr ("Not all elements could be created.\n"); return -1; &#125; /* Set the URI to play */ g_object_set (data.playbin, "uri", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm", NULL); /* Start playing */ ret = gst_element_set_state (data.playbin, GST_STATE_PLAYING); if (ret == GST_STATE_CHANGE_FAILURE) &#123; g_printerr ("Unable to set the pipeline to the playing state.\n"); gst_object_unref (data.playbin); return -1; &#125; /* Listen to the bus */ bus = gst_element_get_bus (data.playbin); do &#123; msg = gst_bus_timed_pop_filtered (bus, 100 * GST_MSECOND, GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS | GST_MESSAGE_DURATION); /* Parse message */ if (msg != NULL) &#123; handle_message (&amp;data, msg); &#125; else &#123; /* We got no message, this means the timeout expired */ if (data.playing) &#123; gint64 current = -1; /* Query the current position of the stream */ if (!gst_element_query_position (data.playbin, GST_FORMAT_TIME, &amp;current)) &#123; g_printerr ("Could not query current position.\n"); &#125; /* If we didn't know it yet, query the stream duration */ if (!GST_CLOCK_TIME_IS_VALID (data.duration)) &#123; if (!gst_element_query_duration (data.playbin, GST_FORMAT_TIME, &amp;data.duration)) &#123; g_printerr ("Could not query current duration.\n"); &#125; &#125; /* Print current position and total duration */ g_print ("Position %" GST_TIME_FORMAT " / %" GST_TIME_FORMAT "\r", GST_TIME_ARGS (current), GST_TIME_ARGS (data.duration)); /* If seeking is enabled, we have not done it yet, and the time is right, seek */ if (data.seek_enabled &amp;&amp; !data.seek_done &amp;&amp; current &gt; 10 * GST_SECOND) &#123; g_print ("\nReached 10s, performing seek...\n"); gst_element_seek_simple (data.playbin, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, 30 * GST_SECOND); data.seek_done = TRUE; &#125; &#125; &#125; &#125; while (!data.terminate); /* Free resources */ gst_object_unref (bus); gst_element_set_state (data.playbin, GST_STATE_NULL); gst_object_unref (data.playbin); return 0;&#125;static void handle_message (CustomData *data, GstMessage *msg) &#123; GError *err; gchar *debug_info; switch (GST_MESSAGE_TYPE (msg)) &#123; case GST_MESSAGE_ERROR: gst_message_parse_error (msg, &amp;err, &amp;debug_info); g_printerr ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message); g_printerr ("Debugging information: %s\n", debug_info ? debug_info : "none"); g_clear_error (&amp;err); g_free (debug_info); data-&gt;terminate = TRUE; break; case GST_MESSAGE_EOS: g_print ("End-Of-Stream reached.\n"); data-&gt;terminate = TRUE; break; case GST_MESSAGE_DURATION: /* The duration has changed, mark the current one as invalid */ data-&gt;duration = GST_CLOCK_TIME_NONE; break; case GST_MESSAGE_STATE_CHANGED: &#123; GstState old_state, new_state, pending_state; gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state); if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;playbin)) &#123; g_print ("Pipeline state changed from %s to %s:\n", gst_element_state_get_name (old_state), gst_element_state_get_name (new_state)); /* Remember whether we are in the PLAYING state or not */ data-&gt;playing = (new_state == GST_STATE_PLAYING); if (data-&gt;playing) &#123; /* We just moved to PLAYING. Check if seeking is possible */ GstQuery *query; gint64 start, end; query = gst_query_new_seeking (GST_FORMAT_TIME); if (gst_element_query (data-&gt;playbin, query)) &#123; gst_query_parse_seeking (query, NULL, &amp;data-&gt;seek_enabled, &amp;start, &amp;end); if (data-&gt;seek_enabled) &#123; g_print ("Seeking is ENABLED from %" GST_TIME_FORMAT " to %" GST_TIME_FORMAT "\n", GST_TIME_ARGS (start), GST_TIME_ARGS (end)); &#125; else &#123; g_print ("Seeking is DISABLED for this stream.\n"); &#125; &#125; else &#123; g_printerr ("Seeking query failed."); &#125; gst_query_unref (query); &#125; &#125; &#125; break; default: /* We should not reach here */ g_printerr ("Unexpected message received.\n"); break; &#125; gst_message_unref (msg);&#125; 该段代码会打开并显示一个伴有音频的一个电影，由于媒体来自于网络，所以窗口可能需要一会才能显示出来，具体取决于网速。并在电影十秒钟后跳转到一个新的位置。 代码分析首先建立一个可以传递给其他函数的含有所有信息的结构体: 123456789101112/* Structure to contain all our information, so we can pass it around */typedef struct _CustomData &#123; GstElement *playbin; /* Our one and only element */ gboolean playing; /* Are we in the PLAYING state? */ gboolean terminate; /* Should we terminate execution? */ gboolean seek_enabled; /* Is seeking enabled for this media? */ gboolean seek_done; /* Have we performed the seek already? */ gint64 duration; /* How long does this media last, in nanoseconds */&#125; CustomData;/* Forward definition of the message processing function */static void handle_message (CustomData *data, GstMessage *msg); 这里由于信息处理代码会变得越来越大，因此将其移到了handle_message函数中。然后建立了一个包含单个元素(playbin)的Pipeline，然而playbin本身就是一个Pipeline，而且这种情况下，他是Pipeline中唯一的element，所以直接使用playbin。这里跳过一些细节:该clip的URI通过URI属性给playbin，并将Pipeline设置为播放状态。 12msg = gst_bus_timed_pop_filtered (bus, 100 * GST_MSECOND, GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS | GST_MESSAGE_DURATION); 之前没有给gst_bus_timed_pop_filtered函数提供超时参数，因此它在收到消息前不会返回。这里使用100ms的超时，所以如果在0.1s内没有收到任何消息，函数将返回NULL，并通过这个方法来更新UI。需要注意的是，所有的超时时间必须指定为GstClockTime，所以都是以纳秒为单位的，表示不同时间单位的数字应该乘以宏如GST_SECOND或GST_MSECOND。也能使代码更具可读性。如果收到消息，则通过handle_message函数处理它。否则刷新用户接口(UI)。 用户接口刷新12/* We got no message, this means the timeout expired */if (data.playing) &#123; 如果Pipeline处于PLAYING状态，则刷新屏幕。在非PLAYING状态下我们不想做任何事，因为大多数查询都会失败。这里的刷新率大约是每秒10次，对于我们的UI来说已经足够。同时将在屏幕上打印出当前媒体的位置以便了解管道查询。这涉及到几个步骤，之后再说，但是位置和持续时间是比较常见的查询，所以GStreamer提供了更容易的现成的备选方案: 1234/* Query the current position of the stream */if (!gst_element_query_position (data.pipeline, GST_FORMAT_TIME, &amp;current)) &#123; g_printerr ("Could not query current position.\n");&#125; 其中，gst_element_query_position函数隐藏了查询对象的管理并直接提供结果。123456/* If we didn't know it yet, query the stream duration */if (!GST_CLOCK_TIME_IS_VALID (data.duration)) &#123; if (!gst_element_query_duration (data.pipeline, GST_FORMAT_TIME, &amp;data.duration)) &#123; g_printerr ("Could not query current duration.\n"); &#125;&#125; 其中，gst_element_query_duration用于函数查询流的长度。123/* Print current position and total duration */g_print ("Position %" GST_TIME_FORMAT " / %" GST_TIME_FORMAT "\r", GST_TIME_ARGS (current), GST_TIME_ARGS (data.duration)); 这里使用GST_TIME_FORMAT和GST_TIME_ARGS宏来提供对GStreamer时间的对用户友好的表示。 1234567/* If seeking is enabled, we have not done it yet, and the time is right, seek */if (data.seek_enabled &amp;&amp; !data.seek_done &amp;&amp; current &gt; 10 * GST_SECOND) &#123; g_print ("\nReached 10s, performing seek...\n"); gst_element_seek_simple (data.pipeline, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, 30 * GST_SECOND); data.seek_done = TRUE;&#125; 现在在管道上调用gst_element_seek_simple函数进行查找，这种方法的好处是隐藏了许多复杂的问题。 参数回顾GST_FORMAT_TIME: 表示以时间单位指定目标位置，其他的查找格式使用不同的单位。然后是一些GstSeekFlags，其中常见的一些如下: GST_SEEK_FLAG_FLUSH: 会在seek之前丢弃当前Pipeline中的所有数据。当Pipeline被重新填充且新的数据开始出现时，可能会暂停一下，但是极大增加了应用程序的响应能力。因为如果没有这个标志，旧数据可能会一直显示，直到新的数据出现在Pipeline末端。 GST_SEEK_FLAG_KEY_UNIT: 对于大多数编码视频流，寻找到任意位置是不可能的，因为仅限于某些称为关键帧的帧。使用这个标识时，seek操作实际上会移动到最近的关键帧并开始产生数据。不使用这个标志的话，Pipeline将会在内部移动到最近的关键帧(没有其他选择)，但是直到到达要求的位置才会显示数据。后面一种方法更精确，但是可能需要更长的时间。 GST_SEEK_FLAG_ACCURATE: 查找精度标识。在一些媒体clips没有提供足够的索引信息时，查找任意位置是耗时的。在这些情况下，GStreamer通常会估计要寻找的位置，而且完成的比较好。如果这个精度对于你的情况来说不够好(看到的不是要求的精确时间)，则提供该标识。但是值得注意的是，计算寻找位置可能花费更长时间(在一些文件中很长)。最后提供了查找的位置。因为要求了GST_FORMAT_TIME,所以值需要用纳秒表示。为了简单起见，用秒表示时间并乘以GST_SECOND。 信息处理handle_message函数通过管道总线(Pipeline’s bus)处理接收到的所有信息。ERROR和EOS处理之前已经说过了，所以直接跳到感兴趣的部分:1234case GST_MESSAGE_DURATION: /* The duration has changed, mark the current one as invalid */ data-&gt;duration = GST_CLOCK_TIME_NONE; break; 该消息在流的持续时间变化时会发送给总线。这里简单地将当前持续时间标记为无效，所以稍后会被重新查询。123456789case GST_MESSAGE_STATE_CHANGED: &#123; GstState old_state, new_state, pending_state; gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state); if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;pipeline)) &#123; g_print ("Pipeline state changed from %s to %s:\n", gst_element_state_get_name (old_state), gst_element_state_get_name (new_state)); /* Remember whether we are in the PLAYING state or not */ data-&gt;playing = (new_state == GST_STATE_PLAYING); 在PAUSED和PLAYING状态下，搜索和查询操作通常只会得到一个有效的回复，因为所有元素都有机会接收信息并进行自我配置。这里使用playing变量来跟踪管道是否处于PLAYING状态。如果刚刚进入了PLAYING状态，则执行第一次查询。然后询问Pipeline是否允许在此流上进行搜索:12345678910111213141516171819if (data-&gt;playing) &#123; /* We just moved to PLAYING. Check if seeking is possible */ GstQuery *query; gint64 start, end; query = gst_query_new_seeking (GST_FORMAT_TIME); if (gst_element_query (data-&gt;pipeline, query)) &#123; gst_query_parse_seeking (query, NULL, &amp;data-&gt;seek_enabled, &amp;start, &amp;end); if (data-&gt;seek_enabled) &#123; g_print ("Seeking is ENABLED from %" GST_TIME_FORMAT " to %" GST_TIME_FORMAT "\n", GST_TIME_ARGS (start), GST_TIME_ARGS (end)); &#125; else &#123; g_print ("Seeking is DISABLED for this stream.\n"); &#125; &#125; else &#123; g_printerr ("Seeking query failed."); &#125; gst_query_unref (query);&#125; 这里gst_query_new_seeking函数使用GST_FORMAT_TIME格式创建了一个新的“seeking”类型的查询对象。这表明我们有兴趣通过指定想要移动的新时间来寻找。也可以使用GST_FORMAT_BYTE格式，然后在源文件中查找特定的字节位置，不过通常不太实用。然后gst_element_query函数将查询对象传递给Pipeline，并将结果存储在同一个查询中，因此可以通过gst_query_parse_seeking函数方便的检索。它提取出一个表示是否允许查询的布尔值和可查找的范围。最后在完成查询后释放查询对象。通过这些过程基本上可以建立一个媒体播放器，根据当前流的位置定期更新一个滑块，并允许通过滑块进行搜索或跳转。]]></content>
      <categories>
        <category>TX1入坑</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GStreamer</tag>
        <tag>TX1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GStreamer笔记二: Dynamic Pipeline]]></title>
    <url>%2Fposts%2F24b1a5e1%2F</url>
    <content type="text"><![CDATA[主要也是关于建立Pipeline的，不过主要目的是建立动态的Pipeline，即在信息可用时随时创建Pipeline，而不是在应用程序开始时候定义单一Pipeline。 一些基本概念的重申本次尝试: 将Pipeline在其未完全建立起来时设置为Playing状态。虽然这并没有什么问题，如果不做任何动作，当数据到达Pipeline末端时将会由Pipeline产生一个error并停止，所以尝试会采取进一步的操作。尝试打开一个多路复用(muxed)的文件，即视频和音频存在一个容器文件中。负责打开该容器的元素称之为分离器(demuxers)。容器格式例如: MKV(Matroska), QT/MOV(Quick Time), Ogg或高级系统格式如ASF, WMV, WMA等。 pad如前所述，pad就是Gstreamer元素间互相通信的一个接口，也有人翻译为衬垫。数据通过sink pad流入，通过source pad流出。只包含source pad的称之为source元素，只包含sink pad的元素称为sink元素，两者兼有则称之为filter元素。如图所示: 分离器如果一个容器嵌入多个流（例如一个视频和两个音频轨道），则分离器将分离它们并将其展示于不同的输出端口。通过这种方式，可以在流水线中创建不同的分支，处理不同类型的数据。一个含有两个source pad和一个sink pad的分离器的例子如图所示: 使用分离器的一个Pipeline例子如下: 该例是一个基本的Ogg播放器的Gstreamer Pipeline。处理分离器的主要复杂性在于，只有在接收到一些数据且有机会查看容器并看到其内部信息之后，才能产生信息。即分离器开始时，没有任何其他元素能连接的source pad，因此Pipeline必须终止它们。解决方法是建立一个从source向下到分离器的一个Pipeline，并将其设置为运行(Play)。当分离器了解了关于容器中数据流的数目和种类的足够信息之后，其会开始创建source pads。此时即是完成Pipeline创建并将其添加到新的分离器pads上的最佳时机。简单起见，所用例子仅连接到audio pad，忽略video pad。 动态建立示例一个动态的HelloWorld示例代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;gst/gst.h&gt;/* Structure to contain all our information, so we can pass it to callbacks */typedef struct _CustomData &#123; GstElement *pipeline; GstElement *source; GstElement *convert; GstElement *sink;&#125; CustomData;/* Handler for the pad-added signal */static void pad_added_handler (GstElement *src, GstPad *pad, CustomData *data);int main(int argc, char *argv[]) &#123; CustomData data; GstBus *bus; GstMessage *msg; GstStateChangeReturn ret; gboolean terminate = FALSE; /* Initialize GStreamer */ gst_init (&amp;argc, &amp;argv); /* Create the elements */ data.source = gst_element_factory_make ("uridecodebin", "source"); data.convert = gst_element_factory_make ("audioconvert", "convert"); data.sink = gst_element_factory_make ("autoaudiosink", "sink"); /* Create the empty pipeline */ data.pipeline = gst_pipeline_new ("test-pipeline"); if (!data.pipeline || !data.source || !data.convert || !data.sink) &#123; g_printerr ("Not all elements could be created.\n"); return -1; &#125; /* Build the pipeline. Note that we are NOT linking the source at this * point. We will do it later. */ gst_bin_add_many (GST_BIN (data.pipeline), data.source, data.convert , data.sink, NULL); if (!gst_element_link (data.convert, data.sink)) &#123; g_printerr ("Elements could not be linked.\n"); gst_object_unref (data.pipeline); return -1; &#125; /* Set the URI to play */ g_object_set (data.source, "uri", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm", NULL); /* Connect to the pad-added signal */ g_signal_connect (data.source, "pad-added", G_CALLBACK (pad_added_handler), &amp;data); /* Start playing */ ret = gst_element_set_state (data.pipeline, GST_STATE_PLAYING); if (ret == GST_STATE_CHANGE_FAILURE) &#123; g_printerr ("Unable to set the pipeline to the playing state.\n"); gst_object_unref (data.pipeline); return -1; &#125; /* Listen to the bus */ bus = gst_element_get_bus (data.pipeline); do &#123; msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS); /* Parse message */ if (msg != NULL) &#123; GError *err; gchar *debug_info; switch (GST_MESSAGE_TYPE (msg)) &#123; case GST_MESSAGE_ERROR: gst_message_parse_error (msg, &amp;err, &amp;debug_info); g_printerr ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message); g_printerr ("Debugging information: %s\n", debug_info ? debug_info : "none"); g_clear_error (&amp;err); g_free (debug_info); terminate = TRUE; break; case GST_MESSAGE_EOS: g_print ("End-Of-Stream reached.\n"); terminate = TRUE; break; case GST_MESSAGE_STATE_CHANGED: /* We are only interested in state-changed messages from the pipeline */ if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data.pipeline)) &#123; GstState old_state, new_state, pending_state; gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state); g_print ("Pipeline state changed from %s to %s:\n", gst_element_state_get_name (old_state), gst_element_state_get_name (new_state)); &#125; break; default: /* We should not reach here */ g_printerr ("Unexpected message received.\n"); break; &#125; gst_message_unref (msg); &#125; &#125; while (!terminate); /* Free resources */ gst_object_unref (bus); gst_element_set_state (data.pipeline, GST_STATE_NULL); gst_object_unref (data.pipeline); return 0;&#125;/* This function will be called by the pad-added signal */static void pad_added_handler (GstElement *src, GstPad *new_pad, CustomData *data) &#123; GstPad *sink_pad = gst_element_get_static_pad (data-&gt;convert, "sink"); GstPadLinkReturn ret; GstCaps *new_pad_caps = NULL; GstStructure *new_pad_struct = NULL; const gchar *new_pad_type = NULL; g_print ("Received new pad '%s' from '%s':\n", GST_PAD_NAME (new_pad), GST_ELEMENT_NAME (src)); /* If our converter is already linked, we have nothing to do here */ if (gst_pad_is_linked (sink_pad)) &#123; g_print (" We are already linked. Ignoring.\n"); goto exit; &#125; /* Check the new pad's type */ new_pad_caps = gst_pad_query_caps (new_pad, NULL); new_pad_struct = gst_caps_get_structure (new_pad_caps, 0); new_pad_type = gst_structure_get_name (new_pad_struct); if (!g_str_has_prefix (new_pad_type, "audio/x-raw")) &#123; g_print (" It has type '%s' which is not raw audio. Ignoring.\n", new_pad_type); goto exit; &#125; /* Attempt the link */ ret = gst_pad_link (new_pad, sink_pad); if (GST_PAD_LINK_FAILED (ret)) &#123; g_print (" Type is '%s' but link failed.\n", new_pad_type); &#125; else &#123; g_print (" Link succeeded (type '%s').\n", new_pad_type); &#125;exit: /* Unreference the new pad's caps, if we got them */ if (new_pad_caps != NULL) gst_caps_unref (new_pad_caps); /* Unreference the sink pad */ gst_object_unref (sink_pad);&#125; 该示例代码仅播放音频，由于是在线媒体，所以连接速度会与网速有关。 代码分析首先定义了一个结构体:1234567/* Structure to contain all our information, so we can pass it to callbacks */typedef struct _CustomData &#123; GstElement *pipeline; GstElement *source; GstElement *convert; GstElement *sink;&#125; CustomData; 简单情况下，通常可以使用一个局部变量(一个GstElement类型的基本指针)来表示所需要的信息。但大多数情况下（包括该例）是涉及到回调的，所以将其放在一个结构体中以便处理。12/* Handler for the pad-added signal */static void pad_added_handler (GstElement *src, GstPad *pad, CustomData *data); 此处是一个添加pad的前置函数声明。1234/* Create the elements */data.source = gst_element_factory_make ("uridecodebin", "source");data.convert = gst_element_factory_make ("audioconvert", "convert");data.sink = gst_element_factory_make ("autoaudiosink", "sink"); 该段是创建Element的代码。其中:uridecodebin通过将uri转化为原始音频或视频流来实例化所有的必要Element(source, 分离器，解码器)，其所做的是playbin的一半。由于含有分离器，其source pads最初并不可用，而且我们需要随时将其连接起来。audioconvert对于转换不同格式的音频很实用，由于解码器生成的格式可能和audio sink期望的不一样，所以为了确保其可以在任何平台上工作，使用audioconvert进行转换。autoaudiosink在音频中类似于视频中的autovideosink，其将会把音频流送给声卡。 12345if (!gst_element_link (data.convert, data.sink)) &#123; g_printerr ("Elements could not be linked.\n"); gst_object_unref (data.pipeline); return -1;&#125; 此处主要作用是将转换元素连接到sink，但是由于其不含source pads，所以没有将其连接到source上，仅仅是保持该分支(转换器+sink)为未连接状态，待后续处理。 12/* Set the URI to play */g_object_set (data.source, "uri", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm", NULL); 这里通过设置文件uri属性方法来播放它们。 信号GSignals是GStreamer中的一个关键部分。当一些你感兴趣的事发生时，它允许你通过回调的方式获得通知。信号(Signals)由名称标识，且每个GObject都有自己的signals。12/* Connect to the pad-added signal */g_signal_connect (data.source, "pad-added", G_CALLBACK (pad_added_handler), &amp;data); 该行代码将一个”pad added”信号附加到我们的source(一个uridecoderbin元素)上。为此使用了g_signal_connect函数，并提供要使用的回调函数pad_add_handler和一个数据指针。GStreamer并未对数据指针做任何事，仅仅将它转发给回调函数，因此可以与其共享信息。在这种情况下，我们传递一个指向我们专门为此建立的一个结构体CustomData的指针。GStreamer产生的信号可以通过其文档或者使用gst-inspect-1.0工具查询。至此已经准备好了，只需要将Pipeline设置为PLAYING状态并开始监听总线(bus)上感兴趣的Message(如ERROR或EOS)。 回调函数当source element有了足够的信息开始产生数据时，将会创建source pads，并触发“pad-added”信号。此时，回调函数就会被调用: 1static void pad_added_handler (GstElement *src, GstPad *new_pad, CustomData *data) &#123; 其中，信号处理的第一个参数始终是触发它的对象。src是触发这个信号的GstElement。此例中，它只能是uridecodebin，因为它是我们唯一附加的信号。new_pad是刚刚添加到src element的GstPad, 通常是我们想要连接的pad。data是我们附加到信号时提供的指针，例中用其传递CustomData指针。 1GstPad *sink_pad = gst_element_get_static_pad (data-&gt;convert, "sink"); 从CustomData中提取转换元素，然后使用gst_element_get_static_pad函数取回其sink pad。这是我们希望连接到new_pad的pad。之前涉及的简单例子中直接将元素连接到元素，并由GStreamer选择合适的pad。现在我们直接将这些pad连接起来。 12345/* If our converter is already linked, we have nothing to do here */if (gst_pad_is_linked (sink_pad)) &#123; g_print (" We are already linked. Ignoring.\n"); goto exit;&#125; uridecodebin可以创建尽可能多的pad，而且每个pad都会调用这个回调函数。该行代码主要作用是阻止我们尝试连接到已经连接了的pad上。 12345678/* Check the new pad's type */new_pad_caps = gst_pad_query_caps (new_pad, NULL);new_pad_struct = gst_caps_get_structure (new_pad_caps, 0);new_pad_type = gst_structure_get_name (new_pad_struct);if (!g_str_has_prefix (new_pad_type, "audio/x-raw")) &#123; g_print (" It has type '%s' which is not raw audio. Ignoring.\n", new_pad_type); goto exit;&#125; 现在将会检查这个新pad要输出的数据类型，因为我们仅对产生音频的pad有兴趣。之前已经创建了一个处理音频的Pipeline(一个autoaudioconver连接到一个autoaudiosink)，例中我们将不能将其连接到产生视频的pad上。gst_pad_query_caps函数查询或检索pad的功能(这是一种它所支持的数据，封装在GstCaps结构体中)，一个pad可以提供许多功能(cap)，因此GstCap可能包含多个GstStructure，且每个表示不同的功能。由于此例中我们知道我们想要的pad只有一个能力(audio)，所以使用gst_caps_get_structure函数获取第一个GstStructure。最后使用gst_structure_get_name函数获取包含格式(实际是媒体类型)的主要描述的结构体名称。如果名称不是audio/x-raw，这就不是解码的音频pad，也不是我们所感兴趣的。否则，尝试连接: 1234567/* Attempt the link */ret = gst_pad_link (new_pad, sink_pad);if (GST_PAD_LINK_FAILED (ret)) &#123; g_print (" Type is '%s' but link failed.\n", new_pad_type);&#125; else &#123; g_print (" Link succeeded (type '%s').\n", new_pad_type);&#125; 其中，gst_pad_link函数尝试连接这两个pad。和gst_element_link函数一样，连接必须指定有source到sink，且这两个pad必须属于同一个bin(或Pipeline)中的元素。至此已经基本完成，当出现一个正确类型的pad时，它将会被连接到音频处理Pipeline的其余部分，并执行且继续直到遇到ERROR或者EOS。但关于GStreamer的状态还是需要重申一下。 关于GStreamer States之前，已经解释过GStreamer的状态了，一共四种，如下所示: State Description NULL the NULL state or initial state of an element. READY the element is ready to go to PAUSED. PAUSED the element is PAUSED, it is ready to accept and process data. Sink elements however only accept one buffer and then block. PLAYING the element is PLAYING, the clock is running and the data is flowing. 四种状态只能在相邻状态之间移动，不能直接从NULL跳到PLAYING，必须经过中间的READY和PAUSED状态。但是如果将管道设置为PLAYIING状态，GStreamer将会为你进行中间转换。 123456789case GST_MESSAGE_STATE_CHANGED: /* We are only interested in state-changed messages from the pipeline */ if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data.pipeline)) &#123; GstState old_state, new_state, pending_state; gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state); g_print ("Pipeline state changed from %s to %s:\n", gst_element_state_get_name (old_state), gst_element_state_get_name (new_state)); &#125; break; 此段代码的添加主要用于监听关于状态更改的总线消息(bus message)，并将其打印在屏幕上以帮助了解这个转换。每个元素都将关于其当前状态的信息放在总线上，因此我们将其过滤出来，并只收听来自Pipeline的信息。大多数应用程序只需要关心去PLAYING来开始播放，然后PAUSED来暂停，然后在程序退出时返回NULL来释放所有资源。]]></content>
      <categories>
        <category>TX1入坑</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GStreamer</tag>
        <tag>TX1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GStreamer笔记一: GStreamer Concepts]]></title>
    <url>%2Fposts%2F8755e75b%2F</url>
    <content type="text"><![CDATA[笔记主要参照GStreamer官方tutorial，之前的一篇文章里最后一个例子写的是一个通过uri自动建立Pipeline的代码。这里主要内容是关于实例化每个元素并连接起来来手动建立Pipeline。 手动建立Pipeline基本代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;gst/gst.h&gt;int main(int argc, char *argv[]) &#123; GstElement *pipeline, *source, *sink; GstBus *bus; GstMessage *msg; GstStateChangeReturn ret; /* Initialize GStreamer */ gst_init (&amp;argc, &amp;argv); /* Create the elements */ source = gst_element_factory_make ("videotestsrc", "source"); sink = gst_element_factory_make ("autovideosink", "sink"); /* Create the empty pipeline */ pipeline = gst_pipeline_new ("test-pipeline"); if (!pipeline || !source || !sink) &#123; g_printerr ("Not all elements could be created.\n"); return -1; &#125; /* Build the pipeline */ gst_bin_add_many (GST_BIN (pipeline), source, sink, NULL); if (gst_element_link (source, sink) != TRUE) &#123; g_printerr ("Elements could not be linked.\n"); gst_object_unref (pipeline); return -1; &#125; /* Modify the source's properties */ g_object_set (source, "pattern", 0, NULL); /* Start playing */ ret = gst_element_set_state (pipeline, GST_STATE_PLAYING); if (ret == GST_STATE_CHANGE_FAILURE) &#123; g_printerr ("Unable to set the pipeline to the playing state.\n"); gst_object_unref (pipeline); return -1; &#125; /* Wait until error or EOS */ bus = gst_element_get_bus (pipeline); msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS); /* Parse message */ if (msg != NULL) &#123; GError *err; gchar *debug_info; switch (GST_MESSAGE_TYPE (msg)) &#123; case GST_MESSAGE_ERROR: gst_message_parse_error (msg, &amp;err, &amp;debug_info); g_printerr ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message); g_printerr ("Debugging information: %s\n", debug_info ? debug_info : "none"); g_clear_error (&amp;err); g_free (debug_info); break; case GST_MESSAGE_EOS: g_print ("End-Of-Stream reached.\n"); break; default: /* We should not reach here because we only asked for ERRORs and EOS */ g_printerr ("Unexpected message received.\n"); break; &#125; gst_message_unref (msg); &#125; /* Free resources */ gst_object_unref (bus); gst_element_set_state (pipeline, GST_STATE_NULL); gst_object_unref (pipeline); return 0;&#125; 编译时候可以通过pkg-config命令查询所需要的头文件和库文件，关于pkg的方法前面已有叙述，地址在此。 代码分析其基本流程图如下: 创建元素在初始化GStreamer后，首先需要创建元素，如上所示代码中的: 123/* Create the elements */source = gst_element_factory_make ("videotestsrc", "source");sink = gst_element_factory_make ("autovideosink", "sink"); 使用gst_element_factory_make函数创建，该函数第一个参数是需要创建的元素类型，第二个参数是给这个元素实例的名称，如果为空，GStreamer会自动生成一个特有的名称。此处创建了两个元素:videotestsrc和autovideosink。其中，videotestsrc属于source元素，通常用来产生或提供数据，经常用来创建一个测试用的模型。该元素在debug模式下或者教程中用得较多，实际应用中鲜有所闻。autovideosink属于sink元素，用于接受或者消费数据，将其接收到的图像展示在窗口中等。程序可以有多个video sink，这通常取决于操作系统。autovideosink会自动选择并实例化最好的一个，所以不用担心实现细节，代码对于平台是比较独立的。 创建管道创建了Element后则需要创建Pipeline，如上所示代码中的: 12/* Create the empty pipeline */pipeline = gst_pipeline_new ("test-pipeline"); 所有元素在使用前必须包含进一个Pipeline，因为需要关心其时钟和Message功能。通常使用gst_pipeline_new创建管道。 1234567/* Build the pipeline */gst_bin_add_many (GST_BIN (pipeline), source, sink, NULL);if (gst_element_link (source, sink) != TRUE) &#123; g_printerr ("Elements could not be linked.\n"); gst_object_unref (pipeline); return -1;&#125; Pipeline也是一种bin，一种特殊的bin，是一种包含了其他元素的元素。因此所有对bin适用的方法对Pipeline也同样适用。这里通过gst_bin_add_many函数添加多个元素到Pipeline，该函数接受多个元素，并添加到Pipeline中，以NULL结束。单个元素添加可使用gst_bin_add函数。然后就需要将这些元素连接起来，因为虽然添加进了管道，但只是说明了管道中元素的位置，并没有将各个元素连接起来，数据无法流动。这里通过gst_element_link将各个元素连接起来，该函数第一个参数是源元素，第二个参数是链接的目标元素，连接必须遵照数据流动方向建立。只有在同一个bin中的元素才能连接在一起，所以在连接之前必须先将其添加进Pipeline中。 属性操作如上代码中修改source的属性中的一段:12/* Modify the source's properties */g_object_set (source, "pattern", 0, NULL); 该行代码改变了videotestsrc元素的pattern属性，控制了测试视频元素的输出类型。绝大多数GStreamer元素都可以自定义其属性:可以通过修改名称属性来改变元素行为(可写属性)，或者通过查询来获取元素内部状态(可读属性)。通常使用g_object_get函数获取属性，通过g_objece_set函数设置属性。g_object_set函数接受一个以NULL结尾的属性名-属性值列表，所以可以一次性改变元素的属性。Gstreamer元素都是一种特殊的GObject(GLib对象系统，提供属性设备的实例)，所以属性处理方法都有一个带g_的前缀。所有元素的可用属性名和属性值可以通过gst-inspect工具获取。 错误检测剩余代码则是进行错误检测以增加程序的鲁棒性。如:1234567/* Start playing */ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);if (ret == GST_STATE_CHANGE_FAILURE) &#123; g_printerr ("Unable to set the pipeline to the playing state.\n"); gst_object_unref (pipeline); return -1;&#125; 在播放时候通过gst_element_set_state函数返回值来检测错误。再如:123456789101112131415161718192021222324252627/* Wait until error or EOS */bus = gst_element_get_bus (pipeline);msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);/* Parse message */if (msg != NULL) &#123; GError *err; gchar *debug_info; switch (GST_MESSAGE_TYPE (msg)) &#123; case GST_MESSAGE_ERROR: gst_message_parse_error (msg, &amp;err, &amp;debug_info); g_printerr ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message); g_printerr ("Debugging information: %s\n", debug_info ? debug_info : "none"); g_clear_error (&amp;err); g_free (debug_info); break; case GST_MESSAGE_EOS: g_print ("End-Of-Stream reached.\n"); break; default: /* We should not reach here because we only asked for ERRORs and EOS */ g_printerr ("Unexpected message received.\n"); break; &#125; gst_message_unref (msg);&#125; 其中，gst_bus_timed_pop_filtered函数等待执行结束并返回一个GstMessage。此处该函数在遇到错误或者到EOS状态时会返回，所以需要检测是什么原因导致函数返回的，因此通过下面的if语句对msg进行判断。GstMessage是一个非常通用的结构，可以提供几乎任何类型的信息。而且，GStreamer为每种消息提供了一系列的解析函数。通过使用宏定义函数GST_MESSAGE_TYPE可以知道Message包含的错误，然后通过gst_message_parse_error函数返回一个GLib Error的error结构体和一个字符串用于调试。 GStreamer总线GStreamer总线(bus)是一个简单的系统，负责将由元素生成的GstMessages传递给应用程序的对象，以及应用程序线程。实际的媒体流是在另一个线程中完成的，而不是应用程序。Message可以通过gst_bus_timed_pop_filtered()函数和其兄弟姐妹同步获取，也可以通过signal异步获取。应用程序应该始终关注总线，去获取错误以及其他回放相关的问题。]]></content>
      <categories>
        <category>TX1入坑</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GStreamer</tag>
        <tag>TX1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查询工具pkg-config]]></title>
    <url>%2Fposts%2Faad6181%2F</url>
    <content type="text"><![CDATA[在程序编译时候，通常需要引用外部库文件或者头文件，文件多了用gcc指定时候就显得麻烦，一个一个写在Makefile中也比较繁琐，这种情况下，能自动获取完整的依赖库信息就显得轻松不少了。 pkg-config简介及用法关于pkg-configpkg-config就是自动获取所需的库文件以及头文件的命令，原本设计用于Linux，不过后来其他系统如Win和Mac里也都有可用的版本。主要用于输出C/C++的编译器需要的参数，链接器需要的参数以及已经安装软件版本等信息。 主要用法其主要的命令参数以及解释如下: 123456789101112131415161718192021222324252627282930313233343536373839Usage: pkg-config [OPTION...]Help Options: -h, --help Show help optionsApplication Options: --version output version of pkg-config --modversion output version for package --atleast-pkgconfig-version=VERSION require given version of pkg-config --libs output all linker flags --static output linker flags for static linking --short-errors print short errors --libs-only-l output -l flags --libs-only-other output other libs (e.g. -pthread) --libs-only-L output -L flags --cflags output all pre-processor and compiler flags --cflags-only-I output -I flags --cflags-only-other output cflags not covered by the cflags-only-I option --variable=NAME get the value of variable named NAME --define-variable=NAME=VALUE set variable NAME to VALUE --exists return 0 if the module(s) exist --print-variables output list of variables defined by the module --uninstalled return 0 if the uninstalled version of one or more module(s) or their dependencies will be used --atleast-version=VERSION return 0 if the module is at least version VERSION --exact-version=VERSION return 0 if the module is at exactly version VERSION --max-version=VERSION return 0 if the module is at no newer than version VERSION --list-all list all known packages --debug show verbose debug information --print-errors show verbose information about missing or conflicting packages (default unless --exists or --atleast/exact/max-version given on the command line) --silence-errors be silent about errors (default when --exists or --atleast/exact/max-version given on the command line) --errors-to-stdout print errors from --print-errors to stdout not stderr --print-provides print which packages the package provides --print-requires print which packages the package requires --print-requires-private print which packages the package requires for static linking --validate validate a package's .pc file --define-prefix try to override the value of prefix for each .pc file found with a guesstimated value based on the location of the .pc file --dont-define-prefix don't try to override the value of prefix for each .pc file found with a guesstimated value based on the location of the .pc file --prefix-variable=PREFIX set the name of the variable that pkg-config automatically sets 其中用的比较多的就是--cflags和--libs。主要用来输出头文件和lib文件。如查找opencv头文件和lib库的位置: 1pkg-config --cflags --libs opencv 输出: 1-I/usr/local/include/opencv -I/usr/local/include -L/usr/local/lib -lopencv_cudabgsegm -lopencv_cudaobjdetect -lopencv_cudastereo -lopencv_stitching -lopencv_cudafeatures2d -lopencv_superres -lopencv_cudacodec -lopencv_videostab -lopencv_cudaoptflow -lopencv_cudalegacy -lopencv_cudawarping -lopencv_aruco -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_dpm -lopencv_freetype -lopencv_fuzzy -lopencv_line_descriptor -lopencv_optflow -lopencv_reg -lopencv_saliency -lopencv_stereo -lopencv_structured_light -lopencv_phase_unwrapping -lopencv_rgbd -lopencv_surface_matching -lopencv_tracking -lopencv_datasets -lopencv_text -lopencv_face -lopencv_plot -lopencv_dnn -lopencv_xfeatures2d -lopencv_shape -lopencv_video -lopencv_ximgproc -lopencv_calib3d -lopencv_features2d -lopencv_flann -lopencv_xobjdetect -lopencv_objdetect -lopencv_ml -lopencv_xphoto -lopencv_highgui -lopencv_videoio -lopencv_photo -lopencv_imgcodecs -lopencv_cudaimgproc -lopencv_cudafilters -lopencv_imgproc -lopencv_cudaarithm -lopencv_core -lopencv_cudev 再如Gstreamer的:1pkg-config --cflags --libs gstreamer-1.0 可以看到,1-pthread -I/usr/include/gstreamer-1.0 -I/usr/lib/x86_64-linux-gnu/gstreamer-1.0/include -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -lgstreamer-1.0 -lgobject-2.0 -lglib-2.0 关于路径的获取pkg-config获取路径是通过查询第三方库的pc文件实现的。比如:12cd /usr/local/lib/pkgconfigls 输出:12flann.pc libavdevice.pc libavformat.pc libswresample.pc opencv.pclibavcodec.pc libavfilter.pc libavutil.pc libswscale.pc pc文件内容通常包含Name, Description, Version, Libs, Cflags等基本参数。如opencv的pc文件内容是:1234567891011121314# Package Information for pkg-configprefix=/usr/localexec_prefix=$&#123;prefix&#125;libdir=$&#123;exec_prefix&#125;/libincludedir_old=$&#123;prefix&#125;/include/opencvincludedir_new=$&#123;prefix&#125;/includeName: OpenCVDescription: Open Source Computer Vision LibraryVersion: 3.2.0Libs: -L$&#123;exec_prefix&#125;/lib -lopencv_cudabgsegm -lopencv_cudaobjdetect -lopencv_cudastereo -lopencv_stitching -lopencv_cudafeatures2d -lopencv_superres -lopencv_cudacodec -lopencv_videostab -lopencv_cudaoptflow -lopencv_cudalegacy -lopencv_cudawarping -lopencv_aruco -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_dpm -lopencv_freetype -lopencv_fuzzy -lopencv_line_descriptor -lopencv_optflow -lopencv_reg -lopencv_saliency -lopencv_stereo -lopencv_structured_light -lopencv_phase_unwrapping -lopencv_rgbd -lopencv_surface_matching -lopencv_tracking -lopencv_datasets -lopencv_text -lopencv_face -lopencv_plot -lopencv_dnn -lopencv_xfeatures2d -lopencv_shape -lopencv_video -lopencv_ximgproc -lopencv_calib3d -lopencv_features2d -lopencv_flann -lopencv_xobjdetect -lopencv_objdetect -lopencv_ml -lopencv_xphoto -lopencv_highgui -lopencv_videoio -lopencv_photo -lopencv_imgcodecs -lopencv_cudaimgproc -lopencv_cudafilters -lopencv_imgproc -lopencv_cudaarithm -lopencv_core -lopencv_cudevLibs.private: -L/usr/lib/x86_64-linux-gnu -lpng -lz -ltiff -ljasper -ljpeg -lgtk-x11-2.0 -lgdk-x11-2.0 -lpangocairo-1.0 -latk-1.0 -lcairo -lgdk_pixbuf-2.0 -lgio-2.0 -lpangoft2-1.0 -lpango-1.0 -lgobject-2.0 -lglib-2.0 -lfontconfig -lfreetype -lgthread-2.0 -ldc1394 -lavcodec-ffmpeg -lavformat-ffmpeg -lavutil-ffmpeg -lswscale-ffmpeg -ldl -lm -lpthread -lrt -lcudart -lnppc -lnppi -lnpps -lcufft -L-L/usr/local/cuda -l64Cflags: -I$&#123;includedir_old&#125; -I$&#123;includedir_new&#125; 所以也可以以同样的方式添加自己的第三方库来简化编译工作。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GCC</tag>
        <tag>pkg-config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多媒体框架GStreamer]]></title>
    <url>%2Fposts%2F413bb42a%2F</url>
    <content type="text"><![CDATA[GStreamer is a library for constructing graphs of media-handling components. The applications it supports range from simple Ogg/Vorbis playback, audio/video streaming to complex audio (mixing) and video (non-linear editing) processing. GStreamer是一个轻便的多媒体框架，在TX1上默认并未提供V4L2驱动，需要手动安装，而且这个驱动是基于GStreamer的。此外，在TX1上支持的H.264和H.265硬解码也是通过GStreamer的。 基本概念PipelineGStreamer是通过管道和插件实现各种功能或构建各种流媒体应用的。管道的概念在shell中已经很常见了，不过GStreamer中的管道符号不是|而是!。GStreamer中将很多元素串联起来，类似管道的命令，将前者输出作为后者输入。如:1gst-launch-1.0 filesrc location=a.mp3 ! decodebin ! audioconvert ! alsasink 其中,每个元素说明如下: filesrc: 从本地磁盘加载了一个文件，使用该元素时你设置了location 属性指向该文件。 decodebin: 使用该元素从filesrc解码。会自动检测文件的类型并在后台构造一些GStreamer元素来解码。 audioconvert: 音频转换元素。 alsasink: 将音频使用ALSA传递给声卡。 Element元素是GStreamer内置可使用在管道上的命令，GStreamer通过各种元素完成任务。可以使用gst-inspect-1.0命令来查看可使用的元素。当创建Pipeline时，需要为各个Element设置各种属性。GStreamer将GstElement细分成如下几类： Source Element: 数据源元素。只有输出端，它仅能用来产生供管道消费的数据，而不能对数据做任何处理。一个典型的数据源元素的例子是音频捕获单元，它负责从声卡读取原始的音频数据，然后作为数据源提供给其它模块使用。 Filter Element: 过滤器元素。既有输入端又有输出端，它从输入端获得相应的数据，并在经过特殊处理之后传递给输出端。一个典型的过滤器元素的例子是音频编码单元，它首先从外界获得音频数据，然后根据特定的压缩算法对其进行编码，最后再将编码后的结果提供给其它模块使用。 Sink Element: 接收器元素。只有输入端，它仅具有消费数据的能力，是整条媒体管道的终端。一个典型的接收器元素的例子是音频回放单元，它负责将接收到的数据写到声卡上，通常这也是音频处理过程中的最后一个环节。 Pad一般元素都有输入输出接口，即pad。可将各个元素视作黑盒，则一般元素都有一个输入pad和输出pad，即过滤器元素。输入pad称为sink，输出pad称为src。管道命令模型基本如下:1[src] ! [sink src] ! [sink src] ! [sink] 最左边的元素只有一个src pad用来提供信息（如filesrc）。接下来的几个元素接收信息并做一些处理，因此他们有sink和src pad（例如decodebin和audiocovert），最后一个元素只接收信息（例如alsasink）。使用gst-inspect-1.0命令查看一个元素的详细信息时，就可以看到该元素的pad信息。 注意可能与平时大家认为的概念有些不同的是，src pad是用来发送数据的端点，即数据的 输出端；而sink pad是用来接收数据的端点，即数据的输入端。 一般来说，src pad只能连接到sink pad。但ghost pad两端就要连接相同类型的pad。 Cap每个元素的cap表示该元素可以接收什么样的信息，类似于V4L2中的cap。 BinGStreamer中的bin类似于c中的结构体，是可以存放多个元素的容器。例如管道是a ! b ! c ! d，可以把他们放进mybin，这样当使用mybin时其实是引用了a ! b ! c ! d。 Ghost pad从名字上来看，ghost pad即特殊的pad。 当你创建了一个bin并在里面放置了很多元素时，该bin变成了你自定义的元素，该元素按顺序调用里面的元素。要做到这样，bin很自然地需要它自己的pad，它自己的pad会挂接到bin里面元素的pad上，这就是 ghost pad了。当你创建一个bin时，你创建了ghost pad并告诉他们要去挂接里面哪一个元素。 MessageMessage是Pipeline用向外来主动报告自己的运行状态。Message会被发送到一个消息队列，即Pipeline的Bus。应用程序则是从Bus中获取message，并进行处理。 EventEvent是Pipeline用来通信的机制，分为上行、下行和双向Event。在定义了某个事件的响应后，也可以由应用程序直接向该插件(bin)发送事件。通过Event可以控制整个Pipeline的运行状态。 上行事件: 由sink插件向source插件方向传输。包括: 12GST_EVENT_QOSGST_EVENT_SEEK 下行事件: 由source插件向sink插件方向传输。包括: 12GST_EVENT_EOSGST_EVENT_NEWSEGMENT 双行事件:包括: 12GST_EVENT_FLUSH_STARTGST_EVENT_FLUSH_STOP SignalSignal是应用控制某一插件的运行状态，可以看做Glib对象的一个属性，属于同步操作，和Linux中的系统信号有差别。通过Signal可以让某个插件做一些对插件本身变量的操作，比如增加或删除一些维护信息等。 GStreamer程序处理可以使用c或Python，Python中需要import gi，c中使用include &lt;gst/gst.h&gt;等头文件。TX1中的GStreamer头文件可以在/usr/include/GStreamer-1.0目录下找到。 元素处理Elements是具有一定功能的基本单元，主要组成如下: 1234udpsrc: 接受UDP数据(source产生数据)rtph264depay: H264的RTP拆包(filter)。(rtp+h264包)-&gt;(h264包)mpegtsmux: 打ts包(filter)。(h264包)-&gt;(ts包)filesink: 将数据存入文件(sink消耗数据) 在应用程序中创建GstElement对象的方法是借助于工厂对象GstElementFactory。由于GStreamer框架提供了多种类型的GstElement对象，因此对应地提供了多种类型的GstElementFactory对象，它们是通过特定的工厂名称来进行区分的。如: 12GstElementFactory *factory;factory = gst_element_factory_find ("mad"); 该代码通过gst_element_factory_find()函数创建了一个名为mad的工厂对象。之后就可以通过gst_element_factory_create()函数来创建特定的GstElement对象了。12GstElement *element;element = gst_element_factory_create (factory, "decoder"); 函数gst_element_factory_create()在调用时有两个参数，分别是需要用到的工厂对象，以及即将创建的元素名。元素名可以用查询的办法获得，也可以通过传入空指针（NULL）来生成工厂对象的默认元素。 GStreamer使用了与GObject相同的机制来对属性（property）进行管理，包括查询（query）、设置（set）和读取（get）等。所有的GstElement对象都需要从其父对象GstObject那里继承名称（name）这一最基本的属性，这是因为像gst_element_factory_make()和gst_element_factory_create()这样的函数在创建工厂对象和元素对象时都会用到名称属性，通过调用gst_object_set_name()和gst_object_get_name()函数可以设置和读取GstElement对象的名称属性。 Pad处理成功创建GstElement对象之后，可以通过gst_element_get_pad()获得该元素的指定pad。例如，下面的代码将返回element元素中名为src的pad：12GstPad *srcpad;srcpad = gst_element_get_pad (element, "src"); 需要的话也可以通过gst_element_get_pad_list()函数来查询指定元素中的所有pad。例如，下面的代码将输出elemen元素中所有pad的名称：1234567GList *pads;pads = gst_element_get_pad_list (element);while (pads) &#123; GstPad *pad = GST_PAD (pads-&gt;data); g_print ("pad name is: %s\n", gst_pad_get_name (pad)); pads = g_list_next (pads);&#125; 与元素一样，pad的名称也能够动态设置或者读取，这是通过调用gst_pad_get_name()和gst_pad_set_name()函数来完成的。所有元素的pad都可以细分成输入pad和输出pad两种，其中输入pad只能接收数据但不能产生数据，而输出pad则正好相反。函数gst_pad_get_direction()可以获得指定pad的类型。GStreamer框架中的所有pad都必然依附于某个元素之上，调用gst_pad_get_parent()可以获得指定pad所属的元素，该函数的返回值是一个指向GstElement的指针。 Pad从某种程度上可以看成是元素的代言人，因为它要负责向外界描述该元素所具有的能力。GStreamer框架提供了统一的机制来让pad描述元素所具有的能力（capability），这是借助结构体_GstCaps来实现的：123456struct _GstCaps &#123; gchar *name; /* the name of this caps */ guint16 id; /* type id (major type) */ guint refcount; /* caps are refcounted */ GstProps *properties; /* properties for this capability */ GstCaps *next; /* caps can be chained together */ &#125;; GStreamer框架中的每个pad都可能对应于多个能力描述，它们能够通过函数gst_pad_get_caps()来获得。例如，下面的代码将输出pad中所有能力描述的名称及其MIME类型：123456789GstCaps *caps;caps = gst_pad_get_caps (pad);g_print ("pad name is: %s\n", gst_pad_get_name (pad));while (caps) &#123; g_print (" Capability name is %s, MIME type is %s\n", gst_caps_get_name (cap), gst_caps_get_mime (cap)); caps = caps-&gt;next;&#125; Bin处理在GStreamer应用程序中使用的bin主要有两种类型： GstPipeline 管道是最常用到的容器，对于一个GStreamer应用程序来讲，其顶层bin必须是一条管道。 GstThread 线程的作用在于能够提供同步处理能力，如果GStreamer应用程序需要进行严格的音视频同步，一般都需要用到这种类型的bin。 GStreamer框架提供了两种方法来创建bin：一种是借助工厂方法，另一种则是使用特定的函数。下面的代码示范了如何使用工厂方法创建线程对象，以及如何使用特定函数来创建管道对象：12345GstElement *thread, *pipeline;// 创建线程对象，同时为其指定唯一的名称。thread = gst_element_factory_make ("thread", NULL);// 根据给出的名称，创建一个特定的管道对象。pipeline = gst_pipeline_new ("pipeline_name"); Bin成功创建之后，就可以调用gst_bin_add()函数将已经存在的元素添加到其中来了：12345GstElement *element;GstElement *bin;bin = gst_bin_new ("bin_name");element = gst_element_factory_make ("mpg123", "decoder");gst_bin_add (GST_BIN (bin), element); 从bin中找到特定的元素可以借助gst_bin_get_by_name()函数实现： 12GstElement *element;element = gst_bin_get_by_name (GST_BIN (bin), "decoder"); 由于GStreamer框架中的一个bin能够添加到另一个bin中，因此有可能会出现嵌套bin的情况，gst_bin_get_by_name()函数在查找元素时会对嵌套的bin作递归查找。元素有添加到bin中后，在需要的时候还可以从中移出，通过调用gst_bin_remove()函数来完成： 12GstElement *element;gst_bin_remove (GST_BIN (bin), element); Ghost pad具有ghost pad的bin在行为上与元素是完全相同的，所有元素具有的属性它都具有，所有针对元素能够进行的操作也同样能够针对bin进行，因此在GStreamer应用程序中能够像使用元素一样使用这类bin。通常通过以下方式为bin添加一个ghost pad: 123456GstElement *bin;GstElement *element;element = gst_element_factory_create ("mad", "decoder");bin = gst_bin_new ("bin_name");gst_bin_add (GST_BIN (bin), element);gst_element_add_ghost_pad (bin, gst_element_get_pad (element, "sink"), "sink"); 元素连接GStreamer框架中的元素是通过各自的pad连接起来的，如下所示:1234567GstPad *srcpad, *sinkpad;srcpad = gst_element_get_pad (element1, "src");sinpad = gst_element_get_pad (element2, "sink");// 连接gst_pad_link (srcpad, sinkpad);// 断开gst_pad_unlink (srcpad, sinkpad); 如果需要建立起连接的元素都只有一个输入pad和一个输出pad，那么更简单的做法是调用gst_element_link()函数直接在它们之间建立起连接，或者调用gst_element_unlink()函数断开它们之间的连接：1234// 连接gst_element_link (element1, element2);// 断开gst_element_unlink (element1, element2); 元素状态每个元素一般会有四种状态: 标识 状态 NULL 这是所有元素的默认状态，表明它刚刚创建，还没有开始做任何事情。 READY 表明元素已经做好准备，随时可以开始处理流程。 PAUSED 表明元素因某种原因暂时停止处理数据。 PLAYING 表明元素正在进行数据处理。 所有的元素都从NULL状态开始，依次经历NULL、READY、PAUSED、PLAYING等状态间的转换。元素当前所处的状态可以通过调用gst_element_set_state()函数进行切换：123GstElement *bin;/* 创建元素，并将其连接成bin */gst_element_set_state (bin, GST_STATE_PLAYING); 默认情况下，管道及其包含的所有元素在创建之后将处于NULL状态，此时它们不会进行任何操作。当管道使用完毕之后，不要忘记重新将管道的状态切换回NULL状态，让其中包含的所有元素能够有机会释放它们正在占用的资源。管道真正的处理流程是从第一次将其切换到READY状态时开始的，此时管道及其包含的所有元素将做好相应的初始化工作，来为即将执行的数据处理过程做好准备。对于一个典型的元素来讲，处于READY状态时需要执行的操作包括打开媒体文件和音频设备等，或者试图与位于远端的媒体服务器建立起连接。处于READY状态的管道一旦切换到PLAYING状态，需要处理的多媒体数据就开始在整个管道中流动，并依次被管道中包含的各个元素进行处理，从而最终实现管道预先定义好的某种多媒体功能。GStreamer框架也允许将管道直接从NULL状态切换到PLAYING状态，而不必经过中间的READY状态。正处于播放状态的管道能够随时切换到PAUSED状态，暂时停止管道中所有数据的流动，并能够在需要的时候再次切换回PLAYING状态。如果需要插入或者更改管道中的某个元素，必须先将其切换到PAUSED或者NULL状态，元素在处于PAUSED状态时并不会释放其占用的资源。 Probe应用程序可以通过探针(Probe)来探测某个插件的pad中流过的数据，如:123456789101112131415161718/*******Callback handler when probe date received***********/static gboolean callback_have_data(GstPad *padsrc, GstBuffer *buffer, gpointer data)&#123; gint iBufSize = 0; gchar* pBuffer = NULL; iBufSize = GST_BUFFER_SIZE(buffer); pBuffer = (gchar*)GST_BUFFER_DATA(buffer); static gint numBuf = 0; g_print("\rBUF %d Size=%d ", numBuf++, iBufSize); return TRUE;&#125;GstPad *m_pad_concert_src = gst_element_get_static_pad(m_gst_convert, "src"); gst_pad_add_buffer_probe(m_pad_concert_src, G_CALLBACK(callback_have_data), NULL);gst_object_unref(m_pad_concert_src); 该代码在m_pad_concert插件的src pad加一个探针，每当有buf到达时，就调用callback_have_data(),这里这个函数只是打印一下buf的大小，统计一下buf流过的个数。 例子一个简单的程序:12345678910111213141516171819202122232425262728#include &lt;gst/gst.h&gt;int main(int argc, char *argv[]) &#123; GstElement *pipeline; GstBus *bus; GstMessage *msg; /* Initialize GStreamer */ gst_init (&amp;argc, &amp;argv); /* Build the pipeline */ pipeline = gst_parse_launch ("playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm", NULL); /* Start playing */ gst_element_set_state (pipeline, GST_STATE_PLAYING); /* Wait until error or EOS */ bus = gst_element_get_bus (pipeline); msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS); /* Free resources */ if (msg != NULL) gst_message_unref (msg); gst_object_unref (bus); gst_element_set_state (pipeline, GST_STATE_NULL); gst_object_unref (pipeline); return 0;&#125; 然后使用gcc进行编译，编译时需加上参数pkg-config --cflags --libs gstreamer-0.10。其中，gst_init (&amp;argc, &amp;argv)用于初始化所有内部结构，检查插件是否可用，以及执行用于GStreamer的命令参数。pipeline = gst_parse_launch (&quot;playbin2 uri=http://docs.GStreamer.com/media/sintel_trailer-480p.webm&quot;, NULL)中，gst_parse_launch函数接受一个管道的文本表示并把它变成一个实际的管道。playbin2是充当source和sink一个特殊的元素（element），并且能够实现整个管道。gst_element_set_state (pipeline, GST_STATE_PLAYING)函数设置Pipeline状态为播放状态。gst_element_get_bus (pipeline);函数获取管道的总线，gst_bus_timed_pop_filtered函数将阻塞，直到收到错误或EOS(End-Of-Stream)。]]></content>
      <categories>
        <category>TX1入坑</category>
      </categories>
      <tags>
        <tag>GStreamer</tag>
        <tag>TX1</tag>
        <tag>视频处理</tag>
        <tag>嵌入式开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的文件IO和多进程]]></title>
    <url>%2Fposts%2F360656f%2F</url>
    <content type="text"><![CDATA[Linux中的用户编程接口（API）遵循了UNIX中的应用编程界面标准——POSIX。这些系统调用编程接口主要是通过C库(libc)实现的。Linux中程序的运行空间主要分为内核空间和用户空间，通常用户能直接访问的是用户空间，内核空间一般通过系统调用才能访问。主要内容均来自于网络，仅作笔记之用，主要记录一下文件IO的一些基本API和多进程编程方式。 文件IO文件IO中的API主要是对文件的读写操作以及属性查询。主要API包括open,read,write,close,lseek,select和属性查询的stat。对于系统内核，所有操作的文件都是通过文件描述符引用的。文件描述符用一个非负整数表示，当程序打开或者创建文件时，内核向进程返回一个文件描述符用于继续操作；当写一个文件时，则是通过将文件描述符作为参数传递给操作文件的API用于继续处理。 在POSIX应用程序中，整数0、1、2应被代换成符号常数：STDIN_FILENO(标准输入，默认是键盘)STDOUT_FILENO(标准输出，默认是屏幕)STDERR_FILENO(标准错误输出，默认是屏幕) 这些常数都定义在头文件中，文件描述符的范围是0～OPEN_MAX。早期的UNIX版本采用的上限值是19（允许每个进程打开20个文件）， 现在很多系统则将其增加至256。可用的文件I\O函数很多，包括：打开文件，读文件，写文件等。大多数Linux文件I\O只需要用到5个函数：open，read，write，lseek以及close。 open功能说明需要包含的头文件: &lt;sys/types.h&gt;, &lt;sys/stat.h&gt;, &lt;fcntl.h&gt;函数原型:1int open(const str * pathname, int oflag, [..., mode_t mode]) 该函数主要用于打开文件，打开成功返回文件描述符，失败返回-1。 参数说明pathname: 文件的全路径名。mode: 对于open函数而言，仅当创建文件时才使用该参数，主要用于文件权限的设置。 oflag: 表示打开的一些方式,主要有O_RDONLY(只读打开)、O_WRONLY(只写打开)、O_RDWR(读写打开)和:O_APPEND: 追加到文件尾O_CREAT: 若文件不存在则创建它。使用此选择项时，需同时说明第三个参数mode，用其说明新文件的访问权限O_EXCL: 如果同时指定O_CREAT，而该文件又是存在的，报错；也可以测试一个文件是否存在，不存在则创建。O_TRUNC: 如果此文件存在，而且为读写或只写成功打开，则将其长度截短为0O_SYNC: 使每次write都等到物理I\O操作完成 例子创建文件: 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define FILE_PATH "./test.txt"int main(void)&#123; int fd; if ((fd = open(FILE_PATH, O_RDWR | O_CREAT | O_EXCL, 0666)) &lt; 0) &#123; printf("open error\n"); exit(-1); &#125; else &#123; printf("open success\n"); &#125; return 0;&#125; read功能说明主要用于读取文件数据。头文件: &lt;unistd.h&gt;函数原型:1ssize_t read(int fd, void * buf, size_t count) 返回实际读到的字节数，读到文件尾返回0，出错返回-1。其中ssize_t是在头文件中用typedef定义的，相当于signed int类型。 参数说明 fd：要读取的文件的描述符buf：得到的数据在内存中的位置的首地址count：期望本次能读取到的最大字节数。size_t是系统头文件中用typedef定义的数据类型，相当于unsigned int write功能说明和read对应，主要用于写入和修改文件。函数原型:1ssize_t write(int fd, const void * buf, size_t count) 返回实际写入的字节数，出错返回-1。 参数说明 fd：要写入文件的文件描述符buf：要写入文件的数据在内存中存放位置的首地址count：期望写入的数据的最大字节数 例子读写文件:read &amp;&amp; write1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; char buf[100]; int num = 0; // 获取键盘输入 if ((num = read(STDIN_FILENO, buf, 10)) == -1) &#123; printf ("read error"); error(-1); &#125; else &#123; // 输出到屏幕上 write(STDOUT_FILENO, buf, num); &#125; return 0;&#125; close功能说明主要用于关闭文件，头文件是unistd.h。函数原型:1int close(int filedes) 参数说明输入参数是需要关闭的文件的描述符。 当一个进程终止的时候，它所有的打开文件都是由内核自动关闭。很多程序都使用这一功能而不显式地调用close关闭一个已打开的文件。但是，作为一名优秀的程序员，应该显式的调用close来关闭已不再使用的文件。 lseek功能说明主要用来设置文件内容的读写位置，是用的较多的操作。需要包含头文件unistd.h和sys/types.h 每个打开的文件都有一个“当前文件偏移量”，是一个非负整数，用以度量从文件开始处计算的字节数。通常，读写操作都是从当前文件偏移量处开始，并使偏移量增加所读或写的字节数。默认情况下，你打开一个文件时(open)，除非指定O_APPEND参数，不然位移量被设为0。函数原型:1off_t lseek(int filesdes, off_t offset, int whence) 参数说明返回新的文件位移，出错返回-1。同样off_t是系统头文件定义的数据类型，相当于signed int。 whence是SEEK_SET, 那么该文件的位移量设置为据文件开始处offset个字节whence是SEEK_CUR, 那么该文件的位移量设置为当前值加offset。offset可为正或负whence是SEEK_END, 那么该文件的位移量设置为文件长度加offset。offset可为正或负 例子123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char * argv[])&#123; int fd; char buf[100]; if ((fd = open(argv[1], O_RDONLY)) &lt; 0) &#123; perror("open"); exit(-1); &#125; read(fd, buf, 1); write(STDOUT_FILENO, buf, 1); lseek(fd, 2, SEEK_CUR); read(fd, buf, 1); write(STDOUT_FILENO, buf, 1); lseek(fd, -1, SEEK_END); read(fd, buf, 1); write(STDOUT_FILENO, buf, 1); lseek(fd, 0, SEEK_SET); read(fd, buf, 1); write(STDOUT_FILENO, buf, 1); close(fd); printf("\n"); return 0;&#125; select功能说明用于同时监控多个文件描述符。因为read一次只能监控一个，且在监控过程中处于阻塞状态，无法同时监控多个输入。需要包含头文件sys/select.h。函数原型:1int select(int maxfd, fd_set \* readset, fd_set \* writeset, fd_set \* exceptset, const struct timeval \* timeout) 参数说明返回值：失败返回-1，成功返回readset，writeset，exceptset中所有，有指定变化的文件描述符的数目(若超时返回0) maxfd：要检测的描述符个数， 因此值应为最大描述符+1readset：被监控是否有输入的文件描述符集。不监控时，设为NULLwriteset：被监控是否可以输入的文件描述符集。不监控时，设为NULLexceptset：被监控是否有错误产生的文件描述符集。不监控时，设为NULLtimeval：监控超时时间。设置为NULL表示一直阻塞到有文件描述符被监控到有指定变化。 Tips:readset，writeset，exceptset这三个描述符集指针均是值—结果参数，调用的时候，被监控描述符相应位需要置1；返回时，未就绪的描数字相应位会被清0，而就绪的会被置1。下面的系统定义的宏，和select配套使用FD_ZERO(&amp;rset)：将文件描述符集rset的所有位清0FD_SET(4, &amp;reset)：设置文件描述符集rset的bit 4FD_CLR(fileno(stdin), &amp;rset)：将文件描述符集rset的bit 0清0FD_ISSET(socketfd, &amp;rset)：若文件描述符集rset中的socketfd位置1 例子1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;sys/select.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define MAXNUM 100#define OPEN_DEV "/dev/input/mice"int main(void)&#123; fd_set rfds; struct timeval tv; int retval, fd; char buf[MAXNUM]; fd = open(OPEN_DEV, O_RDONLY); while (1) &#123; FD_ZERO(&amp;rfds); FD_SET(0, &amp;rfds); FD_SET(fd, &amp;rfds); tv.tv_sec = 5; tv.tv_usec = 0; retval = select(fd+1, &amp;rfds, NULL, NULL, &amp;tv); if (retval &lt; 0) printf ("error\n"); if (retval == 0) printf ("No data within 5 seconds\n"); if (retval &gt; 0) &#123; if (FD_ISSET(0, &amp;rfds)) &#123; printf ("Data is available from keyboard now\n"); read(0, buf, MAXNUM); &#125; if (FD_ISSET(fd, &amp;rfds)) &#123; printf ("Data is available from mouse now\n"); read(fd, buf, MAXNUM); &#125; &#125; &#125; return 0;&#125; stat基本用法主要功能是获取文件的属性。需要包含头文件&lt;sys/types.h&gt;，&lt;sys/stat.h&gt;，&lt;unistd.h&gt;。函数原型:1int stat(const char \* path, struct stat \* buf) 参数说明 path：要查看属性的文件或目录的全路径名称。 buf：指向用于存放属性的结构体。stat成功调用后，buf的各个字段将存放各个属性。struct stat是系统头文件中定义的结构体，定义如下： 123456789101112131415struct stat &#123; dev_t st_dev; ino_t st_ino; mode_t st_mode; nlink_t st_nlink; uid_t st_uid; gid_t st_gid; dev_t st_rdev; off_t st_size; blksize_t st_blksize; blkcnt_t st_blocks; time_t st_atime; time_t st_mtime; time_t st_ctime;&#125;; st_ino：节点号st_mode：文件类型和文件访问权限被编码在该字段中st_nlink：硬连接数st_uid：属主的用户IDst_gid：所属组的组IDst_rdev：设备文件的主、次设备号编码在该字段中st_size：文件的大小st_mtime：文件最后被修改时间成功返回0，失败返回-1。 例子123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(int argc, char **argv)&#123; struct stat buf; if(argc != 2) &#123; printf("Usage: stat &lt;pathname&gt;"); exit(-1); &#125; if(stat(argv[1], &amp;buf) != 0) &#123; printf("stat error."); exit(-1); &#125; printf("#i-node: %ld\n", buf.st_ino); printf("#link: %d\n", buf.st_nlink); printf("UID: %d\n", buf.st_uid); printf("GID: %d\n", buf.st_gid); printf("Size %ld\n", buf.st_size); exit(0);&#125; 文件类型的判定struct stat中有个字段为st_mode，可用来获取文件类型和文件访问权限，可以从该字段解码我们需要的文件信息。 st_mode中文件类型宏定义：S_ISREG(): 普通文件S_ISDIR(): 目录文件S_ISCHR(): 字符设备文件S_ISBLK(): 块设备文件S_ISFIFO(): 有名管道文件S_ISLNK(): 软连接(符号链接)文件S_ISSOCK(): 套接字文件 例子123456789101112131415161718192021222324252627282930313233#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(int argc, char **argv)&#123; struct stat buf; char * file_mode; if(argc != 2) &#123; printf("Usage: stat &lt;pathname&gt;\n"); exit(-1); &#125; if(stat(argv[1], &amp;buf) != 0) &#123; printf("stat error.\n"); exit(-1); &#125; if (S_ISREG(buf.st_mode)) file_mode = "-"; else if (S_ISDIR(buf.st_mode)) file_mode = "d"; else if (S_ISCHR(buf.st_mode)) file_mode = "c"; else if(S_ISBLK(buf.st_mode)) file_mode = "b"; printf("#i-node: %ld\n", buf.st_ino); printf("#link: %d\n", buf.st_nlink); printf("UID: %d\n", buf.st_uid); printf("GID: %d\n", buf.st_gid); printf("Size %ld\n", buf.st_size); printf("mode: %s\n", file_mode); exit(0);&#125; 文件权限的判定文件类型与许可设定被一起编码在st_mode字段中，也需要一组由系统提供的宏来完成解码。 S_ISUID: 执行时，设置用户IDS_ISGID: 执行时，设置组IDS_ISVTX: 保存正文S_IRWXU: 拥有者的读、写和执行权限S_IRUSR: 拥有者的读权限S_IWUSR: 拥有者的写权限S_IXUSR: 拥有者的执行权限S_IRWXG: 用户组的读、写和执行权限S_IRGRP: 用户组的读权限S_IWGRP: 用户组的写权限S_IXGRP: 用户组的执行权限S_IRWXO: 其它读、写、执行权限S_IROTH: 其它读权限S_IWOTH: 其它写权限S_IXOTH: 其它执行权限 stat的目录操作打开目录 需要包含的头文件：&lt;sys/types.h&gt;，&lt;dirent.h&gt;函数原型：DIR * opendir(const char * name)功能：opendir()用来打开参数name指定的目录，并返回DIR *形态的目录流返回值：成功返回目录流；失败返回NULL 读取目录函数原型：struct dirent * readdir(DIR * dir)功能：readdir()返回参数dir目录流的下一个子条目(子目录或子文件)返回值： 成功返回结构体指向的指针，错误或已读完目录，返回NULL函数执行成功返回的结构体原型如下：1234567struct dirent &#123; ino_t d_ino; off_t d_off; unsigned short d_reclen; unsigned char d_type; char d_name[256];&#125;; 其中 d_name字段，是存放子条目的名称 关闭目录 函数原型：int closedir(DIR * dir)功能：closedir()关闭dir所指的目录流返回值：成功返回0；失败返回-1，错误原因在errno中例子:123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dirent.h&gt;int main(int argc, char *argv[])&#123; DIR *dp; struct dirent *entp; if (argc != 2) &#123; printf("usage: showdir dirname\n"); exit(0); &#125; if ((dp = opendir(argv[1])) == NULL) &#123; perror("opendir"); exit(-1); &#125; while ((entp = readdir(dp)) != NULL) printf("%s\n", entp-&gt;d_name); closedir(dp); return 0;&#125; 多进程Linux的基本进程状态其实在使用top命令时候也可以看到一些标识,如R/S/D/T/Z/X等。 R (TASK_RUNNING)，可执行状态。只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLEi状态。而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。（参见《linux内核异步中断浅析》）在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。linux系统中也存在容易捕捉的TASK_UNINTERRUPTIBLE状态。执行vfork系统调用后，父进程将进入TASK_UNINTERRUPTIBLE状态，直到子进程调用exit或exec（参见《神奇的vfork》）。通过下面的代码就能得到处于TASK_UNINTERRUPTIBLE状态的进程： 1234ps -ax | grep a\.out4371 pts/0 D+ 0:00 ./a.out4372 pts/0 S+ 0:00 ./a.out4374 pts/1 S+ 0:00 grep a.out 然后我们可以试验一下TASK_UNINTERRUPTIBLE状态的威力。不管kill还是kill -9，这个TASK_UNINTERRUPTIBLE状态的父进程依然屹立不倒。T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。对于进程本身来说，TASK_STOPPED和TASK_TRACED状态很类似，都是表示进程暂停下来。而TASK_TRACED状态相当于在TASK_STOPPED之上多了一层保护，处于TASK_TRACED状态的进程不能响应SIGCONT信号而被唤醒。只能等到调试进程通过ptrace系统调用执行PTRACE_CONT、PTRACE_DETACH等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。Z (TASK_DEAD – EXIT_ZOMBIE)，退出状态，进程成为僵尸进程。 进程在退出的过程中，处于TASK_DEAD状态。 在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。 之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。 当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。 1234ps -ax | grep a\.out10410 pts/0 S+ 0:00 ./a.out10411 pts/0 Z+ 0:00 [a.out]0413 pts/1 S+ 0:00 grep a.out 只要父进程不退出，这个僵尸状态的子进程就一直存在。那么如果父进程退出了呢，谁又来给子进程“收尸”？当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管给谁呢？可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。1号进程，pid为1的进程，又称init进程。linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命：1、执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）；2、在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作；init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于TASK_INTERRUPTIBLE状态，“收尸”过程中则处于TASK_RUNNING状态。X (TASK_DEAD – EXIT_DEAD)，退出状态，进程即将被销毁。而进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程（进程、线程参见《linux线程浅析》）。或者父进程通过设置SIGCHLD信号的handler为SIG_IGN，显式的忽略了SIGCHLD信号。（这是posix的规定，尽管子进程的退出信号可以被设置为SIGCHLD以外的其他信号。）此时，进程将被置于EXIT_DEAD退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。 获取进程标识号主要有两个函数:getpid和getppid。前者是获取进程号，后者是获取父进程号。需要包含的头文件：&lt;sys/types.h&gt;, &lt;unistd.h&gt; 函数原型：pid_t getpid(void)功能：获取当前进程ID返回值：调用进程的进程ID函数原型：pid_t getppid(void)功能：获取父进程ID返回值：调用进程的父进程ID例子:1234567891011121314#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; pid_t pid = getpid(); pid_t ppid = getppid(); printf ("pid = %d\n", pid); printf ("ppid = %d\n", ppid); return 0;&#125; Linux下C进程内存布局C进程内存布局说明text：代码段。存放的是程序的全部代码（指令），来源于二进制可执行文件中的代码部分initialized data（简称data段）和uninitialized data（简称bss段）组成了数据段。 其中data段存放的是已初始化全局变量和已初始化static局部变量，来源于二进制可执行文件中的数据部分；bss段存放的是未初始化全局变量和未初始化static局部变量，其内容不来源于二进制可执行文件中的数据部分（也就是说：二进制可执行文件中的数据部分没有未初始化全局变量和未初始化static局部变量）。根据C语言标准规定，他们的初始值必须为0，因此bss段存放的是全0。将bss段清0的工作是由系统在加载二进制文件后，开始执行程序前完成的，系统执行这个清0操作是由内核的一段代码完成的，这段代码就是即将介绍的exec系统调用。至于exec从内存什么地方开始清0以及要清0多少空间，则是由记录在二进制可执行文件中的信息决定的（即：二进制文件中记录了text、data、bss段的大小）malloc是从heap（堆）中分配空间的stack（栈）存放的是动态局部变量。当子函数被调用时，系统会从栈中分配空间给该子函数的动态局部变量（注意：此时栈向内存低地址延伸）；当子函数返回时，系统的栈会向内存高地址延伸，这相当于释放子函数的动态局部变量的内存空间。我们假设一下，main函数在调用子函数A后立即调用子函数B，那么子函数B的动态局部变量会覆盖原来子函数A的动态局部变量的存储空间，这就是子函数不能互相访问对方动态局部变量的根本物理原因。内存的最高端存放的是命令行参数和环境变量，将命令行参数和环境变量放到指定位置这个操作是由OS的一段代码（exec系统调用）在加载二进制文件到内存后，开始运行程序前完成的。Linux下C进程内存布局可以由下面的程序的运行结果来获得验证：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int global_init_val = 100;int global_noninit_val;extern char **environ;int main(int argc, char *argv[], char *envp[])&#123; static int localstaticval = 10; char *localval; localval = malloc(10); printf("address of text is : %p\n", main); printf("address of data is : %p, %p\n", &amp;global_init_val, &amp;localstaticval); printf("address of bss is : %p\n", &amp;global_noninit_val); printf("address of heap is : %p\n", localval); printf("address of stack is : %p\n", &amp;localval); free(localval); printf("&amp;environ = %p, environ = %p\n", &amp;envp, envp); printf("&amp;argv = %p, argv = %p\n", &amp;argv, argv); return 0; &#125; 运行结果，如下：12345671 address of text is : 0x80484542 address of data is : 0x804a01c, 0x804a0203 address of bss is : 0x804a02c4 address of heap is : 0x96e10085 address of stack is : 0xbffca8bc6 &amp;environ = 0xbffca8d8, environ = 0xbffca97c7 &amp;argv = 0xbffca8d4, argv = 0xbffca974 运行结果的第1（2、3、4、5、6、7）行是由程序的第13（14、15、16、17、20、21）行打印的。由运行结果的第1、2、3、4行可知，存放的是程序代码的text段位于进程地址空间的最低端；往上是存放已初始化全局变量和已初始化static局部变量的data段；往上是存放未初始化全局变量的bss段；往上是堆区（heap）。由运行结果的第7、6、5行可知，命令行参数和环境变量存放在进程地址空间的最高端；往下是存放动态局部变量的栈区（stack）。 环境变量的获取与设置坏境变量在内存中通常是一字符串环境变量名=环境变量值的形式存放。我们的程序可能会调用Linux系统的环境变量，甚至修改环境变量，所以，Linux向我们提供了这种API。需要包含头文件&lt;stdlib.h&gt;。函数原型：char * getenv(const char * name)返回字符指针，该指针指向变量名为name的环境变量的值字符串。int putenv(const char * str)将“环境变量=环境变量值”形式的字符创增加到环境变量列表中；如果该环境变量已存在，则更新已有的值。int setenv(const char * name, const char * value, int rewrite)设置名字为name的环境变量的值为value；如果该环境变量已存在，且rewrite不为0，用新值替换旧值；rewrite为0，就不做任何事。例子:123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[], char *envp[])&#123; char **ptr; for (ptr = envp; *ptr != 0; ptr++) /* and all env strings */ printf ("%s\n", *ptr); printf ("\n\n--------My environment variable-------\n\n"); printf ("USERNAME is %s\n", getenv("USERNAME")); putenv ("USERNAME=shiyanlou"); printf ("USERNAME is %s\n", getenv("USERNAME")); setenv ("USERNAME", "shiyanlou-2", 0); printf ("USERNAME is %s\n", getenv("USERNAME")); setenv ("USERNAME", "shiyanlou-2", 1); printf ("USERNAME is %s\n", getenv("USERNAME")); return 0;&#125; fork进程控制fork被称为进程控制天字第1号系统调用，可以看出其使用广泛性。 fork的机制与特性12345678910111213#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; pid_t pid; if ((pid = fork()) == 0) &#123; getchar(); exit(0); &#125; getchar();&#125; 父进程调用fork将会产生一个子进程。此时会有2个问题： 子进程的代码从哪里来？ 子进程首次被OS调度时，执行的第1条代码是哪条代码？ 子进程的代码是父进程代码的一个完全相同拷贝。事实上不仅仅是text段，子进程的全部进程空间（包括：text/data/bss/heap/stack/command line/environment variables）都是父进程空间的一个完全拷贝。下一个问题是：谁为子进程分配了内存空间？谁拷贝了父进程空间的内容到子进程的内存空间？fork当仁不让！事实上，查看fork实现的源代码，由4部分工作组成：首先，为子进程分配内存空间；然后，将父进程空间的全部内容拷贝到分配给子进程的内存空间；然后在内核数据结构中创建并正确初始化子进程的PCB（包括2个重要信息：子进程pid，PC的值=善后代码的第1条指令地址）；最后是一段善后代码。由于子进程的PCB已经产生，所以子进程已经出生，因此子进程就可以被OS调度到来运行。子进程首次被OS调度时，执行的第1条代码在fork内部，不过从应用程序的角度来看，子进程首次被OS调度时，执行的第1条代码是从fork返回。这就导致了fork被调用1次，却返回2次：父、子进程中各返回1次。对于应用程序员而言，最重要的是fork的2次返回值不一样，父进程返回值是子进程的pid，子进程的返回值是0。至于子进程产生后，父、子进程谁先运行，取决于OS调度策略，应用程序员无法控制。以上分析了fork的内部实现以及对应用程序的影响。如果应用程序员觉得难以理解的话，可以暂时抛开，只要记住3个结论即可：fork函数被调用1次（在父进程中被调用），但返回2次（父、子进程中各返回一次）。两次返回的区别是子进程的返回值是0，而父进程的返回值则是子进程的进程ID。父、子进程完全一样（代码、数据），子进程从fork内部开始执行；父、子进程从fork返回后，接着执行下一条语句。一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，应用程序员无法控制。 fork实例分析12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#define err_sys(info) \ &#123; \ printf ("%s\n", info);\ exit(0); \ &#125;int glob = 6; /* external variable in initialized data */char buf[ ] = "a write to stdout\n";int main(void)&#123; int var; /* automatic variable on the stack */ pid_t pid; var = 88; if ((write(STDOUT_FILENO, buf, sizeof(buf)-1) != sizeof(buf)-1)) err_sys("write error"); printf("before fork\n"); /* we don't flush stdout */ if ( (pid = fork()) &lt; 0) &#123; err_sys("fork error"); &#125; else if (pid == 0) &#123; /* child */ glob++; /* modify variables */ var++; &#125; else &#123; sleep(2); /* parent */ &#125; printf("pid = %d, ppid = %d, glob = %d, var = %d\n", getpid(),getppid(), glob, var); exit(0); &#125; 运行结果:1234a write to stdoutbefore forkpid = 9009, ppid = 9008, glob = 7, var = 89pid = 9008, ppid = 8979, glob = 6, var = 88 运行结果分析：结果的第1行是由父进程的21行打印；结果的第2行是由父进程的24行打印；由于父进程在24行睡眠了2秒，因此fork返回后，子进程先于父进程运行是大概率事件，所以子进程运行到25行打印出结果中的第3行。由于子进程会拷贝父进程的整个进程空间（这其中包括数据），因此当子进程26行从fork返回后，子进程中的glob=6，var=88（拷贝自父进程的数据）。此时子进程中pid=0，因此子进程会执行29、30行，当子进程到达35行时，将打印glob=7，var=89。虽然，子进程改变了glob和var的值，但它仅仅是改变了子进程中的glob和var，而影响不了父进程中的glob和var。在子进程出生后，父、子进程的进程空间（代码、数据等）就是独立，互不干扰的。因此当父进程运行到35行，将会打印父进程中的glob和var的值，他们分别是6和88，这就是运行结果的第4行。 exec进程控制与fork相对应，exec被成为进程控制的地字一号系统调用。 文件描述符详解文件描述符本质是数组下表，如下图所示: 右侧的表称为i节点表，在整个系统中只有1张。该表可以视为结构体数组，该数组的一个元素对应于一个物理文件。中间的表称为文件表，在整个系统中只有1张。该表可以视为结构体数组，一个结构体中有很多字段，其中有3个字段比较重要： file status flags：用于记录文件被打开来读的，还是写的。其实记录的就是open调用中用户指定的第2个参数current file offset：用于记录文件的当前读写位置（指针）。正是由于此字段的存在，使得一个文件被打开并读取后，下一次读取将从上一次读取的字符后开始读取v-node ptr：该字段是指针，指向右侧表的一个元素，从而关联了物理文件。左侧的表称为文件描述符表，每个进程有且仅有1张。该表可以视为指针数组，数组的元素指向文件表的一个元素。最重要的是：数组元素的下标就是大名鼎鼎的文件描述符。open系统调用执行的操作：新建一个i节点表元素，让其对应打开的物理文件（如果对应于该物理文件的i节点元素已经建立，就不做任何操作）；新建一个文件表的元素，根据open的第2个参数设置file status flags字段，将current file offset字段置0，将v-node ptr指向刚建立的i节点表元素；在文件描述符表中，寻找1个尚未使用的元素，在该元素中填入一个指针值，让其指向刚建立的文件表元素。最重要的是：将该元素的下标作为open的返回值返回。这样一来，当调用read（write）时，根据传入的文件描述符，OS就可以找到对应的文件描述符表元素，进而找到文件表的元素，进而找到i节点表元素，从而完成对物理文件的读写。 fork对文件描述符的影响fork会导致子进程继承父进程打开的文件描述符，其本质是将父进程的整个文件描述符表复制一份，放到子进程的PCB中。因此父、子进程中相同文件描述符（文件描述符为整数）指向的是同一个文件表元素，所以父（子）进程读取文件后，子（父）进程将读取同一文件的后续内容。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main(void)&#123; int fd, pid, status; char buf[10]; if ((fd = open("./test.txt", O_RDONLY)) &lt; 0) &#123; perror("open"); exit(-1); &#125; if ((pid = fork()) &lt; 0) &#123; perror("fork"); exit(-1); &#125; else if (pid == 0) &#123; //child read(fd, buf, 2); write(STDOUT_FILENO, buf, 2); &#125; else &#123; //parent sleep(2); lseek(fd, 1, SEEK_CUR); read(fd, buf, 3); write(STDOUT_FILENO, buf, 3); write(STDOUT_FILENO, "\n", 1); &#125; return 0;&#125; 假设，./test.txt的内容是abcdefg。那么子进程的18行将读到字符ab；由于，父、子进程的文件描述符fd都指向同一个文件表元素，因此当父进程执行23行时，fd对应的文件的读写指针将移动到字符d，而不是字符b，从而24行读到的是字符def，而不是字符bcd。程序运行的最终结果是打印abdef，而不是abbcd。相对应的，如果是两个进程独立调用open去打开同一个物理文件，就会有2个文件表元素被创建，并且他们都指向同一个i节点表元素。两个文件表元素都有自己独立的current file offset字段，这将导致2个进程独立的对同一个物理文件进行读写，因此第1个进程读取到文件的第1个字符后，第2个进程再去读取该文件时，仍然是读到的是文件的第1个字符，而不是第1个字符的后续字符。对应用程序员而言，最重要结论是：如果子进程不打算使用父进程打开的文件，那么应该在fork返回后立即调用close关闭该文件。 wait同步wait作用在forkbase.c中，fork出子进程后，为了保证子进程先于父进程运行，在父进程中使用了sleep（2）的方式让父进程睡眠2秒。但实际上这样做，并不能100%保证子进程先于父进程运行，因为在负荷非常重的系统中，有可能在父进程睡眠2秒期间，OS并没有调度到子进程运行，并且当父进程睡醒后，首先调度到父进程运行。系统调用wait可以100%保证父、子进程完全按程序员的安排来进行同步。需要包含的头文件： wait.h函数原型：pid_t wait(int * status)功能：等待进程结束。返回值：若成功则为子进程ID号，若出错则为-1。参数说明： status：用于存放进程结束状态。wait函数用于使父进程阻塞，直到一个子进程结束。父进程调用wait，该父进程可能会: 阻塞(如果其所有子进程都还在运行)。带子进程的终止状态立即返回(如果一个子进程已终止，正等待父进程存取其终止状态)。出错立即返回(如果它没有任何子进程)。 wait调用 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;wait.h&gt;void pr_exit(intstatus);int main(void)&#123; pid_t pid; int status; if ( (pid = fork()) &lt; 0) &#123; perror("fork");exit(-1); &#125; else if (pid == 0) &#123; /* child */ sleep(1); printf("inchild\n"); exit(101); &#125; if (wait(&amp;status) != pid) /* wait for child */ &#123; perror("wait");exit(-2); &#125; printf("in parent\n"); pr_exit(status); /* and print itsstatus */ if ( (pid = fork()) &lt; 0) &#123; perror("fork");exit(-1); &#125; else if (pid == 0) /*child */ abort(); /* generates SIGABRT */ if (wait(&amp;status) != pid) /* wait for child */ &#123; perror("wait");exit(-2); &#125; pr_exit(status); /* and printits status */ if ( (pid = fork()) &lt; 0) &#123; perror("fork");exit(-1); &#125; else if (pid == 0) /*child */ status /= 0; /* divide by 0 generates SIGFPE */ if (wait(&amp;status) != pid) /* wait for child */ &#123; perror("wait");exit(-1); &#125; pr_exit(status); /* and printits status */ exit(0); &#125; void pr_exit(int status) &#123; if (WIFEXITED(status)) printf("normallytermination, low-order 8 bit of exit status = %d\n", WEXITSTATUS(status)); else if(WIFSIGNALED(status)) printf("abnormallytermination, singal number = %d\n", WTERMSIG(status)); &#125; 其中，11行创建了一个子进程，13行根据fork的返回值区分父、子进程。 我们先看父进程，父进程从18行运行，这里调用了wait函数等待子进程结束，并将子进程结束的状态保存在status中。这时，父进程就阻塞在wait这里了，这样就保证了子进程先运行。子进程从13行开始运行，然后sleep 1秒，打印出“in child”后，调用exit函数退出进程。这里exit中有个参数101，表示退出的值是101。.子进程退出后，父进程wait到了子进程的状态，并把状态保存到了status中。后面的pr_exit函数是用来对进程的退出状态进行打印。接下来，父进程又创建一个子进程，然后又一次调用wait函数等待子进程结束，父进程这时候阻塞在了wait这里。子进程开始执行，子进程里面只有一句话：abort（），abort会结束子进程并发送一个SIGABORT信号，唤醒父进程。所以父进程会接受到一个SIGABRT信号，并将子进程的退出状态保存到status中。然后调用pr_exit函数打印出子进程结束的状态。然后父进程再次创建了一个子进程，依然用wait函数等待子进程结束并获取子进程退出时的状态。子进程里面就一句status/= 0，这里用0做了除数，所以子进程会终止，并发送一个SIGFPE信号，这个信号是用来表示浮点运算异常，比如运算溢出，除数不能为0等。这时候父进程wait函数会捕捉到子进程的退出状态，然后调用pr_exit处理。 pr_exit函数将status状态传入，然后判断该状态是不是正常退出，如果是正常退出会打印出退出值；不是正常退出会打印出退出时的异常信号。这里用到了几个宏，简单解释如下： WIFEXITED： 这个宏是用来判断子进程的返回状态是不是为正常，如果是正常退出，这个宏返回真。WEXITSTATUS： 用来返回子进程正常退出的状态值。WIFSIGNALED： 用来判断子进程的退出状态是否是非正常退出，若非正常退出时发送信号，则该宏返回真。WTERMSIG： 用来返回非正常退出状态的信号number。所以这段代码的结果是分别打印出了三个子进程的退出状态和异常结束的信号编号 exec详解当一个程序调用fork产生子进程，通常是为了让子进程去完成不同于父进程的某项任务，因此含有fork的程序，通常的编程模板如下：12345if ((pid = fork()) == 0) &#123; dosomething in child process; exit(0);&#125;do something in parent process; 这样的编程模板使得父、子进程各自执行同一个二进制文件中的不同代码段，完成不同的任务。这样的编程模板在大多数情况下都能胜任，但仔细观察这种编程模板，你会发现它要求程序员在编写源代码的时候，就要预先知道子进程要完成的任务是什么。这本不是什么过分的要求，但在某些情况下，这样的前提要求却得不到满足，最典型的例子就是Linux的基础应用程序 —— shell。你想一想，在编写shell的源代码期间，程序员是不可能知道当shell运行时，用户输入的命令是ls还是cp，难道你要在shell的源代码中使用if–elseif–else if–else if ……结构，并拷贝 ls、cp等等外部命令的源代码到shell源代码中吗？退一万步讲，即使这种弱智的处理方式被接受的话，你仍然会遇到无法解决的难题。想一想，如果用户自己编写了一个源程序，并将其编译为二进制程序test，然后再在shell命令提示符下输入./test，对于采用前述弱智方法编写的shell，它将情何以堪？因此需要exec予以协作。 exec机制在用fork函数创建子进程后，子进程往往要调用exec函数以执行另一个程序。当子进程调用exec函数时，会将一个二进制可执行程序的全路径名作为参数传给exec，exec会用新程序代换子进程原来全部进程空间的内容，而新程序则从其main函数开始执行，这样子进程要完成的任务就变成了新程序要完成的任务了。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用另一个新程序替换了当前进程的正文、数据、堆和栈段。进程还是那个进程，但实质内容已经完全改变。呵呵，这是不是和中国A股的借壳上市有异曲同工之妙？顺便说一下，新程序的bss段清0这个操作，以及命令行参数和环境变量的指定，也是由exec完成的。 exec用法函数原型：int execle(const char * pathname,const char * arg0, ... (char *)0, char * const envp [] )返回值：exec执行失败返回-1，成功将永不返回（想想为什么？）。哎，牛人就是有脾气，天字1号是调用1次，返回2次；地字1号，干脆就不返回了，你能奈我何？参数：pathname：新程序的二进制文件的全路径名arg0：新程序的第1个命令行参数argv[0]，之后是新程序的第2、3、4……个命令行参数，以(char*)0表示命令行参数的结束envp：新程序的环境变量 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(int argc, char*argv[])&#123; int i; char **ptr; extern char **environ; for (i = 0; i &lt; argc; i++) /* echo all command-line args */ printf("argv[%d]:%s\n", i, argv[i]); for (ptr = environ; *ptr != 0;ptr++) /* and all env strings */ printf("%s\n",*ptr);&#125; 将此程序进行编译，生成二进制文件命名为echoall，放在当前目录下。很容易看出，此程序运行将打印进程的所有命令行参数和环境变量。运行结果分析： 1-5行是第1个子进程14行运行新程序echoall的结果，其中：1-3行打印的是命令行参数；4、5行打印的是环境变量。6行之后是第2个子进程23行运行新程序echoall的结果，其中：6、7行打印的是命令行参数；8行之后打印的是环境变量。之所以第2个子进程的环境变量那么多，是因为程序23行调用execlp时，没有给出环境变量参数，因此子进程就会继承父进程的全部环境变量。 进程的消亡gdb调试多进程技巧对多进程程序进行调试，存在一个较大的难题，那就是当程序调用fork产生子进程后，gdb跟踪的是父进程，无法进入到子进程里去单步调试子进程。这样一来，如果子进程中的代码运行出错的话，将无法进行调试。因此想调试子进程的话，需要一点技巧： 在子进程的入口处加入sleep(20)函数，以使子进程在被创建后能暂时停止。用ps查看子进程的pid，假定pid为222，则输入命令：gdb程序名称222。从而再运行一个调试程序，使得gdb attach到子进程。用gdb的break命令在子进程中设定断点。用gdb的continue，恢复子进程的运行。等待sleep的睡眠时间到达，从而子进程将在断点处停下来。 启动例程与main函数从程序员的角度看，C应用程序从main函数开始运行。但事实上，当C应用程序被内核通过exec启动时，一个启动例程会先于main函数运行，它会为main函数的运行准备好环境后，调用main函数。而main函数正常结束后return语句将使得main函数返回到启动例程，启动例程在完成必要的善后处理后将最终调用_exit结束进程。有5种方式结束进程： 正常结束：1.从main函数返回2.调用exit3.调用_exit 非正常结束：4.调用abort5.被信号中止 exit函数与_exit函数需要包含的头文件：&lt;stdlib.h&gt;、&lt;unistd.h&gt;函数原型： void exit(int status)、 void _exit(int status)这两个函数的功能都是使进程正常结束。_exit：立即返回内核，它是一个系统调用exit：在返回内核前会执行一些清理操作，这些清理操作包括调用exit handler，以及彻底关闭标准I/O流(这回使得I/O流的buffer中的数据被刷新，即被提交给内核)，它是标准C库中的一个函数。 I/O流和I/O库缓存关于IO流的buffer:12345678910#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; printf("hello"); //printf("hello\n"); //write(1, "hello", 5); sleep(100); return 0; &#125; 其结果没有任何输出。 当应用程序调用printf时，将字符串”hello”提交给了标准I/O库的I/O库缓存。I/O库缓存大致可以认为是printf实现中定义的全局字符数组，因此它位于用户空间，可见”hello”并没有被提交给内核(所以也不可能出现内核将”hello”打印到屏幕的操作)，所以没有打印出任何东西。只有当某些条件满足时，标准I/O库才会刷新I/O库缓存，这些条件包括： 用户空间的I/O库缓存已被填满I/O库缓存遇到了换行符(‘\n’)，并且输出目标是行缓冲设备(屏幕就是这种设备)。因此将上面的代码第6行注释掉，并取消第7行的注释，就可以看到打印出了helloI/O流被关闭，上节中的exit函数就会关闭I/O流Tips:当标准I/O库缓存时，会调用以前的我们学过的系统调用，例如：write，将I/O库缓存中的内容提交给内核。so，上述代码也可以这样：第6行注释，第7行注释，第8行取消注释。也可以在屏幕上看见”hello” Exit handlerExit handler 是程序员编写的函数，进程正常结束时，它们会被系统调回。这使程序员具备了在进程正常结束时，控制进程执行某些善后操作的能力。使用Exit handler，需要程序员完成两件事情：编写Exit handler函数；调用atexit或on_exit向系统注册Exit handler(即告知系统需要回调的Exit handler函数是谁)需要包含头的文件：函数原型：12int atexit(void (* func)(void))int on_exit(void (* func)(int, void *),) 功能：atexit注册的函数func没有参数；on_exit注册的函数func有一个int型参数，系统调用回调func时将向该参数传入进程的退出值，func的另一个void *类型参数将会是arg。ANSI C中，进程最多可以注册32个Exit handler函数，这些函数按照注册时的顺序被逆序调用。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;static void my_exit0(int, void *);static void my_exit1(void);static void my_exit2(void);char str[9]="for test";int main(void) &#123; //char str[9]="for test"; if (atexit(my_exit2) != 0) &#123; perror("can't register my_exit2"); exit(-1); &#125; if (atexit(my_exit1) != 0) &#123; perror("can't register my_exit1"); exit(-1); &#125; if (on_exit(my_exit0,(void *)str) !=0) &#123; perror("can't register my_exit0"); exit(-1); &#125; printf("main is done\n"); printf("abc"); //_exit(1234); exit(1234);&#125;static void my_exit0(int status, void *arg) &#123; printf("zero exit handler\n"); printf("exit %d\n", status); printf("arg=%s\n",(char *)arg);&#125;static void my_exit1(void) &#123; printf("first exit handler\n");&#125;static void my_exit2(void) &#123; printf("second exit handler\n");&#125; 进程中止处理函数执行顺序按照设置顺序的相反顺序执行。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件IO</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易18校招题]]></title>
    <url>%2Fposts%2Fad27c4df%2F</url>
    <content type="text"><![CDATA[没怎么找工作，因为各种原因也没准备，偶然翻到了牛客网，发现以前还有个账号，又看了一下里面的题目，因为没怎么刷题，即兴练手。里面一共有8题，做了一会没做完，之后补上，先写几题。 魔法币时间限制：1秒空间限制：32768K小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。 输入描述:输入包括一行,包括一个正整数n(1 ≤ n ≤ 10^9),表示小易需要的魔法币数量。 输出描述:输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符’1’和’2’。 输入例子1:10 输出例子1:122 大致思路稍微计算一下，可以发现，只用魔法机器1生成的魔法币数量是:$$ 2^m-1$$只用魔法机器2生成的魔法币数量是:$$2^{(m+1)}-2$$而这刚好可以写成一个完全的二叉树: 其中每一个父节点有两个子节点，左边的是采用机器1生成的，右边则是采用机器2生成的。可以看出每个数仅出现一次，说明机器1和机器2的组合唯一，因此可以采用倒推法计算出每一个机器。首先通过计算出在哪一行，然后判断在该行是奇数还是偶数，奇数为1号，偶数为2号，计算完后再按公式返回上一行如此反复。最后代码如下:1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); char a[30]; int num = log(n+1)/log(2); int i,tmp=num; while (tmp&gt;1) &#123; int stmp =n+2-pow(2,tmp); if(stmp%2 == 0) &#123; a[tmp-1]='2'; n =(n-2)/2; &#125; else &#123; a[tmp-1]='1'; n = (n-1)/2; &#125; tmp--; &#125; a[0]= n%2?'1':'2'; for (i=0;i&lt;num;i++) printf("%c",a[i]); &#125; 相反数时间限制：1秒空间限制：32768K为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1. 输入描述:输入包括一个整数n,(1 ≤ n ≤ 10^5) 输出描述:输出一个整数,表示n的相反数 输入例子1:1325 输出例子1:6556 思路直接求出每一位逆序相加即可，比较简单，直接贴代码:12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt; int main(void)&#123; int i=0,k=1,n,tmp,rev[5]; scanf("%d",&amp;n); tmp=n; while(tmp&gt;9) &#123; rev[i]=tmp%10; tmp =(tmp-rev[i])/10; i++; k *=10; &#125; rev[i]=tmp; int result=n; i=0; while(k&gt;0) &#123; //printf("%d",rev[i]); result += rev[i]*k; i++; k /=10; &#125; printf("%d",result);&#125; 字符串碎片时间限制：1秒空间限制：32768K一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。 输入描述:输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s只含小写字母(‘a’-‘z’) 输出描述:输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。 如样例所示: s = “aaabbaaac”所有碎片的平均长度 = (3 + 2 + 3 + 1) / 4 = 2.25 输入例子1:aaabbaaac 输出例子1:2.25 思路用一个计数器，遍历一遍，碰到不相同的就加１。代码如下:123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main(void)&#123; char s[50]; scanf("%s",s); char *p=s; int len=1,frac=1; while(*(p+1) != '\0') &#123; len++; if(*p != *(p+1)) frac++; p++; &#125; printf("%.2f",(len+0.0)/frac);&#125; 游历魔法王国时间限制：1秒空间限制：32768K魔法王国一共有n个城市,编号为0~n-1号,n个城市之间的道路连接起来恰好构成一棵树。小易现在在0号城市,每次行动小易会从当前所在的城市走到与其相邻的一个城市,小易最多能行动L次。如果小易到达过某个城市就视为小易游历过这个城市了,小易现在要制定好的旅游计划使他能游历最多的城市,请你帮他计算一下他最多能游历过多少个城市(注意0号城市已经游历了,游历过的城市不重复计算)。 输入描述:输入包括两行,第一行包括两个正整数n(2 ≤ n ≤ 50)和L(1 ≤ L ≤ 100),表示城市个数和小易能行动的次数。第二行包括n-1个整数parenti, 对于每个合法的i(0 ≤ i ≤ n - 2),在(i+1)号城市和parent[i]间有一条道路连接。 输出描述:输出一个整数,表示小易最多能游历的城市数量。 输入例子1:5 20 1 2 3 输出例子1:3 思路找出树的最大长度和L比较，如果大于L，那就直接是L+1，如果小于L，剩下的必须走别的路，且必须走两次，所以最后结果是maxlen+(L-maxlen)/2。代码如下:1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt; int getlen(int n,int p[50]) &#123; int mlen=0,tmp,i,k; for (i=n-2;i&gt;=0;i--) &#123; k=i; tmp=0; while(p[k]!=0) &#123; tmp++; k=p[k]-1; &#125; tmp++; mlen=(mlen&gt;tmp)?mlen:tmp; &#125; return mlen; &#125;int main(void)&#123; int i,n,L; int p[50]; scanf("%d%d",&amp;n,&amp;L); for(i=0;i&lt;n-1;i++) scanf("%d",&amp;p[i]); int maxlen; maxlen =getlen(n,p); maxlen = (maxlen&gt;L)?L:(maxlen+int((L-maxlen)/2)); maxlen++; printf("%d",maxlen); &#125; 重排数列时间限制：1秒空间限制：100768K小易有一个长度为N的正整数数列A = {A[1], A[2], A[3]…, A[N]}。牛博士给小易出了一个难题:对数列A进行重新排列,使数列A满足所有的A[i] * Ai + 1都是4的倍数。小易现在需要判断一个数列是否可以重排之后满足牛博士的要求。 输入描述:输入的第一行为数列的个数t(1 ≤ t ≤ 10),接下来每两行描述一个数列A,第一行为数列长度n(1 ≤ n ≤ 10^5)第二行为n个正整数Ai 输出描述:对于每个数列输出一行表示是否可以满足牛博士要求,如果可以输出Yes,否则输出No。 输入例子231 10 10041 2 3 4 输出例子YesNo 大致思路比较是否是4的倍数和奇数的数目，如果前者大于等于后者，必然是满足的。还有一种情况是前者等于后者减一，此时不存在非4倍数的偶数。最后代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int Isarray(int n, int a[100000])&#123; int n1=0,n2=0,n4=0,i=0; for(;i&lt;n;i++) &#123; if(a[i]%4==0) ++n4; else if(a[i]%2==0) ++n2; else ++n1; &#125; //printf("%d,%d,%d,%d\t",n1,n2,n4,n); if (n==1 &amp;&amp; n4 ) return 1; if(n4 &gt; (n1-1)) return 1; else if((n4 == n1-1) &amp;&amp; (n2 == 0) ) return 1; else return 0; &#125;int main(void)&#123; int i,j,t,n,a[100000],b[10]; scanf("%d",&amp;t); for(j=0;j&lt;t;j++) &#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); b[j]=Isarray(n,a); &#125; for(j=0;j&lt;t;j++) if(b[j]) printf("Yes\n"); else printf("No\n"); return 0;&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网易</tag>
        <tag>校招</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[楼赛]]></title>
    <url>%2Fposts%2Fc72229d1%2F</url>
    <content type="text"><![CDATA[这几天登录了下实验楼，看到有个楼赛，然后就参加了，这里记录一下。虽然一直用Linux，但是基本没专门去上过之类的课，最早还是智能信息课的实验机房里搭Hadoop用到的，然后还挺喜欢的，以至于后来卸了Win把笔记本装了Ubuntu，用的开源软件，也没有盗版的困扰了。呐，就是这样说的，当然没打算拿奖，里面高手估计多得是，所以也是求个体验。 楼赛一共有三题，虽然比较简单，不过比较实用，太难的屠龙之术也就没啥必要丢出来以论轩轾了。 第一题 备份日志文件描述如下:这个就是写个每天自动备份打包完成任务的脚本，不过里面不让写脚本，这个里面虽然说了，但是还是花了很多时间才放弃写脚本。 时间输出首先是要获得当前时间，以确定两点开始备份。通常是使用date命令。首先查看一下date的参数:123456789101112131415161718192021222324 $ ▶ date --helpUsage: date [OPTION]... [+FORMAT] or: date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]Display the current time in the given FORMAT, or set the system date.Mandatory arguments to long options are mandatory for short options too. -d, --date=STRING display time described by STRING, not 'now' -f, --file=DATEFILE like --date; once for each line of DATEFILE -I[FMT], --iso-8601[=FMT] output date/time in ISO 8601 format. FMT='date' for date only (the default), 'hours', 'minutes', 'seconds', or 'ns' for date and time to the indicated precision. Example: 2006-08-14T02:34:56-0600 -R, --rfc-2822 output date and time in RFC 2822 format. Example: Mon, 14 Aug 2006 02:34:56 -0600 --rfc-3339=FMT output date/time in RFC 3339 format. FMT='date', 'seconds', or 'ns' for date and time to the indicated precision. Example: 2006-08-14 02:34:56-06:00 -r, --reference=FILE display the last modification time of FILE -s, --set=STRING set time described by STRING -u, --utc, --universal print or set Coordinated Universal Time (UTC) --help display this help and exit --version output version information and exit 后面比较多就不贴了，主要是获取年月日，好给打包文件命名。12date +%y%m%d171029 能获取出来这一步基本就OK了。 自动化任务使用cron命令实现自动化。首先编辑crontab文件，在其中加入执行时间和执行命令，即备份并打包文件。比较简单，就直接贴代码了:12crontab -e0 2 * * * mkdir /home/shiyanlou/backup &amp;&amp; tar -cvf /home/shiyanlou/backup/"$(date +%y-%m-%d)".tar /var/log/dpkg.log /var/log/mysql.log /var/log/fontconfig.log 然后启动一下cron服务:1sudo service cron start 或者1sudo cron start 第二题 批量创建删除用户和组描述如下:批量创建删除用户和组，按照里面的要求，大概是创建一个脚本，可以实现创建和删除用户的功能，输入为四个参数，对于已经创建的用户显示星号。 确保输入正确输入正确包括 参数数目正确 12345if [ $# -ne 4 ]thenecho "parameter"exitfi 学生数量正确 12345if [ $4 -lt 1 ] || [ $4 -gt 10 ]thenecho "parameter error"exitfi 功能参数正确即必须是del或者add参数，即删除或者添加用户组。可以最后加个else处理这个部分。 学生名称前缀正确即学生名称前缀只允许包含小写字母。 123456echo $3 | grep "^[a-z]\+$"if [ $? eq 1 ]then echo "parameter error"exitfi 随机数的生成一共要生成六位随机数，虽说linux自带RANDOM，但是都是小于等于五位数的，且不能确保多少位，所以使用urandom来获取随机数。 1tr -cd 0-9 &lt;/dev/urandom | head -c 6 大致思路是这样，然后贴代码了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253if [ $# -ne 4 ]thenecho "parameter"exitfiecho $3 | grep "^[a-z]\+$"if [ $? eq 1 ]then echo "parameter error"exitfiif [ $4 -lt 1 ] || [ $4 -gt 10 ]thenecho "parameter error"exitelif [ $1 == "add" ]thenid $2 &gt;&amp; /dev/nullif [ $? -ne 0 ]thenpw=`tr -cd 0-9 &lt;/dev/urandom | head -c 6`sudo useradd -s /bin/zsh $2 -p $pwss="#$2 ALL=(ALL:ALL) ALL"echo $sssudo sh -c "echo $ss &gt;&gt; /etc/sudoers"sudo usermod -aG sudo $2echo $2:$pwelseecho $2:******fifor stu in `seq 1 $4`doid $3$stu &gt;&amp; /dev/nullif [ $? -ne 0 ]thenpw=`tr -cd 0-9 &lt;/dev/urandom | head -c 6`echo $3$stu:$pwsudo useradd -s /bin/zsh -p $pw $3$stuelseecho $3$stu:******fidoneelif [ $1 == "del" ]thensudo userdel $2for stu in `seq 1 $4`dosudo userdel $3$studoneelseecho "parameter error"exitfi 第三题 获取系统信息描述如下:获取系统信息，包括系统各部分硬件信息和软件信息。 CPU信息CPU信息可以通过查看Linux的cpuinfo获取，不过并没有直接给出CPU数量，虽然可以直接看出。这里通过把processor的数量加1得到1echo "cpu num: "$(grep processor /proc/cpuinfo | wc -l) 内存信息内存信息可以通过很多方式查看，比如top，还有就是Linux的meminfo，还有就是free命令。但是要求自定义单位，所以这里用free。12echo $(free -g |grep Mem |awk '&#123;print "memory total: " $2"G"&#125;')echo $(free -m |grep Mem |awk '&#123;print "memory free: " $4"M"&#125;') 磁盘信息磁盘信息一般使用df命令，这里要获取根目录的磁盘大小，根目录一般在输出中第一行，所以需要获取其位置:1echo "disk size: "$(df -h|awk '&#123;print $2&#125;'|sed -n 2p) 不过这个只是碰运气，有的不在第一行，就会出错了，但是grep直接过滤掉根目录是没用的，这里需要精确匹配根目录/，所以需要用到grep -w1echo "disk size: "$(df -h|grep -w '/' |awk '&#123;print $2&#125;'|sed -n 2p) 系统信息获取系统位数，直接:1echo "system bit:" $(getconf LONG_BIT) 进程数查看当前所有进程可以用ps命令实现，但是没有计数的功能，也不必为此单独创建一个命令，可以结合wc命令实现该功能:1echo "process: "$(ps -A |wc -l) 软件数目和上面一样，可以通过dpkg命令查询所有安装的软件，再结合wc命令实现计数:1echo "software num: "$(dpkg -l|wc -l) 网卡信息查询IP很简单，一句ifconfig可以解决，但是输出格式不满足要求，需要删掉输出信息中多余的字符，可以用awk命令。1echo "ip: "$(ifconfig eth0 |awk '/inet/ &#123; split($2,x,":");print x[2]&#125;') 最后这题全部代码如下:12345678910echo "cpu num: "$(grep processor /proc/cpuinfo | wc -l)echo $(free -g |grep Mem |awk '&#123;print "memory total: " $2"G"&#125;')echo $(free -m |grep Mem |awk '&#123;print "memory free: " $4"M"&#125;')#echo $(grep MemTotal /proc/meminfo | awk '&#123;print "memory total: " $2&#125;')#echo $(grep MemFree /proc/meminfo | awk '&#123;print "memory free: "$2&#125;')echo "disk size: "$(df -h|grep -w "/" |awk '&#123;print $2&#125;'|sed -n 2p)echo "system bit:" $(getconf LONG_BIT)echo "process: "$(ps -A |wc -l)echo "software num: "$(dpkg -l|wc -l)echo "ip: "$(ifconfig eth0 |awk '/inet/ &#123; split($2,x,":");print x[2]&#125;')]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>楼赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mathjax的LaTeX公式语法]]></title>
    <url>%2Fposts%2Fb9c74ed9%2F</url>
    <content type="text"><![CDATA[$$ E = mc^2 $$关于Mathjax的LaTeX公式语法，在Hexo的markdown语法中引用大致相同。 插入公式LaTeX的数学公式主要有两种:行内公式和行间公式。 行内公式行内公式和行间公式都有两种写法，一种是括号，一种是美元符写法 1 。\(formula\) 括号写法$formula$ 美元符写法但是由于Hexo markdown语法中暂未渲染括号的语法，也容易与markdown语法混淆，所以本篇目前使用美元符号的写法。 行间公式$$formula$$ 表示行间公式行内公式与行间公式的效果 2 : 12$[J\_\alpha(x) = \sum\_&#123;m=0&#125;^\infty \frac&#123;(-1)^m&#125;&#123;m! \Gamma (m + \alpha +1)&#125; (&#123; \frac&#123;x&#125;&#123;2&#125;)^&#123;xy^2+1&#125;&#125;]$$$[J\_\alpha(x) = \sum\_&#123;m=0&#125;^\infty \frac&#123;(-1)^m&#125;&#123;m! \Gamma (m + \alpha +1)&#125; (&#123; \frac&#123;x&#125;&#123;2&#125;)^&#123;xy^2+1&#125;&#125;]$$ 效果:行内公式:$[J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha +1)} ({ \frac{x}{2})^{xy^2+1}}]$行间公式:$$[J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha +1)} ({ \frac{x}{2})^{xy^2+1}}]$$ 上下标和括号上下角标上标用^符号表示，下标用_符号表示。如果内容多于一个，可以用{}括起来。如果左右两边都需要有角标，可以用\sideset语法设置。1$$\sideset&#123;^1\_2&#125;&#123;^3\_4&#125;S$$ $$\sideset{^1_2}{^3_4}S$$ 括号小括号是()，中括号是[]，大括号是\{\}。其中使用\left和\right可以设置自适应括号大小。如：1$(\frac&#123;a&#125;&#123;b&#125;)$ 和 $\left(frac&#123;a&#125;&#123;b&#125;\right)$ 效果: $(\frac{a}{b})$ 和 $\left(\frac{a}{b}\right)$ 其中\left和\right通常是成对出现的，如果只需要自适应一个分隔符的大小，也需要写两个语法。这是用另外一个(如\left.)去适配。 1$$\left\.\frac&#123; &#123;\rm d&#125;y&#125;&#123; &#123;\rm d&#125;x&#125;\right|\_&#123;x=0&#125;$$ 效果: $$\left.\frac{ {\rm d}y}{ {\rm d} x} \right|_{x=0}$$ 由于hexo中markdown语法问题，\frac后的两个{ {中间一定要加空格，或者直接取消第二个大括号，显示为: $$\left.\frac{ \rm dy}{ \rm dx} \right|_{x=0}$$ 一些常用表达式分数\frac{}{}表示分数，后面两个部分是分子和分母。 开方\sqrt[n]{formula}表示开n次方。 矢量\vec{a} \cdot \vec{b}表示$\vec{a}\cdot\vec{b}$ 积分\int\_0^1{x^2}sin(x){\rm d}x表示$\int_0^1{x^2}sin(x){\rm d}x$ 极限行内:$\lim\limits\_{n\rightarrow + \infty} \frac{1}{n(n+1)}$ 表示$\lim\limits_{n\rightarrow + \infty} \frac{1}{n(n+1)}$行间:$$\lim\_{n\rightarrow + \infty} \frac{1}{n(n+1)}$$ 表示$$\lim_{n\rightarrow + \infty} \frac{1}{n(n+1)}$$ 累加累乘\sum\_{i=0}^n \frac{1}{i^2}表示$\sum_{i=0}^n \frac{1}{i^2}$\prod\_{i=0}^n \frac{1}{i^2}表示$\prod_{i=0}^n \frac{1}{i^2}$ 特殊字符希腊字符 小写 大写 \alpha A \beta B \gamma \Gamma \delta \Delta \epsilon E \varepsilon \zeta Z \eta H \theta \Theta \vartheta \iota I \kappa K \lambda \Lambda \mu M \nu N \xi \Xi o O \pi \Pi \varpi \rho P \varrho \sigma \Sigma \varsigma \tau T \upsilon \Upsilon \phi \Phi \varphi \chi X \psi \Psi \omega \Omega 关系运算 运算符号 表示方式 ± \pm × \times ÷ \div ∣ \mid ∤ \nmid ⋅ \cdot ∘ \circ ∗ \ast ⨀ \bigodot ⨂ \bigotimes ⨁ \bigoplus ≤ \leq ≥ \geq ≠ \neq ≈ \approx ≡ \equiv ∑ \sum ∏ \prod ∐ \coprod 集合运算 集合符号 表示方式 ∅ \emptyset ∈ \in ∉ \notin ⊂ \subset ⊃ \supset ⊆ \subseteq ⊇ \supseteq ⋂ \bigcap ⋃ \bigcup ⋁ \bigvee ⋀ \bigwedge ⨄ \biguplus ⨆ \bigsqcup 对数和三角运算符 运算符 表示方式 log \log lg \lg ln \ln ⊥ \bot ∠ \angle 30∘ 30^\circ sin \sin cos \cos tan \tan cot \cot sec \sec csc \csc 箭头符号 箭头 表示方式 ↑ \uparrow ↓ \downarrow ⇑ \Uparrow ⇓ \Downarrow → \rightarrow ← \leftarrow ⇒ \Rightarrow ⇐ \Leftarrow ⟶ \longrightarrow ⟵ \longleftarrow ⟹ \Longrightarrow ⟸ \Longleftarrow 其他运算符 运算符 表示方式 ′ \prime ∫ \int ∬ \iint ∭ \iiint ⨌ \iiiint ∮ \oint lim \lim ∞ \infty ∇ \nabla ∵ \because ∴ \therefore ∀ \forall ∃ \exists ≠ \not= ≯ \not&gt; ⊄ \not\subset $\hat{y} $ \hat{y} $\check{y}$ \check{y} $\breve{y}$ \breve{y} $\overline{a+b+c+d} $ \overline{a+b+c+d} $\underline{a+b+c+d} $ \underline{a+b+c+d} $\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$ \overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0} 字体转换 字体 表示方式 \rm 罗马体 \bf 黑体 \sl 倾斜体 \mit 数学斜体 \sc 小体大写字母 \it 意大利体 \cal 花体 \sf 等线体 \tt 打字机字体 1.本篇中公式具体内容均以formula表示。 ↩2.由于hexo markdown语法的渲染，公式中_需要用转义字符表示。 ↩]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
        <tag>latex</tag>
        <tag>markdown</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客的优化]]></title>
    <url>%2Fposts%2F6d87f1ac%2F</url>
    <content type="text"><![CDATA[捣鼓个人博客也有一段时间了，其间加了不少的插件，改来改去，最后打开也变得很慢了。问题主要有两个方面，一个是网络问题，因为托管在Github上，国内访问一直很慢，后来还是迁移到Coding上了，妥协了，给他加了个Hosted by Coding Pages。另一方面则是加载的问题，由于多了许多插件，导致网页加载变慢，特别是在添加live2d之后。所以打算做些工作优化一下博客。 外部链接优化主要是告诉搜索引擎爬虫无需抓取目标页，同时告诉搜索引擎无需将的当前页的Pagerank传递到目标页。Google推荐是用nofollow，nofollow是HTML元标签(meta)的content属性和链接标签(a)的rel属性的一个值，告诉机器(爬虫)无需追踪目标页，为了对抗blogspam(博客垃圾留言信息)。但是如果是通过sitemap直接提交该页面，爬虫还是会爬取，这里的nofollow只是当前页对目标页的一种态度，并不代表其他页对目标页的态度。 主要作用 防止不可信的内容，最常见的是博客上的垃圾留言与评论中为了获取外链的垃圾链接，为了防止页面指向一些拉圾页面和站点。 付费链接：为了防止付费链接影响Google的搜索结果排名，Google建议使用nofollow属性。 引导爬虫抓取有效的页面：避免爬虫抓取一些无意义的页面，影响爬虫抓取的效率。其主要方法是给所有外部链接加上rel=&quot;external nofollow&quot;属性，对外部链接target=”_blank”采用在新窗口种打开外部链接的方法。 安装1npm install hexo-autonofollow --save 配置编辑站点配置文件。1234nofollow: enable: true exclude: - you domain 这里的exclude下主要填你的域名，为豁免域名。 在主页不显示某类文章修改主题目录下layout的index.swig文件:12345678910111213141516171819202122232425&#123;% extends '_layout.swig' %&#125;&#123;% import '_macro/post.swig' as post_template %&#125;&#123;% import '_macro/sidebar.swig' as sidebar_template %&#125;&#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125;&#123;% block page_class %&#125; &#123;% if is_home() %&#125; page-home &#123;% endif %&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;% if post.categories!= 'Recommend' %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include '_partials/pagination.swig' %&#125;&#123;% endblock %&#125;&#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125;&#123;% endblock %&#125; 在其中加入page的判断页面即可。 添加emoji支持由于Hexo的默认Markdown语法不支持emoji表情，网上也有人替换了其Markdown渲染工具，但是又会引入新的Bug，所以就放弃了。后来看到有人照着Github的方式做了一个插件，在生成网页的时候将关键字替换成emoji的unicode字符，然后再利用JavaScript将字符替换成图片，这样即使图片加载失败还有字符fallback。其Repo在此。 安装1npm install hexo-filter-github-emojis --save 配置编辑站点配置文件1234567vim _config.xmlgithubEmojis: enable: true className: github-emoji unicode: false styles: localEmojis: 其中，localEmojis可以添加自己的本地表情。 Warning的处理在安装完之后再执行hexo生成站点文件时，会有一个警告，主要内容如下:1DeprecationWarning: Calling an asynchronous function without callback is deprecated. 这个意思是调用无回调的异步函数的方法已经被废弃，可能是使用了writeFile函数。因此在其安装目录下寻找，后来在其index文件中找到了这个函数。修改方法如下: 12cd node_modules/hexo-filter-github-emojisvim index.js 找到带有writeFile函数的一行，应该是这行:1fs.writeFile(path.join(__dirname, 'emojis.json'), JSON.stringify(githubEmojis, null, '\t')) 将writeFile改为writeFileSync函数，即:1fs.writeFileSync(path.join(__dirname, 'emojis.json'), JSON.stringify(githubEmojis, null, '\t')) 之后再运行，警告消失。 后加现在听说作者已经修复了这个问题，所以不需要改了。 静态资源压缩网页加载速度优化，主要通过压缩网页的静态资源如JS,Html,CSS,图片等文件来达到加速效果。网上现在主要有两种，一种是直接用Hexo的插件，Hexo-Neat，还有一种是使用通用的压缩工具Gulp。这里主要使用Gulp。 安装首先是安装Gulp插件:1npm install gulp --save-dev 然后安装gulp相关插件:1234567$ npm install gulp-clean-css --save-dev$ npm install gulp-uglify --save-dev$ npm install gulp-htmlmin --save-dev$ npm install gulp-htmlclean --save-dev$ npm install gulp-imagemin --save-dev$ npm install del --save-dev$ npm install run-sequence --save-dev 配置添加一个gulpfile.js文件，在博客根目录下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485var gulp = require('gulp');var minifycss = require('gulp-clean-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');var del = require('del');var runSequence = require('run-sequence');var Hexo = require('hexo');gulp.task('clean', function() &#123; return del(['public/**/*']);&#125;);// generate html with 'hexo generate'var hexo = new Hexo(process.cwd(), &#123;&#125;);gulp.task('generate', function(cb) &#123; hexo.init().then(function() &#123; return hexo.call('generate', &#123; watch: false &#125;); &#125;).then(function() &#123; return hexo.exit(); &#125;).then(function() &#123; return cb() &#125;).catch(function(err) &#123; console.log(err); hexo.exit(err); return cb(err); &#125;)&#125;)gulp.task('minify-css', function() &#123; return gulp.src(['./public/**/*.css','public/**/*.min.css']) .pipe(minifycss(&#123; compatibility: 'ie8' &#125;)) .pipe(gulp.dest('./public'));&#125;);gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);gulp.task('minify-js', function() &#123; return gulp.src(['./public/**/*.js','!public/**/*.min.js']) .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);gulp.task('minify-img', function() &#123; return gulp.src('./public/images/**/*.*') .pipe(imagemin()) .pipe(gulp.dest('./public/images'))&#125;)gulp.task('minify-img-aggressive', function() &#123; return gulp.src('./public/images/**/*.*') .pipe(imagemin( [imagemin.gifsicle(&#123;'optimizationLevel': 3&#125;), imagemin.jpegtran(&#123;'progressive': true&#125;), imagemin.optipng(&#123;'optimizationLevel': 7&#125;), imagemin.svgo()], &#123;'verbose': true&#125;)) .pipe(gulp.dest('./public/images'))&#125;)gulp.task('compress', function(cb) &#123; runSequence(['minify-html', 'minify-css', 'minify-img'], cb);&#125;);gulp.task('build', function(cb) &#123; runSequence('clean', 'generate', 'compress', cb)&#125;);gulp.task('default', ['build']) 因为已经将hexo g生成站点文件的过程包含进去了，直接执行gulp即可。但是不知道是不是Next版本更新的原因，导致js的压缩总是出问题，暂时先删掉了runSequence中的minify-js一项，之后再作讨论。 问题解决原因找到了，是因为Gulp的uglify-js不支持ES6的语法，因此编译会出错。解决方案:先使用babel编译。 安装 1npm install --save-dev gulp-babel babel-preset-es2015 babel-core 修改gulpfile.js文件在变量定义中添加一行: 1var babel = require("gulp-babel"); 然后在.pipe(uglify())这一行前加一句:1.pipe(babel(&#123;presets: ['es2015']&#125;)) 问题解决。 替换谷歌字体库众所周知，谷歌字体库访问通常情况都非常慢，于是决定使用国内的CND加速，但是之前360的字体库已经下架了，所以使用中科大的(虽然不下架应该也不会选择它 )。修改方式:编辑主题的配置文件:1vim theme/next/_config.xml 找到fonts的设置，在host:后面填写1//fonts.lug.ustc.edu.cn 和host:中间注意保持空格。 后加中科大字体库已经挂了，谷歌字体库也经常抽风。于是采用国内CDN加速，参考于Showfom大神的一篇博客 。 修改谷歌字体库将//fonts.googleapis.com修改为国内cdn加速的库，和上面一样，找到fonts的设置，在host:后面填写 1//fonts.cat.net 替换CDNJS 开源 JS 库只需要替换 cdnjs.cloudflare.com 为 cdnjs.cat.net 即可。即： 在vendors中的jquery： 后面添加自定义的地址: 1https://ajax.cat.net/ajax/libs/jquery/3.2.1/jquery.min.js 修改Han字体的CDN由于Han字体使用的CDN是cloudflare的，国内速度比较慢，因此替换其CDN: 在han:后加: 1https://cdnjs.cat.net/ajax/libs/Han/3.3.0/han.min.css 修改其他的CDN最终修改后的配置文件内容如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: https://ajax.cat.net/ajax/libs/jquery/3.2.1/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: https://cdnjs.cat.net/ajax/libs/fancybox/3.1.25/jquery.fancybox.min.js fancybox_css: https://cdnjs.cat.net/ajax/libs/fancybox/3.1.25/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: https://cdnjs.cat.net/ajax/libs/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: https://cdnjs.cat.net/ajax/libs/lazyload/2.0.3/lazyload-min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: https://cdnjs.cat.net/ajax/libs/velocity/1.5.0/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: https://cdnjs.cat.net/ajax/libs/velocity/1.5.0/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: https://cdnjs.cat.net/ajax/libs/UAParser.js/0.7.9/ua-parser.min.js # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: https://cdnjs.cat.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: https://cdnjs.cat.net/ajax/libs/canvas-nest.js/1.0.1/canvas-nest.min.js # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: https://cdnjs.cat.net/ajax/libs/Han/3.3.0/han.min.css 然后找出网页中所有其他的使用cloudflare加速的内容，替换掉。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Nofollow</tag>
        <tag>Emoji</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题的Gitalk移植]]></title>
    <url>%2Fposts%2F4da30c7%2F</url>
    <content type="text"><![CDATA[之前是由于各种评论服务都挂了，后来采用来必力，偶尔抽了一次风，所以当时打算用Github的Issue当评论。在网上找了很多，大多是Gitment的，也照着网上的教程试了一遍，也装成功了，具体过程都添加在建站时候的一篇文档里了，并没有单独写一篇文章，地址在这。但是Gitment有个问题，对于每一篇文章都得手动去初始化，很麻烦。后来看到Gitalk，样式也挺漂亮的，于是打算尝试一下移植到Next主题上。 新建Gitalk的swig文件由于Next主题的可扩展性还算好，为了方便统一管理，尽量不修改已经存在的文件。首先创建Gitalk的swig文件，放在next/layout/_third-party/comments文件夹下，命名为gitalk.swig。内容如下1234567891011121314151617181920&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt; &lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var gitalk = new Gitalk(&#123; clientID: '&#123;&#123; theme.gitalk.ClientID &#125;&#125;', clientSecret: '&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;', repo: '&#123;&#123; theme.gitalk.repo &#125;&#125;', owner: '&#123;&#123; theme.gitalk.githubID &#125;&#125;', admin: ['&#123;&#123; theme.gitalk.adminUser &#125;&#125;'], id: location.pathname, distractionFreeMode: '&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;' &#125;) gitalk.render('gitalk-container') &lt;/script&gt;&#123;% endif %&#125; 在主题文件layout/_third-party/comments/index.swig中引入刚刚添加的文件。1&#123;% include 'gitalk.swig' %&#125; 修改主题评论代码在layout/_partials/comments.swig文件中找到最后一个if分支，应该是这两句:12&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div id="vcomments"&gt;&lt;/div&gt; 在最后一个if分支后加一个Gitalk的分支:12&#123;% elseif theme.gitalk.enable %&#125; &lt;div id="gitalk-container"&gt;&lt;/div&gt; 在主题配置文件中引入GItalk1vim themes/next/_config.xml 在其中加入:12345678gitalk: enable: true githubID: newdee repo: BlogComments ClientID: ****** ClientSecret: ****** adminUser: newdee distractionFreeMode: true 其中githubID是你的Github用户名，repo是你用来存放评论Issue的仓库，可以不是Blog的仓库。adminUser是你的用户名，主要用来初始化评论的。clientID和client_secret是你的授权客户端ID和密钥。具体获得方法是在Github的设置界面选择Authorized Github Apps，然后Register a new application，将Authorization callback URL设置为你的Blog的域名，然后就可以获得clientID和client_secret了。 基本上到这里就可以直接用了,打开页面会提示你初始化评论框。如果要设置按钮的样式，可以参照以下步骤: 新建样式文件要设置评论框的样式，可以在source/css/_common/components/third-party/文件夹下，新建一个gitalk.styl文件，向其中加入如下内容:1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; 可以根据自己的喜好添加修改样式。 引入样式文件在主题目录下的source/css/_common/components/third-party/third-party.styl文件中引入:1@import "gitalk"; Issue重复的问题到这里是可以用了的，但是初始化过程中发现Issue页面有两个一样的，后来发现是因为它把直接文章页面地址和点击阅读更多所跳转的带#more的页面当成两个页面，因此重复创建Issue了。解决方案:由于默认的id参数是location.href，可以将其改为location.pathname，即可解决当前状况。即在gitalk.swig文件中的admin下面加一行:1id: location.pathname, 至此，大功告成。不过配置完才发现，Gitalk也是需要一篇文章一篇文章的初始化的，并不能自动将所有的文章一次性初始化完成。 本地化由于Gitalk是使用UNPKG来给npm的CDN加速的，但是网络延迟有时候会稍高，可以选择直接下载js和css文件到本地。将下载的css文件放于主题目录的source/css目录下，js放于source/js/src目录下。将layout/_third-party/comments/gitalk,swig文件中的超链接两行修改一下:12&lt;link rel="stylesheet" href="/css/gitalk.css"&gt;&lt;script src="/js/src/gitalk.min.js"&gt;&lt;/script&gt; 然后就可以正常加载了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Gitalk</tag>
        <tag>Github Issue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash和Tmux的Powerline]]></title>
    <url>%2Fposts%2F1dd5cd65%2F</url>
    <content type="text"><![CDATA[Powerline可以说是一个状态提示栏，当你在终端操作各种指令的时候，状态提示可以告诉你你当前的一些信息，有时候会提高一些工作效率，不过更多时候可能只是觉得很cool吧。主要说两个Powerline，一个是Bash的（Zsh算一类），一个是Tmux的。由于在Tmux中的状态提示比较丰富了，所以不用Vim了，感觉装多了插件，Vim越来越慢了。 Bash的Powerlinepowerline-shell安装在Bash下安装Powerline，个人选择安装powerline-shell了，现在的仓库地址在这。（两者并非同一项目，Powerline-shell也不是Powerline改名后的，在此更正。）环境Ubuntu，不过与环境关系不大，直接用pip管理器安装:1pip install powerline-shell powerline-shell配置首先生成配置文件:1powerline-shell --generate-config &gt; ~/.powerline-shell.json 然后编辑配置文件，1vim ~/.powerline-shell.json 可以参照这个Demo。其中参数具体含义在Repo中的Readme上有说明。 字体库安装由于Powerline所用的字体，一般的系统字体库中并不具备，如状态提示栏中的特殊符号。包括Bash和Tumx的Powerline等，都需要字体支持，不然可能会比较丑。123git clone https://github.com/powerline/fontscd fontssh install.sh 应用Powerline字体安装完成之后需要选择所用的字体，因为用了Powerline，所以需要选择支持Powerline的字体。具体方法：首先在Terminal上的菜单里选择编辑Preference，然后在选择Profiles, 编辑所用的Profiles，再在Text Appearance中选择Custom font，在里面搜索Powerline的基本都是支持Powerline的字体了，选择自己喜欢的一款就好。到这里，Bash的Powerline就算配置好了。 Tmux的Powerline其实Powerline的配置大多类似，这里直接从官方Repo克隆下来。 下载tmux-powerline12cd ~/some/path/git clone https://github.com/erikw/tmux-powerline.git Tmux配置一般在.tmux.conf文件中添加Tmux的配置:1vim ~/.tmux.conf 向其中添加如下内容:1234567set-option -g status onset-option -g status-interval 2set-option -g status-justify "centre"set-option -g status-left-length 60set-option -g status-right-length 90set-option -g status-left "#(~/path/to/tmux-powerline/powerline.sh left)"set-option -g status-right "#(~/path/to/tmux-powerline/powerline.sh right)" 其中~/path/to/tmux-powerline/powerline.sh是克隆的tmux-powerline的目录。这些就是基本配置，已经足够了。也可以控制左右状态栏的可见性:12bind C-[ run '~/path/to/tmux-powerline/mute_powerline.sh left' # Mute left statusbar.bind C-] run '~/path/to/tmux-powerline/mute_powerline.sh right' # Mute right statusbar. 如果喜欢多窗口的Powerline可以添加下面一句话:1set-window-option -g window-status-current-format "#[fg=colour235, bg=colour27]⮀#[fg=colour255, bg=colour27] #I ⮁ #W #[fg=colour27, bg=colour235]⮀" 天气配置Tmux的状态栏的功能有:12345678910AN 和 WAN IP 地址MPD、Rhythmbox、Banshee、MOC、Audacious、cmus 等播放器的正在播放信息Gmail、Maildir、mbox 的新到邮件数电池状态天气预报系统负载、CPU 占用、持续运行时间、网络速度当前目录的 Git、SVN、Mercurial 分支日期及时间主机名称tmux 信息 但是到这里打开Tmux的时候，会显示未设置地区，所以显示不了天气。具体方法是编辑tmux-powerline的目录中文件:1vim ~/.tmux/tmux-powerline/segments/weather.sh 找到其中export TMUX_POWERLINE_SEG_WEATHER_LOCATION这个变量。里面的注释也有说明，需要你自己获取你的地区ID。1234# Your location. Find a code that works for you:# 1. Go to Yahoo weather http://weather.yahoo.com/# 2. Find the weather for you location # 3. Copy the last numbers in that URL. e.g. "http://weather.yahoo.com/united-states/california/newport-beach-12796587/" has the numbers "12796587" 不过填了自己的ID之后可能还是不能显示天气。这时候只需要调整一下语句的顺序，将export TMUX_POWERLINE_SEG_WEATHER_LOCATION=&quot;2137109&quot;这句话放到第一个if语句前面，最后开起来应该是这样:1234TMUX_POWERLINE_SEG_WEATHER_DATA_PROVIDER_DEFAULT="yahoo"TMUX_POWERLINE_SEG_WEATHER_UNIT_DEFAULT="c" TMUX_POWERLINE_SEG_WEATHER_UPDATE_PERIOD_DEFAULT="600"export TMUX_POWERLINE_SEG_WEATHER_LOCATION="2137109" 再回到Tmux，应该恢复正常了。进行到这里，基本上算是大功告成了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>bash powerline</tag>
        <tag>tmux powerline</tag>
        <tag>powerline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPv4下使用IPv6]]></title>
    <url>%2Fposts%2F8544442c%2F</url>
    <content type="text"><![CDATA[在IPv4环境下使用IPv6。当前测试所用系统:ubuntu。因为暂时离开学校，而IPv6目前尚未普及，只有部分高校有所搭建，但希望访问以前的PT站，因此这里记录一下之前的“4 to 6” 的搭建过程。目前所用方法暂时有两种有效，加上SS代理，那就是三种了。 使用miredo网络工具miredo主要用于BSD和Linux的IPV6 Teredo隧道链接，可以转换不支持IPV6的网络连接IPV6，内核中需要有IPV6和TUN隧道支持。用法参数见其WIKI直接用命令行比较方便，这个也免去了很多复杂的配置，具体过程如下: 安装miredo12sudo apt updatesudo apt install miredo 这个很简单，安装完成之后启动就可以创建一个”4 to 6”的虚拟转换网卡。1sudo miredo 使用ifconfig可以查看到多了一个网卡：123456789teredo Link encap:UNSPEC HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 inet6 addr: 2001:0:53aa:64c:20e0:6050:861c:ebe4/32 Scope:Global inet6 addr: fe80::7d24:d8ab:cc69:a96b/64 Scope:Link inet6 addr: fe80::ffff:ffff:ffff/64 Scope:Link UP POINTOPOINT RUNNING NOARP MULTICAST MTU:1280 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:1 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:500 RX bytes:0 (0.0 B) TX bytes:48 (48.0 B) 然后ping一下Google的IPv6地址，应该是可以ping通了。1ping6 ipv6.google.com 不过到这里还没完,ipv6还可以用来访问一些外面的网站。 修改Hosts文件如果本来就有ipv6地址，前面的就都不用做了。Hosts文件参考最新地址，见其Repo。也可以直接拷贝Hosts文件内容，地址在这。因为内容比较多，复制起来比较麻烦，可以直接保存为txt，比如hosts.txt。然后，1cat hosts.txt &gt;&gt; /etc/hosts 然后就可以直接访问Google，YouTube等网站了。不过由于是4to6的网络，没有自己的ipv6地址，所以速度不会太快。 HE.net方案另一种ipv6代理是He.net方案，可以直接访问其官网。 注册首先是注册Tunnel broker，地址在这，里面的邮箱和密码填好就可以，其余的随便填一下。然后进入你的Tunnel页面。 创建Tunnel点击User Function中的Create Regular Tunne，然后选择一个地区的Tunnel服务器，一般选延迟最小的，可以通过ping判断。虽然是在亚洲，但东京和HK的延迟还是很高的，所以不要通过地点判断。然后就是输入你的IPv4地址，注意是外网IP。点击创建，创建成功后进入Example Configuration， 选择你的操作系统，它会给出一段代码，用于配置你的电脑的网卡的。我这里是Ubuntu，所以选择Debian/Ubuntu，然后给出的代码如下:12345678auto he-ipv6iface he-ipv6 inet6 v4tunnel address ****** netmask 64 endpoint ****** local ****** ttl 255 gateway ****** 这个就是网卡的配置，相当于新建一个自动启动的网卡，然后分配了ip。直接复制粘贴到interface文件中即可:1sudo vim /etc/network/interface 注意，如果电脑没有公网IP，则需要把local的IP地址改为你的私有地址，如192.168.2.100 启用网卡添加完之后，需要启用刚刚配置的4 to 6网卡，1sudo ifup he-ipv6 然后就可以访问V6的PT站和外面的一些网站了。当然，速度虽然取决与你的服务器地区，但总体速度也不会很快。 梯子代理IPv6这个之前搭建梯子的时候应该说过了，配置比较简单，如果用SS的 话，直接在SS服务器的configure文件中将server地址改为::即可：1server: "::" ::会同时转发V6和V4流量。当然，前提是在选择服务器的时候启用了IPv6地址。如果服务器延迟低，IPv6下载也会很快的。不过如果用VPS只是为了搭建一个SS，其余的什么都不管，一旦受到Dos-attack，可能流量就一晚上走完了。DDos易攻难守，而且这对于提供虚拟机的服务商也是一种损失。所以最好还需要一点网络和服务器维护的手段。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>IPv6</tag>
        <tag>隧道</tag>
        <tag>HE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg常用命令]]></title>
    <url>%2Fposts%2F3c4e255%2F</url>
    <content type="text"><![CDATA[又是一阵时间没回来了，中间偶然获得了You-get这个神器，果然py大法好。但是善难养成，恶易成习。坚持太难了。还值得一提的是，vimium这个chrome插件，使得chrome浏览器基本能摆脱鼠标的束缚。当然，只是基本。还有免费的流程图绘制，Draw.io.然后在用You-get的时候发现了pysocks和tsocks两个小工具。有梯子会很有用。还有就是script录制终端和scriptreplay播放录制终端。You-get需要依赖FFmpeg，当我安装You-get的时候，发现FFmpeg已经有了，记不得什么时候装的。既然没印象，那应该就不是什么困难的事了。那FFmpeg安装就免介绍了。顺便记一下，因为又有一段时间没来阁子更新，hexo貌似又出问题了，试了很多方法没解决，npm和nodejs也是卸了重装，最后确定不是这个问题，然后又重装hexo，结果发现还是一样的bus error。后来新建了一个文件夹用hexo，发现正常初始化，所以大概是package的版本不兼容导致的了。于是重新装一下package.json文件里的插件。顺便提一件事，今天发现手环断了。现在重新继续。 简要介绍FFmpeg 的官网在这,github主页。 FFmpeg的项目主要有几个部分: 视频文件命令行转换工具。 ffserver基于Http、RTSP用于实时广播的多媒体服务器，也可以支持时间平移。 ffpaly用sdl和FFmpeg开发的一个简单的媒体播放器。 libavcodec包含了所有的FFmpeg音视频解码的库。为了保证最优性能和高复用性，大多数编码器从头开发的。 libavformat包含了所有普通音视频格式的解析器和产生器的库。比较流行的播放器，QQ影音，Mplayer,KMPlayer,暴风影音，射手影音都是以FFmpeg作为内核的视频播放器。 转码ffmpeg -i input.avi -b:v 640k output.ts参数说明： -i是输入参数，-b是比特率设置，缺省200kb/s.直接ffmpeg -i input.avi是查看视频信息。 播放媒体直接一个ffplay命令就可以，也可以尝试在终端的文本界面打开这个命令试试。 查看文件格式ffprobe命令 视频合并1ffmpeg -i concat "input1.ts|input2.ts|3.ts" -vcodec copy merges.ts 视频剪切1ffmpeg -i 1.ts -ss 00:00:00 -t :10:00 result.ts 提取图片从视频中提取图片:1ffmpeg -vcodec rawvideo -f rawvideo -pix_fmt gray -s 720x576 -i sample.ts gray -f image2 -vcodec bmp %4d.bmp 添加logo1ffmpeg -i 10.20.ts -vf "movie=../resource/youku_logo.png [logo]; [in][logo] overlay=main_w - overlay_w - 10:10 [out]" -q:v 1 -vcodec mpeg4 10.20.logo.ts 视频旋转1234567ffmpeg -i demo.mp4 -vf "transpose=1" out.mp40 = 90CounterCLockwise and Vertical Flip (default)1 = 90Clockwise2 = 90CounterClockwise3 = 90Clockwise and Vertical FlipFor 180 you can use -vf "transpose=2,transpose=2" 参数说明附上FFmpeg的参数说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100-formats 输出所有可用格式-f fmt 指定格式(音频或视频格式)-i filename 指定输入文件名，在linux下当然也能指定:0.0(屏幕录制)或摄像头-y 覆盖已有文件-t duration 记录时长为t-fs limit_size 设置文件大小上限-ss time_off 从指定的时间(s)开始， [-]hh:mm:ss[.xxx]的格式也支持-itsoffset time_off 设置时间偏移(s)，该选项影响所有后面的输入文件。该偏移被加到输入文件的时戳，定义一个正偏移意味着相应的流被延迟了 offset秒。 [-]hh:mm:ss[.xxx]的格式也支持-title string 标题-timestamp time 时间戳-author string 作者-copyright string 版权信息-comment string 评论-album string album名-v verbose 与log相关的-target type 设置目标文件类型("vcd", "svcd", "dvd", "dv", "dv50", "pal-vcd", "ntsc-svcd", ...)-dframes number 设置要记录的帧数视频选项:-b 指定比特率(bits/s)，似乎FFmpeg是自动VBR的，指定了就大概是平均比特率-bitexact 使用标准比特率-vb 指定视频比特率(bits/s)-vframes number 设置转换多少桢(frame)的视频-r rate 帧速率(fps) （可以改，确认非标准桢率会导致音画不同步，所以只能设定为15或者29.97）-s size 指定分辨率 (320x240)-aspect aspect 设置视频长宽比(4:3, 16:9 or 1.3333, 1.7777)-croptop size 设置顶部切除尺寸(in pixels)-cropbottom size 设置底部切除尺寸(in pixels)-cropleft size 设置左切除尺寸 (in pixels)-cropright size 设置右切除尺寸 (in pixels)-padtop size 设置顶部补齐尺寸(in pixels)-padbottom size 底补齐(in pixels)-padleft size 左补齐(in pixels)-padright size 右补齐(in pixels)-padcolor color 补齐带颜色(000000-FFFFFF)-vn 取消视频-vcodec codec 强制使用codec编解码方式('copy' to copy stream)-sameq 使用同样视频质量作为源（VBR）-pass n 选择处理遍数（1或者2）。两遍编码非常有用。第一遍生成统计信息，第二遍生成精确的请求的码率-passlogfile file 选择两遍的纪录文件名为file-newvideo 在现在的视频流后面加入新的视频流 高级视频选项-pix_fmt format set pixel format, 'list' as argument shows all the pixel formats supported-intra 仅适用帧内编码-qscale q 以&lt;数值&gt;质量为基础的VBR，取值0.01-255，约小质量越好-loop_input 设置输入流的循环数(目前只对图像有效)-loop_output 设置输出视频的循环数，比如输出gif时设为0表示无限循环-g int 设置图像组大小-cutoff int 设置截止频率-qmin int 设定最小质量，与-qmax（设定最大质量）共用，比如-qmin 10 -qmax 31-qmax int 设定最大质量-qdiff int 量化标度间最大偏差 (VBR)-bf int 使用frames B 帧，支持mpeg1,mpeg2,mpeg4音频选项:-ab 设置比特率(单位：bit/s，也许老版是kb/s)前面-ac设为立体声时要以一半比特率来设置，比如192kbps的就设成96，转换 默认比特率都较小，要听到较高品质声音的话建议设到160kbps（80）以上。-aframes number 设置转换多少桢(frame)的音频-aq quality 设置音频质量 (指定编码)-ar rate 设置音频采样率 (单位：Hz)，PSP只认24000-ac channels 设置声道数，1就是单声道，2就是立体声，转换单声道的TVrip可以用1（节省一半容量），高品质的DVDrip就可以用2-an 取消音频-acodec codec 指定音频编码('copy' to copy stream)-vol volume 设置录制音量大小(默认为256) &lt;百分比&gt; ，某些DVDrip的AC3轨音量极小，转换时可以用这个提高音量，比如200就是原来的2倍-newaudio 在现在的音频流后面加入新的音频流字幕选项:-sn 取消字幕-scodec codec 设置字幕编码('copy' to copy stream)-newsubtitle 在当前字幕后新增-slang code 设置字幕所用的ISO 639编码(3个字母)Audio/Video 抓取选项:-vc channel 设置视频捕获通道(只对DV1394)-tvstd standard 设转换为flv: ffmpeg -i test.mp3 -ab 56 -ar 22050 -b 500 -r 15 -s 320x240 test.flv ffmpeg -i test.wmv -ab 56 -ar 22050 -b 500 -r 15 -s 320x240 test.flv 转换文件格式的同时抓缩微图： ffmpeg -i "test.avi" -y -f image2 -ss 8 -t 0.001 -s 350x240 'test.jpg' 对已有flv抓图： ffmpeg -i "test.flv" -y -f image2 -ss 8 -t 0.001 -s 350x240 'test.jpg' 转换为3gp: ffmpeg -y -i test.mpeg -bitexact -vcodec h263 -b 128 -r 15 -s 176x144 -acodec aac -ac 2 -ar 22500 -ab 24 -f 3gp test.3gp ffmpeg -y -i test.mpeg -ac 1 -acodec amr_nb -ar 8000 -s 176x144 -b 128 -r 15 test.3gp]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodeppt入坑]]></title>
    <url>%2Fposts%2F9b44f6cc%2F</url>
    <content type="text"><![CDATA[没错，又来入坑了。昨天刚刚尝试了用reveal.js渲染Markdown的幻灯片，效果还行，但是每次都要在Html文档里面编辑，略嫌麻烦，强迫症患者的理想目标是，找到一个工具，在写好的MD文档之外，调用这个工具，即可渲染得到PPT。而关于PPT的风格主题、模板以及其他的，则可以在工具中指定参数。不过挺难找的，而当初也没好好的学学js，书看了不到一半就放弃了。今天就来试试这个自称最好的Nodeppt。详细介绍见这里,gayhub的repo在这。 开始首先安装Nodeppt注意，需要先安装NodeJS。 1npm install -g nodeppt 然而在npm的过程中，fetch等了很久，网上说可以换成淘宝的源，后来试了一下，是挺快的，然后再切换回原来的源即可。不过还是安装失败。不过问题在于没有加sudo然后启动 1234# 获取帮助nodeppt start -h# 绑定端口nodeppt start -p &lt;port&gt; 或者：1nodeppt start -p port -d path/for/ppts 如: 12345nodeppt start -p 8090 -d path/for/ppts# 绑定host，默认绑定0.0.0.0nodeppt start -p 8080 -d path/for/ppts -H 127.0.0.1# 使用socket通信（按Q键显示/关闭二维码，手机扫描，即可控制）# socket须知：1、注意手机和pc要可以相互访问，2、防火墙，3、ip 启用socket控制有两种方式： 使用url参数： http://127.0.0.1:8080/md/demo.md?controller=socket 使用start命令行：nodeppt start -c socket在页面按键【Q】显示控制url的二维码和控制链接（需要隐身窗口打开），手机上可以使用左右touch滑动和摇一摇切换下一页。 最后创建Slide可以直接用Nodeppt创建，就像hexo创建文档一样。nodeppt create ppt-name接下来就是按照提示输入基本信息，默认就是MD文件，如果需要Html，可以在名字后面加上后缀类型。 扩展语法Nodeppt在支持Markdown基本语法之外，还有一些扩展。 配置基本配置：12345678910title: 这是演讲的题目speaker: 演讲者名字url: 可以设置链接transition: 转场效果，例如：zoomin/cards/slidefiles: /css/theme.moon.css，尾部的文件theme: moon //皮肤highlightStyle: monokai_sublime //hljs的样式headFiles: //头部的文件usemathjax: //如果为yes，则引入mathjax，默认不建议开启，导出文件太多date: 2017年7月26日 另外有：colors-moon-blue-dark-green-light 共六套自带皮肤可供选择。关于目录：可以直接在slide所在根目录添加img、css和js文件夹并添加到引用路径，Nodeppt默认可以找得到的。 排版 使用[slide]标签来分页，如: 1slide style="background-image:url('/img/bg1.png')"] 使用---分界 单条动画 12345使用方法：列表第一条加上 ` &#123;:&amp;.动画类型&#125;``（注意空格）* 上下左右方向键翻页 * 列表支持渐显动画 &#123;:&amp;.moveIn&#125; * 支持多级列表 * 这个动画是moveIn 目前支持的单条动画效果包括： moveIn fadeIn bounceIn rollIn zoomIn 转场动画Markdown的顶部配置可以设置，以方括号标注。magic是在一页幻灯片中播放多个子页面，页面之间进行动效切换，但是slide不翻页（类似keynote的magicmove），使用[magic]标签包裹，子页面之间使用====间隔。[magic]标签支持全部转场动效，效果比较好的有： zoomin/zoomout move circle earthquake newspaper cover-diamond horizontal3d/horizontal vertical3d cover-circle 1234567891011121314151617181920212223242526[slide][magic data-transition="earthquake"]## 标题1-----&lt;div class="columns3"&gt; &lt;img src="/assets/searchbox-fe-framework-and-product/Snip20151209_11.png" height="450"&gt; &lt;img src="/assets/searchbox-fe-framework-and-product/Snip20151209_10.png" height="450"&gt; &lt;img src="/assets/searchbox-fe-framework-and-product/Snip20151209_12.png" height="450"&gt;&lt;/div&gt;====## 标题2-----&lt;div class="columns3"&gt; &lt;img src="/assets/searchbox-fe-framework-and-product/Snip20151209_11.png" height="450"&gt; &lt;img src="/assets/searchbox-fe-framework-and-product/Snip20151209_10.png" height="450"&gt; &lt;img src="/assets/searchbox-fe-framework-and-product/Snip20151209_12.png" height="450"&gt;&lt;/div&gt;====## 标题3-----&lt;div class="columns3"&gt; &lt;img src="/assets/searchbox-fe-framework-and-product/Snip20151209_11.png" height="450"&gt; &lt;img src="/assets/searchbox-fe-framework-and-product/Snip20151209_10.png" height="450"&gt; &lt;img src="/assets/searchbox-fe-framework-and-product/Snip20151209_12.png" height="450"&gt;&lt;/div&gt;[/magic] 如：[slide data-transition=&quot;vertical3d&quot;] 与Html语法混编 内部回调除了使用Html的语法：[code][/code]之外，提供了格外的函数： 12in-callback 切换来...out-callback 切换走... 表格与默认的Markdown语法类似。 在线音乐以及其他的网页插入使用iframe语法插入 导出文件可以选择到处Html用于网页展示或者pdf用于保存。但根据Nodeppt官方的说法，导出pdf不再支持，请使用chrome打印服务另存为pdf，url中添加?print=1，然后使用chrome打印 ctrl+P。不过主要目的自然是用于网页展示了，pdf随时随地可以生成。导出Html文档:123456789# 获取generate帮助nodeppt generate -h# 使用generate命令nodeppt generate filepath# 导出全部，包括Nodeppt的js、img和css文件夹# 默认导出在publish文件夹nodeppt generate ./ppts/demo.md -a# 指定导出文件夹nodeppt generate ./ppts/demo.md output/path -a 导出目录下所有ppt，并且生成ppt list首页： 1nodeppt path output/path -a Demo演示123执行 nodeppt start访问 http://127.0.0.1:8080/在线demo： http://js8.in/nodeppt/ 好了，写了这么多，终于要点题了。在我尝试安装完成之后，发现Nodeppt并没有渲染成功，或许大概是已经停止更新了吧。渲染之后，浏览器打开是酱紫的：入坑完毕。不过后来又找了个Marp，直接转换倒是很方便，可以导出为PDF，但是没有找到导出html的功能，有点遗憾。现在就连Markdown语法都是参差不齐，因为应用不同，所以语法扩展不同，希望能尽快形成一个标准，用md渲染幻灯片的技术普及民众。不过最后还是下了个cleaver来渲染，基本上是可以了。效果在这里。 当然，我又卸载了这个cleaver。因为他和clear命令太像了！！！害得我都没法用补全命令clear。Aaron早逝，但Markdown正无声的占领着这个世界。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>ppt</tag>
        <tag>nodeppt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown制作幻灯片]]></title>
    <url>%2Fposts%2F14461a6d%2F</url>
    <content type="text"><![CDATA[写完博客之后，考虑的就是怎么做幻灯片了。主要考虑的还是用Markdown语法写幻灯片，调查了很多，从remark.js到landslide，从impress.js到show.js，再到deck.js、Fathom.js、Jmpress.js等，五花八门，眼花缭乱，最后还是随机选了一个，reveal.js。 准备工作 reveal.js: Markdown渲染工具 gayhub: 上传 rawgit: 将Github中的html正常加载，并添加CDN 开始Clone或者Fork官方Repo1git clone https://github.com/&lt;you account id&gt;/reveal.js README中有很多配置编辑的方式可供参考， 现在有了一个可运行的reveal.js模板，运行根目录下的index.html即可预览 编辑默认index文档 打开index.html，找到slide的标签，&lt;div class=&quot;slides&quot;&gt;，即为幻灯片正文的开始，在此之下，添加几行代码，打开Markdown的编辑模式:12345&lt; section data-markdown data-separator="---" data-separator-vertical="--"&gt; &lt; script type="text/template"&gt; ### 你要写的正文内容 &lt; /script&gt;&lt; /section&gt; 现在可以用Markdown编辑幻灯片内容了。 基本编辑方式： --- 横向分页 -- 纵向分页，通常一列可以作为一个章节。 # 标题 - 列表 插入图片使用基本的m arkdown插图大法就可以完成。考虑到有时候的网络环境，还是保存在本地再添加比较好。![](upload/pic.jpg)这种格式即可。如果要调整排版和位置，则需要写html的语法。 插入视频这里时候不早了，电脑上没有视频，也懒得插入，下次会自己做一个的，先借用前人的代码，省去从YouTube上下载。1&lt;section data-background-video="your_video_name.webm"&gt; 对外访问将编辑好的reveal.js项目提交到Github上:123git add .git commit -m "add my slides"git push origin master 这里本来并不想写git的命令，因为太基础了，不过送佛送西，就这样吧。然后就可以从网页访问刚刚上传的repo了，我就做了个简单的Helloword。不过到现在位置，我们也仅仅是编辑了一下里面的html，幻灯片并没有被渲染，而是以源代码方式展示出来。这时候使用第三方工具将代码库中的html文件按照期望方式对外暴露使其访问。 打开http://rawgit.com/,输入 https://github.com/&lt;your github id&gt;/cd-in-cloud-reveal-js/blob/master/index.html 得到 production url 和 development url 两个链接。Production url 是带有 CDN 的，和 github 的同步会存在一定的延迟， developement url 的更新会及时一些，不过访问速度相对会没那么快。 然后就是访问生成的HelloWorld,如下所示。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>PPT</tag>
        <tag>revealJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SS服务器搭建]]></title>
    <url>%2Fposts%2F1420aa47%2F</url>
    <content type="text"><![CDATA[在ubuntu环境下的SS服务器搭建。 购买服务器至于翻墙的原因，各人有各人的说法，这堵墙也算是有利有弊，这里我不想多说什么。但Google和Google Scholar，YouTube，以及其他的一些coding资源站的限制访问，大概可以成为很多人有这个需求的起因。考虑到翻墙的人口基数，免费的服务基本上已经快要退出战场了。所以有时候还是花点钱靠谱一些。这类的服务器其实挺多的，用的比较多的是亚马逊的，但是个人感觉太贵，后来在PAC的开源项目中发现了vultr，个人感觉挺便宜的，也算是支持一下免费的PAC，于是准备购买一个vultr服务器， 选择配置这里的配置是ubuntu16.04，1核CPU，40G的SSD硬盘，流量一个月2000G，服务器是东京的服务器，价格是10刀每月，很便宜了，流量基本用不完。而且是按小时计费的，如果你刚刚买了，不喜欢，可以立马撤销掉，也不会花多少钱。然后下单，基本上绑定一张卡就行了，然后它会给你关于这个服务器的ip和密码，密码是随机生成的，你可以自己登陆进去修改，也可以在安装系统之前把你电脑的ssh-key的公钥给他，好免密码登录，不过我试了，好像没起作用。他也有提供网页登录窗口，你登录进去直接操作，不过我比较喜欢本地的操作，就在电脑上ssh 远程登录，用户名是root。然后可以配置一下ssh免密码登录，这个步骤是可选的，而且也非常简单，不清楚的话直接网上搜一下就行了。 搭建环境登陆进去后开始配置环境123apt updateapt install python-pipapt install shadowsocks 更新12pip install --upgrade pippip install --upgrade shadowsocks 这里提示要先装setuptools，于是1pip install setuptools 然后重新升级shadowsocks1pip install --upgrade shadowsocks 添加配置文件我之前是直接在本地写好了，然后直接上传，配置文件内容如下，密码和端口根据需求可以比较随意修改，但不能使用已经被占用的端口。加密协议也可以修改，具体协议根据自己需要。12345678910111213 1 &#123; 2 "server":"0.0.0.0", 3 "local_address": "127.0.0.1", 4 "local_port":1080, 5 "port_password": &#123; 6 "4490": "password", 7 "4491": "password", 8 "4496": "password" 9 &#125;,10 "timeout":300,11 "method":"aes-256-cfb",12 "fast_open": false13 &#125; 首先在服务器端打开端口：1nc -l 1992 &gt; shadowsocks.json 然后在本地输入1nc IP_ADDRESS 1992 &lt; shadowsocks.json 这里的IP_ADDRESS改成自己服务器的ip，端口也可以自己改，一样就行。最后移动到/etc目录下1mv shadowsocks.json /etc/shadowsocks.json 配置完成 开启socks服务运行命令1ssserver -c /etc/shadowsocks.json 出现错误，1-bash: /usr/bin/ssserver: No such file or directory 原因大概是升级shadowsocks之后/usr/bin目录下找不到可执行文件的链接了，可以自己创建一个软连接，用ln命令，也可以直接找到可执行文件位置，直接运行，我比较懒，就选第二种方法了。1whereis ssserver 显示1ssserver: /usr/local/bin/ssserver /usr/share/man/man1/ssserver.1.gz 可以看到，在/usr/local/bin目录下，于是直接运行1root@vultr:~# /usr/local/bin/ssserver -c /etc/shadowsocks.json -d start 到这里，应该就已经搭好了可以用客户端测试一下。显示延迟一百多ms，比较快了，配置到这里就ok了。 懒人部署方法也可以直接使用脚本一键部署，逗比云在这方面写过很多脚本了，可以直接拿过来用。买好服务器之后，直接执行: 1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 主要功能: 支持 限制 用户速度 支持 限制 端口设备数 支持 显示 当前连接IP 支持 显示 SS/SSR连接+二维码 支持 切换管理 单/多端口 支持 一键安装 锐速 支持 一键安装 BBR 支持 一键封禁 垃圾邮件(SMAP)/BT/PT 另外，还有个多人的脚本: 1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 主要功能: 支持 限制 用户速度 支持 限制 用户设备数 支持 限制 用户总流量 支持 定时 流量清零 支持 显示 当前连接IP 支持 显示 SS/SSR连接+二维码 支持 一键安装 锐速 支持 一键安装 BBR 支持 一键封禁 垃圾邮件(SMAP)/BT/PT到这里基本上都照着来就行了，另外如果要使用IPv6代理，最好不要使用一剑封禁，但是垃圾邮件端口还是需要封禁，不然第二天流量就没了。可以用单独的端口封禁脚本: 1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ban_iptables.sh &amp;&amp; chmod +x ban_iptables.sh &amp;&amp; bash ban_iptables.sh 选择封禁垃圾邮件端口就行。最后可以在脚本中加入BBR加速，优化视频播放速度。至此结束。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>ss</tag>
        <tag>vultr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tmux的会话配置]]></title>
    <url>%2Fposts%2F8cfd1ed2%2F</url>
    <content type="text"><![CDATA[受一个外国朋友的影响，用了几个月的Tmux.简直就像打开了新世界的大门。Tmux结合Vim的体验，Tmux控制多个终端的体验，已经无法割舍了。当然，当初也是受这位外国小哥的影响，让我捡起了放弃已久的Vim，并爱上了它。不过用了一段时间，发现虽然可以用tmux attach恢复刚刚关闭的会话，但关机之后并不保存，于是在网上找了一些方法来保存这些会话，好让下次开机依然可以恢复原来的会话。 安装Tmux插件管理工具1git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 后面的文件夹是自己新建的，刚安装好Tmux的时候，其home目录下的配置文件也需要自己新建。和Vim类似，Tmux 也有一个插件管理系统，叫 Tmux Plugin Manager。之后修改Tmux配置文件： 123456789# List of pluginsset -g @plugin 'tmux-plugins/tpm'set -g @plugin 'tmux-plugins/tmux-sensible'# Other examples:# set -g @plugin 'github_username/plugin_name'# set -g @plugin 'git@github.com/user/plugin'# set -g @plugin 'git@bitbucket.com/user/plugin'# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)run '~/.tmux/plugins/tpm/tpm' 记得run的语句一般要放在配置文件的最后一行。 安装默认插件目前添加了两个插件:tpm和tmux-sensible，是官方推荐的插件，现在已经clone了tpm，下一步就是安装tmux-sensible这个插件。在Tmux中，安装插件的一些快捷命令如下: 123prefix shift-i # installprefix shift-u # updateprefix alt-u # uninstall plugins not on the plugin list 现在安装tmux-sensible插件: 12345Already installed "tpm"Installing "tmux-sensible""tmux-sensible" download successTMUX environment reloaded.Done, press ESCAPE to continue. 安装成功。 安装tmux Resurrect &amp; Continuum插件Tmux Resurrect 和 Tmux Continuum 这两个 Tmux 插件在gayhub上都有托管，主要目的就是解决Tmux的会话备份和恢复。首先，修改配置文件，加上: 1set -g @plugin 'tmux-plugins/tmux-resurrect' 然后prefix+shift+i，进入如下所示界面， 123456Already installed "tpm" [0/0]Already installed "tmux-sensible"Installing "tmux-resurrect" "tmux-resurrect" download successTMUX environment reloaded.Done, press ESCAPE to continue. 至此，resurrect插件安装成功。但是Tmux 的resurrect插件都是靠手动备份的，为了实现自动备份，可以配合tmux continuum插件使用，因此现在安装tmux continum插件: 1set -g @plugin 'tmux-plugins/tmux-continuum' 然后又是一样的结果: 12345678Already installed "tpm" [0/0]Already installed "tmux-sensible"Already installed "tmux-resurrect"Installing "tmux-continuum" "tmux-continuum" download successTMUX environment reloaded.Done, press ESCAPE to continue. 好了，又安装成功了。 Recurrect的插件配置修改配置文件，添加几行配置:123456#tmux-resurrectset -g @resurrect-save-bash-history 'on'set -g @resurrect-capture-pane-contents 'on'set -g @resurrect-strategy-vim 'session'# set -g @resurrect-save 'S'# set -g @resurrect-restore 'R' 至此，已经设置了保存键入的历史命令，以及面板布局和Vim状态。Tmux的手动保存和加载快捷键是:12prefix Ctrl-s # save tmux session to local fileprefix Ctrl-r # reload tmux session from local file 自动备份配置在配置文件中加上continuum的配置参数，默认15分钟一次，可以根据自己的需要修改。 1set -g @continuum-save-interval '60' 自动备份完成，会在Tmux启动时还原。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tmux</tag>
        <tag>recurrect</tag>
        <tag>continuum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回来]]></title>
    <url>%2Fposts%2Fc33ea426%2F</url>
    <content type="text"><![CDATA[尘封的往事不必再提，忘却的岁月如风而逝。 其实这两句话除了能显得中二之外毫无意义，因为旧事依然还会提，慵懒或激情的年纪还是会想起。放在这里，只觉得当做开头不错。QQ空间和朋友圈还是放弃了。大概因为越来越多的好友，而由于本人不喜欢营销，所以通常会屏蔽大部分内容，所以自己也尽量不发需要人点赞转发的内容，以至于除此之外，感觉很多个人的想法，实在不大方便让所有人看见，写日志和说说大抵会显得矫情，选择性屏蔽功能多却麻烦。而随着年岁渐长，也渐渐发现，不必所有感受说与人听，不必所有情怀显得高尚，也不必去刻意要求别人了解自己，况平时不善言辞，正式场合不苟言笑，木讷的很，又何用在众人眼下扮着理想的男主呢？终于决定要重回博客。不过看到自己以前心血来潮的时候搭建的博客，先是各种修改主题文件，本来是想着定制自己的主题，于是便选了一套透明风格的，慢慢的解决了各种问题，后来添加很多没有的功能，弄着弄着，感觉用hexo生成的时间都长了一倍，当时觉得的freestyle，后来感觉难看极了。于是放弃了自己的主题，找许多简约朴实风格的模板主题，然后又是各种折腾，功能阉割，最后又是那样惨不忍睹，后来索性就放弃了这个博客，也不记得多久没维护了。重新配置博客的过程也当是重新熟悉一下当初搭建过程，电脑重装过很多次系统了，所以hexo也要重装，然后便是重新熟悉一下markdown语法了。于是稍加修葺，重新定居于此，改名为“阁子”。于是用这废话累牍作其重生之记。大抵也是心中不快，却忧谗畏讥，不敢私语，只能回到自己阁子里来提笔乱书。研究生阶段便是如此，以至于我在读研期间一直在思考着我到底是否适合读研。刚开始的一日一询，步步紧逼，到后来的不闻不问，放之任之，几年下来，始终没有任何产出。研究生生活便是这般苦闷，以至尘埃既定，花开无果，时常想起，便免不了落些个郁郁寡欢。本来这些废话是准备昨天说的，不过昨天刚准备写，就被一群人拉去酒吧了，生平第一次去酒吧，喝酒，打台球，喝酒，掷骰子，喝酒，唱歌跳舞，喝酒。大概凌晨四点，打车回家。当时准备回来继续写这个的，但发现电脑不在宿舍，于是睡了一觉，便到现在了。 回归于此，看到的人不要太在意，说的有错不要太放在心上，我都这把年纪了，世界观是改不掉的了。至于什么微信二维码的接口，已经关掉了，没有指望从各位手里筹到一个鸡腿。当然，倘若有熟人，也请装作不认识罢，反正我也不会知道。不过如果真有兴趣打赏，嘿嘿嘿嘿，那个，about页面有个人简历，去那里找找。 阁子无光，不见日月。诳语胡诌，未知春秋。 “ただいま！”]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[镜语]]></title>
    <url>%2Fposts%2F48f0e3fe%2F</url>
    <content type="text"><![CDATA[久不动笔，有时候总想说点什么，但是最后不知是碍于什么，也许是怕人看，也许是怕人了解自己，然后投来鄙夷的眼光。不过想到自己好歹也搭建了一个博客，或许可以在没有人知道的地方，尽情的释放自己。 这么想已经很久了，但是每次只是花费了半分钟这么想。以至于现在突然兴起，连题目都想不出来叫啥，所以只能先废话着，等到末了看看能不能尽量少选几个字一言蔽之。 走在路上的时候，好像一直在思考，思考着以后该怎么办，思考着如何才能不浪费时间，周围的经常没有话唠，偶尔聊聊几句。昏暗的路灯下，大家都安静走着，只有树上的黑鸦偶尔叫几声，或是拍拍翅膀。还有落地的声响，是它们的白翔。 现在北京已经是十二月下旬了，马上就要进入春运抢票时间了，不管是学校还是公司，应该都要开始年度总结了。但现在却越来越怕这件事了，每次总结都会发现了浪费了好多时间，都会暗自下决定接下来好好学习，然后便是不断循环着的愧疚自责，不断循环着的下定决心。最后便是越来越怕自己了，或者我会指着镜子问为什么要骗我？为什么要让自己意识到这些，却带不来任何改变？ 明明看着电视里的那些不公平的事，你那么气愤。 然而，最终你还是没能改变导演既定的剧本。 这只是电视，只是剧本，你这样安慰着你。面对所有的该与不该，对于自己的剧本，你依然无法插手。迷茫，愤怒，惊醒，奋斗，迷茫，如此往复。总会想着自己奋斗的初衷，什么时候起已经无法成为动力。总是嘲笑所谓的梦想，到底是为了欺人还是骗自己。为什么当初能坚持一件多少人坚持不了的事，现在做什么都是半途而废？为什么看到自己的无能都是不甘，却还是让自己一如既往？ 不知道从什么时候起，那么的讨厌鸡汤，不知道为什么人非得带着积极的情绪活下去，不知道为什么世间的真理都是需要乐观，也不知道我是怎样成为这样一个阴暗的人的。然而我所知道的是，我却在讨厌鸡汤的同时却也讨厌自己。 人总是在追求幸福，而世间的不幸，正是伴随着这些幸福而生。 当你看到或想到别人的不幸，你才发现自己的幸福；当你看到或想到自己的不幸，也会觉得他人身在福中。 镜子不说话，你们又归于沉默。]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站，阁子记]]></title>
    <url>%2Fposts%2F6ed4d3bc%2F</url>
    <content type="text"><![CDATA[丙申九月，建站小记。 这两天趁着双休，学着搭了一下自己的blog，利用的是github的托管页面，用的是hexo的模板，申请了一个免费域名，自己添加了一些工具之类的，再准备陆续把以前自己在CSDN中的blog搬过来。 不知道有没有人能看得到，好像添加搜索那部分还有点问题，sitemap的url报错，不过总算是自己的空间了，虽然还是github提供的，今天忙这个两顿饭都忘记准时吃了，都是吃的汉堡，虽然有点累，但是开辟自己的空间的感觉真的很不错。 不过不知道能不能坚持，我对自己向来是不惮报以最坏的期望的，多少年都在证明这样做的正确性。不过对于进来的人，献上欢迎的花儿，还有飞吻。 现在记一下，博客搭建过程。安装Nodejs和git自然不用多说。然后选择主题，我选择的是一个透明的主题，不过这个主题的作者貌似很懒，只有透明效果。然后布局和插件自己布置。关于访问统计，一共用了百度统计/谷歌统计/腾讯统计，不过这些都是后台统计，显示在网页用的是不蒜子。百度统计和腾讯统计直接在_partial下新建一个ejs，然后把获得的代码粘贴进去就行了。谷歌统计也有通用的模板，把id粘贴进去就行。最后在主题的配置文件里写一下。有的主题已经内置了百度和谷歌的统计代码的，只需要填入id就行，上面是说的没有的情况。添加微博秀，直接到复制微博秀的代码。也是新建一个ejs文件，然后添加一个wedjet修改背景，添加归档Archives,添加sitemap，提交谷歌搜索。添加404，添加外链。hexo方法大致一致，都是在百度谷歌现学现用。以后有时间自己再做个主题，以后有时间在用flask搭一个博客，以后有时间，，，不知道说什么了。 修改了next主题后的一些配置（后加） 把侧边栏头像变成圆形，并且鼠标停留在上面发生旋转效果主要方法：修改themes/next/source/css/_common/components/sidebar/sidebar-author.styl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 添加nest背景特效：打开next/layout/_layout.swig，在之前添加如下代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开/next/_config.yml，添加以下代码： 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 文章链接唯一化文章题目或者变更文章发布时间会经常更改，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。安装此插件后，不要在hexo s模式下更改文章文件名，否则文章将成空白。 1npm install hexo-abbrlink --save 修改站点配置文件： 12345permalink: posts/:abbrlink/ # “posts/” 可自行更换# abbrlink configabbrlink:alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 可选择模式： crc16 &amp; hex crc16 &amp; dec crc32 &amp; hex crc32 &amp; dec 添加宠物（虽然没卵用）回到博客目录: 1npm install -save hexo-helper-live2d 然后打开Hexo/blog/themes/next/layout的_layout.swig,将下面代码放到之前： 1&#123;&#123; live2d() &#125;&#125; 然后在在 hexo 的_config.yml 中添加参数： 123live2d:model: wankobottom: -30 下面是一些model，可以换不同的宠物:123456789101112131415161718192021222324* Gantzert_Felixander* Epsilon2.1* haru* miku* ni-j* nico* nito* nipsilon* nietzsche* shizuku* tsumiki* wanko* z16* hibiki* koharu* haruto* Unitychan* tororo* hijiki* width 宽度 默认值: 150* height 高度 默认值： 300* className 元素的类名 默认值： live2d* id 元素的id 默认值： live2dcanvas* bottom 元素的底部偏移 默认值： -20 如果嫌模型位置不正确 可以调整这个参数 详细地址:https://huaji8.top/post/live2d-plugin-2.0/ 首页title的优化更改index.swig文件，文件路径是your-hexo-site\themes\next\layout，将下面代码 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成: 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 添加mob_share SDK分享方法：在_config.xml中添加 1234#Sharemob_share: enable: true appkey: ******** 然后添加mob模块：在next/layout/_partials/share/文件夹中新建一个mob_share.swig文件，内容为: 12345678910111213141516171819202122232425&lt;!--MOB SHARE BEGIN--&gt;&lt;div class="-mob-share-ui-button -mob-share-open"&gt;分享&lt;/div&gt;&lt;div class="-mob-share-ui" -mob-share-ui-theme -mob-share-ui-theme-slide-bottom style="display: none"&gt;&lt;ul class="-mob-share-list"&gt; &lt;li class="-mob-share-weixin"&gt;&lt;p&gt;微信&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-qzone"&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-weibo"&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-facebook"&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-twitter"&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-pocket"&gt;&lt;p&gt;Pocket&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-tumblr"&gt;&lt;p&gt;Tumblr&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-google"&gt;&lt;p&gt;Google+&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-linkedin"&gt;&lt;p&gt;Linkedin&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-qq"&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-tencentweibo"&gt;&lt;p&gt;腾讯微博&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-renren"&gt;&lt;p&gt;人人网&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-douban"&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-youdao"&gt;&lt;p&gt;有道云笔记&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-instapaper"&gt;&lt;p&gt;Instapaper&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class="-mob-share-close"&gt;取消&lt;/div&gt;&lt;/div&gt;&lt;div class="-mob-share-ui-bg"&gt;&lt;/div&gt;&lt;script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=&#123;&#123;theme.mob_share.appkey&#125;&#125;"&gt;&lt;/script&gt;&lt;!--MOB SHARE END--&gt; 然后添加引用，在next/layout/post.swig文件中，添加一行即可。 12&#123;% elseif theme.mob_share.enable %&#125; &#123;% include '_partials/share/mob_share.swig' %&#125; 后来添加了一些插件：hexo-ruby-character插件插件主要用来给文字注音啥的，具体效果见官方repo 1npm install hexo-ruby-character --save 使用方法： 1&#123;% ruby Base|top %&#125; Base (top) hexo-pdf插件用来在文档中插入pdf的，官方repo安装： 1npm install --save hexo-pdf 用法： 1&#123;% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125; 图片懒加载虽然图片不多，没多大用，不过还是用了，想着稍微能提速一点。官方repo安装： 1npm install hexo-lazyload-image --save 配置： 1234lazyload:enable: true onlypost: falseloadingImg: # eg. ./images/loading.png 添加DaoVoice插件首先在Daovoice官网注册一个账号，新建一个应用，然后进入应用，选择安装到网站，获取 接入代码 和 app_id。然后编写主题配置文件_config.xml，加入几行： 123daovoice: enable: true app_id: ****** 然后编写 DaoVoice 接入代码： 123456789101112131415161718192021找到themes/next/lauout/_third-party/目录，在该目录下新增 daovoice/daovoice.swig 文件，然后在daovoice文件中写入：&#123;% if theme.daovoice.enable %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123; i["DaoVoiceObject"]=r; i[r]=i[r]||function()&#123; (i[r].q=i[r].q||[]).push(arguments)&#125;, i[r].l=1*new Date(); a=s.createElement(o), m=s.getElementsByTagName(o)[0]; a.async=1; a.src=g; a.charset="utf-8"; m.parentNode.insertBefore(a,m) &#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/&#123;&#123; theme.daovoice.app_id &#125;&#125;.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123; theme.daovoice.app_id &#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt; &#123;% endif %&#125; 然后再在模板文件里引入 DaoVoice 接入代码：找到themes/next/lauout/_layout.swig文件，引入刚才写的 daovoice.swig 文件。 1&#123;% include '_third-party/daovoice/daovoice.swig' %&#125; 隐藏底部powered一栏打开hexo/themes/next/layout/_partials/footer.swig,使用&lt;!-- --&gt;隐藏之间的代码即可。或者直接删除 修改底栏心形图标直接去fontawesome网站找到对应的图标名字，在主题配置文件中替换掉heart就行。 主页文章添加阴影效果打开\themes\next\source\css_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 修改页面底部标签分类的#号修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成喜欢的图标，具体可以去FontAwesome网站去找。 添加脚注1npm install hexo-reference --save 用法： 12345678910basic footnote1here is an inline footnote[^2](inline footnote)and another one3and another one4 [^1]: basic footnote content[^3]: paragraphfootnotecontent[^4]: footnote content with some [markdown](https://en.wikipedia.org/wiki/Markdown) 添加居中模块用HTML代码： 1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 添加鼠标特效新建一个js： 1vim themes/next/source/js/src/mouse.js 在里面输入: 12345678910111213141516171819202122232425262728/* 鼠标特效 */var a_idx = 0;jQuery(document).ready(function($) &#123; $("body").click(function(e) &#123; var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正" ,"法治", "爱国", "敬业", "诚信", "友善"); var $i = $("&lt;span/&gt;").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css(&#123; "z-index": 999999999999999999999999999999999999999999999999999999999999999999999, "top": y - 20, "left": x, "position": "absolute", "font-weight": "bold", "color": "#ff6651" &#125;); $("body").append($i); $i.animate(&#123; "top": y - 180, "opacity": 0 &#125;, 1500, function() &#123; $i.remove(); &#125;); &#125;);&#125;); 然后在Blog\themes\next\layout\_layout.swig文件的最下方，&lt;/body&gt;前面添加&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/mouse.js&quot;&gt;&lt;/script&gt;。 添加时钟在next\layout\_macro中找到sidebar.swig(侧边导航栏),在合适的位置加入一下代码: 1234&lt;div class="swf_clock" align="center"&gt;&lt;embed name="honehoneclock" width="160" height="70" align="middle" pluginspage="http://www.macromedia.com/go/getflashplayer" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock01.swf" type="application/x-shockwave-flash" wmode="transparent" quality="high" bgcolor="#ffffff" allowscriptaccess="always"&gt;&lt;/div&gt; 给页面添加背景图片在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 1234567body&#123; background:url(图片链接); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center; &#125; 文字背景色以及半透明的设置一样，在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 123456.content &#123; border-radius: 10px; margin-top: 60px; background:rgba(颜色rgb,透明度) none repeat scroll !important; &#125; 其中border-radius是给文章背景设置圆角，margin-top是设置文章到顶部的距离，其中属性可根据自己的需要进行调整。在修改完文章背景色之后，文字颜色可能和背景色不能很好的搭配，这时候我们就需要修改文章字体的颜色了。打开theme/next/source/css/_common/scaffolding文件夹下的base.styl文件，找到body{}，将其中的color:$text-color更改为你想要的颜色即可。代码如下： 1234567891011body &#123; position: relative; /* Required by scrollspy */ font-family: $font-family-base; font-size: $font-size-base; line-height: $line-height-base; color: 颜色代码; background: $body-bg-color; +mobile() &#123; padding-right: 0 !important; &#125; +tablet() &#123; padding-right: 0 !important; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125;&#125; 文章页面宽度设置还是在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 1main-inner &#123;width: 页面宽度;&#125; 文章内单行代码的样式设置如果更改了网页底色，单行代码的颜色可能与背景色不搭配，这时就需要我们自己设置了。在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 1#posts code &#123;color: 颜色代码;background-color:颜色代码;&#125; 网页顶部和底部的文字颜色修改头部文字颜色 更改头部site-title的字体颜色在theme/next/source/css/_common/components/header文件夹下打开site-meta.styl文件，找到.brand{}向里面添加以下代码： 1color: 颜色代码 !important; 更改头部menu的字体颜色在相同的文件夹下打开menu.styl文件，找到a{}，向里面添加以下代码： 1color: 颜色代码 !important; 底部文字颜色底部文字颜色的修改就显得很简单了，还是在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 1.footer-inner &#123;color: 颜色代码;&#125; 侧栏背景图以及内部文字颜色的修改还是在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 1234567#sidebar &#123; background:url(图片链接); background-size: cover; background-position:center; background-repeat:no-repeat; p,span,a &#123;color: 颜色代码;&#125;&#125; 其中设置p,span,a{color:颜色代码}，即可修改侧边栏内部文字的颜色。 修改Mist风格下的侧边栏位置为左边此设置为修改next主题Mist风格下侧边栏的位置为左边（默认为右边）以及侧边栏变化后页面变化的方向，具体操作如下： 更改页面变化方向：首先，打开next/source/js/src文件夹下的motion.js文件Ctrl+F查找paddingRight；把所有（2个）PaddingRight更改为paddingLeft即可。代码样式如下： 12&#123;paddingLeft: SIDEBAR_WIDTH&#125;,NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingLeft: 0&#125;); 更改所有和sidebar相关的元素： 更改sidebar： 打开next/source/css/_common/components/sidebar文件夹下的sidebar.styl文件，将.sidebar{}内的right: 0;改为left: 0;，形式如下： 123.sidebar &#123; position: fixed; left: 0; 打开相同路径下的sidebar-toggle.styl文件，将.sidebar-toggle{}内的right: $b2t-position-right;改为left: $b2t-position-right;，形式如下： 123.sidebar-toggle &#123; position: fixed; left: $b2t-position-right; 返回上一个文件夹，打开back-to-top.styl文件，将.back-to-top {}内的right: $b2t-position-right;改为left: $b2t-position-right;，形式如下： 12345.back-to-top &#123; box-sizing: border-box; position: fixed; bottom: $b2t-position-bottom; left: $b2t-position-right; 修正侧边栏在左边时的小BUGBUG描述：在更改浏览器大小的时候，顶部栏和底部栏未和侧边栏同步。解决方法：在themes/next/layout/source/js/src文件夹下打开motion.js文件，在$(document).ready(function (){}顶部其中添加代码 12345678910111213window.onload=function()&#123; var bwol=document.body.offsetWidth; if(bwol &lt; 975)&#123; $('aside#sidebar').css("display","none"); $('body').css("paddingLeft","0px"); &#125;&#125;window.onresize = function()&#123; var bwos=document.body.offsetWidth; bwos &lt; 975 &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingLeft: 0&#125;,0); if($('aside#sidebar').css('display') != 'none' &amp;&amp; $('aside#sidebar').css('width')!='0px') $('body').velocity('stop').velocity(&#123;paddingLeft: 350&#125;,0);&#125; 更改侧边栏控制按钮的样式在themes/next/layout/source/js/src文件夹下打开motion.js文件，在顶部其中更改代码。找到以下代码的位置： 123var sidebarToggleLine1st = new SidebarToggleLine();var sidebarToggleLine2st = new SidebarToggleLine();var sidebarToggleLine3st = new SidebarToggleLine(); 将其内部内容更改为以下内容： 123456789101112131415161718192021222324var sidebarToggleLine1st = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-first', status: &#123; arrow: &#123;width: '50%', rotateZ: '45deg', top: '2px', left: '6px'&#125;, // close: &#123;width: '100%', rotateZ: '-45deg', top: '5px', left: '0px'&#125; //叉字形 close: &#123;width: '50%', rotateZ: '-45deg', top: '2px', left: '0px'&#125; //箭头形 &#125; &#125;); var sidebarToggleLine2nd = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-middle', status: &#123; arrow: &#123;width: '90%'&#125;, // close: &#123;opacity: 0&#125; //箭头形 close: &#123;width: '90%'&#125; &#125; &#125;); var sidebarToggleLine3rd = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-last', status: &#123; arrow: &#123;width: '50%', rotateZ: '-45deg', top: '-2px', left: '6px'&#125;, // close: &#123;width: '100%', rotateZ: '45deg', top: '-5px', left: '0px'&#125; //叉字形 close: &#123;width: '50%', rotateZ: '45deg', top: '-2px', left: '0px'&#125; //箭头形 &#125; &#125;); 添加侧边栏头像的链接修改鼠标样式：在themes/next/layout/source/css/_common/componets/sidebar文件夹下打开sidebar-author.styl文件，在.site-author-image{}内添加cursor: pointer;形如： 123456789.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; cursor: pointer;&#125; 添加链接：在themes/next/layout/source/js/src文件夹下打开motion.js文件，在顶部其中添加代码： 123$('.site-author-image').click(function()&#123; window.location.href="自定义链接";&#125;); 设置鼠标划入侧边栏才显示站点信息：在theme/next/layout/_macro文件夹下打开sidebar.swig文件，找到以下代码行的位置： 1&lt;nav class="site-state motion-element"&gt; 在其上添加以下代码： 123456789101112&lt;!--my custom code begin--&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.5.0/velocity.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $("#sidebar").hover(function()&#123; $("#mydivshow").velocity('stop').velocity(&#123;opacity: 1&#125;); &#125;,function()&#123; $("#mydivshow").velocity('stop').velocity(&#123;opacity: 0&#125;); &#125;);&lt;/script&gt;&lt;div id="mydivshow" class="mydivshow"&gt;&lt;!--my custom code end--&gt; 然后找到代码行： 1234&lt;/section&gt;&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;&lt;!--noindex--&gt;&lt;section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"&gt; 在此的上方添加一个，如下所示： 12345678&lt;!--my custom code begin--&gt;&lt;/div&gt;&lt;!--my custom code end--&gt;&lt;/section&gt;&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;&lt;!--noindex--&gt; &lt;section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"&gt; &lt;div class="post-toc"&gt; 自定义区域的初始化设置在theme/next/source/css/_custom文件夹下打开custom.styl文件，向里面增添下列代码： 1#mydivshow&#123;opacity: 0;&#125; 注：具体代码添加位置以及代码里的section.site-overview可以自己修改，和末尾的是控制显示区域，section.site-overview则是用户鼠标滑入划出时的触发事件区域。 自定义音乐播放器安装APlayer插件1npm install aplayer --save 安装完后在node_modules目录下找到APlayer.min.js文件，将其复制到theme/next/source/js/src/目录下。 生成音乐播放器在你想要加入音乐播放器的地方插入以下代码，本站把他放在了侧边栏里，具体操作如下。打开theme/next/layout/_custom/文件夹下的sidebar.swig文件，向其中添加以下代码： 12345678910111213141516171819202122&lt;div id="player1" class="aplayer"&gt;&lt;/div&gt;&lt;script src="/js/src/APlayer.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var ap = new APlayer(&#123; element: document.getElementById('player1'), // Optional, player element narrow: false, // Optional, narrow style autoplay: true, // Optional, autoplay song(s), not supported by mobile browsers showlrc: 0, // Optional, show lrc, can be 0, 1, 2, see: ###With lrc mutex: true, // Optional, pause other players when this player playing theme: '#e6d0b2', // Optional, theme color, default: #b7daff mode: 'random', // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation` preload: 'metadata', // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto' listmaxheight: '513px', // Optional, max height of play list music: &#123; // Required, music info, see: ###With playlist title: 'Preparation', // Required, music title author: 'Hans Zimmer/Richard Harvey', // Required, music author url: 'http://7xifn9.com1.z0.glb.clouddn.com/Preparation.mp3', // Required, music url pic: 'http://7xifn9.com1.z0.glb.clouddn.com/Preparation.jpg', // Optional, music picture lrc: '[00:00.00]lrc here\n[00:01.00]aplayer' // Optional, lrc, see: ###With lrc &#125;&#125;);&lt;/script&gt; 自定义播放器样式包含颜色更改，列表歌曲信息的排版修改。在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 12345678910111213141516.aplayer-list ol li:hover &#123; /*列表悬停颜色*/ background:rgba(颜色代码,透明度) none repeat scroll !important;&#125;.aplayer-list ol li &#123; /*列表底色*/ background:rgba(颜色代码,透明度);&#125;.aplayer-list-light &#123; /*列表播放歌曲颜色*/ background:rgba(颜色代码,透明度) none repeat scroll !important;&#125;#player1 &#123; /*边框样式*/ border-radius: 6px; div,ol &#123;border-radius: 6px;&#125; &#125;#player1 *&#123;color: 颜色代码;&#125; /*字体颜色*//*列表歌曲信息的排版*/.aplayer-list-index&#123;float:left;&#125;.aplayer-list-title&#123;float:left;&#125;.aplayer-list-author&#123;float:right;&#125; 自定义萌萌哒音乐播放控制边栏1npm install aplayer-controler --save 仓库链接 DOS风格的404页面效果在这里 博客自动部署刚开始是准备用AppVeyor的，托管在github上，教程在这里不过发现私有仓库没法添加。然后发现GitLab自有CI，所以尝试用GitLab部署。就是那个最近因为不小心使用 rm rf 把自家数据库删光、还在 YouTube 上直播修库、让失误的程序员看了 10 小时的 nyancat 的那个 GitLab。。。参考链接见这里 live2d插件手机端隐藏由于现在这个模型在手机上比较大，而且不是很清晰，视觉效果不是很好，所以决定在手机端隐藏。方法很简单，判断一下是否移动端即可。在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：1#live2dcanvas &#123; +mobile() &#123; display: none; &#125; &#125; Gitment评论插件最初用的多说，后来多说挂了，之后采用来必力，看起来挺好看的，而且next主题也集成了这个插件，但是后端都是不靠谱的啊!这两天又抽风了，完全加载不出来，官方还没挂，但是页面已经显示不了了。最后还是决定采用Gayhub的评论系统，集成Gitment插件。Gitment的作者是imsun，其项目主页在这. 首先创建Gitment的swig文件，放到主题中，为了便于管理，我决定放在next/layout/_third-party/comments文件夹下。其内容为:12345678910111213141516171819202122232425262728293031323334353637&#123;% if theme.gitment.enable %&#125; &#123;% set owner = theme.gitment.githubID %&#125; &#123;% set repo = theme.gitment.repo %&#125; &#123;% set cid = theme.gitment.ClientID %&#125; &#123;% set cs = theme.gitment.ClientSecret %&#125; &lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt; &lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt; &#123;% if not theme.gitment.lazy %&#125; &lt;script type="text/javascript"&gt; var gitment = new Gitment(&#123; id: window.location.pathname, owner: '&#123;&#123;owner&#125;&#125;', repo: '&#123;&#123;repo&#125;&#125;', oauth: &#123; client_id: '&#123;&#123;cid&#125;&#125;', client_secret: '&#123;&#123;cs&#125;&#125;', &#125;&#125;); gitment.render('gitment-container'); &lt;/script&gt; &#123;% else %&#125; &lt;script type="text/javascript"&gt; function ShowGitment()&#123; document.getElementById("gitment-display-button").style.display = "none"; document.getElementById("gitment-container").style.display = "block"; var gitment = new Gitment(&#123; id: document.location.href, owner: '&#123;&#123;owner&#125;&#125;', repo: '&#123;&#123;repo&#125;&#125;', oauth: &#123; client_id: '&#123;&#123;cid&#125;&#125;', client_secret: '&#123;&#123;cs&#125;&#125;', &#125;&#125;); gitment.render('gitment-container'); &#125; &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 在主题文件layout/_third-party/comments/index.swig中引入刚刚添加的文件:1&#123;% include 'gitment.swig' %&#125; 设置按钮样式按钮样式可以放在css的文件夹下，具体目录是之前的source/css/_common/components/third-party/文件夹。在其中添加gitment.styl样式设置文件。 12345678910111213#gitment-display-button&#123; display: inline-block; padding: 0 15px; color: #0a9caf; cursor: pointer; font-size: 14px; border: 1px solid #0a9caf; border-radius: 4px; &#125; #gitment-display-button:hover&#123; color: #fff; background: #0a9caf; &#125; 具体button的样式可以自己修改里面的参数。然后在主题下source/css/_common/components/third-party/third-party.styl文件中引入相应的CSS样式: 1@import "gitment"; 修改button显示文字:在主题的en.yml增加: 1gitmentbutton: Show comments from Gitment zh-Hans.yml增加: 1gitmentbutton: 显示 Gitment 评论 修改主题评论代码在layout/_partials/comments.swig文件中找到最后一个if分支，应该是这两句: 12&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div id="vcomments"&gt;&lt;/div&gt; 在最后一个if分支后加一个Gitment的: 1234567&#123;% elseif theme.gitment.enable %&#125; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick="ShowGitment()" id="gitment-display-button"&gt;&#123;&#123; __('gitmentbutton') &#125;&#125;&lt;/div&gt; &lt;div id="gitment-container" style="display:none"&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id="gitment-container"&gt;&lt;/div&gt; &#123;% endif %&#125; 在主题配置文件中加入开启Gitment评论:123456789# Gitment # Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true githubID: #your github ID repo: #your comment repo ClientID: ------ ClientSecret: ------ lazy: false OK,到这里基本上是完成了。不过，有点麻烦，每个页面都要手动初始化，懒得折腾了，用了一段时间，还是换回来必力了，前几天官方给回复说已经修复了，暂时先用着罢。 Hexo中插入流程图因为hexo中的markdown语法并未支持流程图，或者说流程图语法现在并不是markdown的基本语法。但在挖坑填坑过程中，偶尔需要解释清楚一个Pipeline的时候，还是需要流程图的。偶然发现了一个插件，hexo-filter-flowchart，官方Repo在此. 安装在blog根目录下使用npm安装：1npm install --save hexo-filter-flowchart 配置站点文件(可选)可以在站点配置文件中修改默认的样式。12345vim _config.xmlflowchart: # raphael: # optional, the source url of raphael.js # flowchart: # optional, the source url of flowchart.js options: # options used for `drawSVG` 流程图用法一般是三个反引号加flow开始，最后三个反引号结束。其中语法示例如下:12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 最后效果如下: Hexo中插入序列图安装官方Repo在这,一样的，安装一个插件:1npm install --save hexo-filter-sequence 加速修改node_modules/hexo-filter-sequence/index.js文件，将其中的cndjs.cloudflare.com替换成cdnjs.cat.net。 序列图绘制一般是三个反引号加一个sequence开始，以三个反引号结束。示例:123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 在反引号后加上sequence后效果如下: 加速修改node_modules/hexo-filter-flowchart/index.js文件，将其中的cndjs.cloudflare.com替换成cdnjs.cat.net。 插入视频使用Dplayer插件。效果如下:1&#123;% dplayer "url=https://******.mp4" "http://******.jpg" "api=https://api.prprpr.me/dplayer/" "id=" "loop=false" %&#125; 而且，，，dplayer和live2d冲突了，导致无法显示live2d，而且这么久了也没见dplayer改，也就没用了。不过对于B站，现在不能直接提取外链了，感觉直接用iframe更方便一点: st=>start: Start e=>end op=>operation: My Operation cond=>condition: Yes or No? st->op->cond cond(yes)->e cond(no)->op{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks!{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("sequence-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-0", options);]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>myfirst</tag>
        <tag>helloworld</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cvsba编译过程（在VS2015下的编译与测试）]]></title>
    <url>%2Fposts%2Ff3656e8e%2F</url>
    <content type="text"><![CDATA[由于之前所用的sba（光束法平差）库是10版本编译的，现在我用的是15版本，而且15的版本相对于以前变化不少，之前也参照过网上的一篇13版本的编译过程，不过一直出错，后来调试很长时间，终于生成成功，这里mark一下。 首先下载cvsba的source code：网址是https://sourceforge.net/projects/cvsba/files/1.0.0/下載的是cvsba-1.0.0，目前依然是这个版本。 然后解压放到对应目录文件夹，依个人喜好。我的是E:\cvsba-1.0.0 编译这里需要一些工具，cmake自然不用多说，还有opencv的依赖，所以事先需要下载opencv，这个不做过多赘述。我这里使用的cmake版本是3.6.1然后打开cmake，选择源文件夹和输出文件夹，尽量不要是一个，方便一点可以在E:\cvsba-1.0.0目录下再建一个bulid文件夹存放。然后config中选择v14，即2015版本。点击确定一般会出现error，因为缺少一些lapack的库。由于编译lapack需要用到fortran编译器，这里没有，所以不再编译，直接从网上下载部分库文件下载clapack.lib, BLAS.lib, libf2c.lib共三个文件，放到E:\cvsba-1.0.0目录下。然后修改错误，把LAPACK_LIB路径改成刚刚放置的位置，继续config，继续修改，把BLAS_LIB路径改成刚刚放置的位置，继续config，继续修改，把F2C_LIB路径改成刚刚放置的位置，其余的不用管，继续config，编译成功。然后generate一下。然后用vs2015打开build文件夹下的cvsba.sln点击cvsba，然后build，发现很多错误。首先是LIBCMT和MSVCRT的问题，在属性表中修改，debug模式中改为/MTd，release中改为/MT。然后重新生成。发现错误如下：原因是没有加如相应的lib, 在程序中增加lib（Link -&gt;input ）附加依赖项 clapack.lib blas.lib libf2c.lib，前面要加其所在文件夹，如E:\cvsba-1.0.0\clapack.lib，E:\cvsba-1.0.0\BLAS.lib，E:\cvsba-1.0.0\libf2c.lib（这是release下面的，debug下添加相应的带d的版本，即E:\cvsba-1.0.0\clapackd.lib，E:\cvsba-1.0.0\BLASd.lib，E:\cvsba-1.0.0\libf2cd.lib）然后重新build，还有错误：原因是15版本现在使用的是内联定义调用许多stdio.h中的函数。解决方法：也是在链接中添加相应依赖库： 1legacy_stdio_definitions.lib 重新build。出现错误，原因也是VC6的stdio.h中未定义，手动在头文件中加入： 1234567#ifdef __cplusplusextern "C"#endifFILE __iob_func[3] = &#123; __acrt_iob_func(0), __acrt_iob_func(1), __acrt_iob_func(2) &#125;; 继续build成功。但是进入debug中发现只有cvsba.dll文件，没有cvsba.lib文件，原因是cvsba..h里面的class声明少了__declspec(dllexport) 把它加上去就可以了Build，成功接下来测试生成的lib和dll文件是否完好。直接build所有的项目，发现一个问题：解决方法：像该文件中加入#include&lt;time.h&gt;至此，全部建立完成。然后进入生成的文件夹运行，可以用windows的cmd也可以用bash，我这里直接用bash了：需要先生成两个文件用于测试：分别是camsfile和pointsfile，可以自己命名，但用于测试，就随便命名了。可以看到已经多了两个文件。然后运行test_cvsba:测试成功，表示刚刚生成的cvsba.lib和cvsba.dll是没问题的。至此，所有任务已经完成。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>三维重建</tag>
        <tag>VS2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种计算Visual Hull的方法]]></title>
    <url>%2Fposts%2F7ad61e8d%2F</url>
    <content type="text"><![CDATA[计算Visual Hull的方法:A Robust and Accurate Method for Visual Hull Computation [Song Peng 2009] 计算3D bounding box仅从一组轮廓和投影矩阵计算3D bounding box 可以从每个轮廓的2Dbounding box考虑，使用4个变量 假设有N张图计算3D bounding box， 是第i张图的投影矩阵， 表示其2D边框。透视投影等式如下： 其中， 由于图像i的轮廓必须在其2D边框内，因此有以下四个不等式： 因此需要求出4N个线性不等式的x,y,z的最大值和最小值。使用遗传算法解决这个问题。每个个体是一个3D点（x,y,z）。如果希望计算x的最大值最小值，则相应的目标函数为.适应函数等于目标函数。算法如下： 产生一个满足4N个不等式的初始群体，如果知道目标的大致距离，该步骤会简单很多。根据其适应性函数选择个体个体与变异交叉，如果产生了不满足4N不等式的个体，则丢弃保存此次产生最优的个体。如果最大允许生成数未达到，则转至步骤2；else exit。建立Visual Hull的八叉树从Silhouette建立：递归细分，投影测试 从bounding box开始，将等值面上的cube分成八个孩子，迭代。 等值面函数与Visual Hull的表面相关 对于一个给定的3D点v，等值面函数定义为: Di是对轮廓i边缘的倒角距离变换CDT，负内，正外。 Projection test方法评估一个给定的voxel： 计算该voxel的8个顶点的等值面函数。如果8个顶点都在visual hull的外部。投影到所有图像，如果在一幅图像上voxel的投影都在silhouette内部，则类型为in，否则为on。 当8个顶点都在visual hull内部时。将voxel投影到所有图像上，如果所有图像上voxel的投影都在silhouette内部，则类型为in，否则为on。 当部分顶点在visual hull内部时，类型为on。事实上，可以仅通过判断voxel的投影与silhouette的相对位置来判断一个voxel的类型。这里使用的是8个顶点的等值面函数来减少计算时间。当部分顶点在visual hull内部时，不需要计算立方体的投影即可判定其类型为on。另一方面，在marching cubes算法中，也需要等值面函数的值。 文中Projection test方法的实现有两个步骤：计算一个voxel在所有图像上的投影（not esay）文中方法：将8个顶点投影到图像上，然后计算8个点的投影的凸包（convex hull）。凸包与cube的投影相同 文中证明：一个立方的六个面将3D空间划分成27个半空间:26个外部，一个内部。 从外部的26个半空间观察该立方体的轮廓，可以分为三种情况：1个、2个、3个可见面。因此，该立方的投影与8个顶点的投影的凸包相同。 计算一组给定点的凸包使用的方法是gift wrapping 算法，时间复杂度是O(nh)。N是点的数目，h是凸包上的点数。因此，这里 gift wrapping算法如下： 判断立方体的投影与silhouette的相对位置如果多边形内所有像素都在目标区域内部，则多边形在silhouette内部； 如果多边形内所有像素都在目标区域外部，则多边形在silhouette外部； 如果部分像素在目标区域内，则多边形与silhouette相交。 使用marching cubes算法计算visual hull在八叉树重建后，使用marching cubes算法提取visual hull表面。 Voxel占用一个叶节点，使用等值面函数值将其8个顶点编码成8个值。然后做一个距离变换，等值面函数值可以表示到visual hull表面的3D距离：负则在内，正则在外。然后用这些值在于给查找表上去索引，该查找表示预先定义的，定义了voxel内部的表面三角形，将形成最终visual hull mesh的一部分。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>三维重建</tag>
        <tag>visual hull</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下opencv的配置]]></title>
    <url>%2Fposts%2Febc78778%2F</url>
    <content type="text"><![CDATA[ubuntu下opencv的配置过程：这里ubuntu版本：Ubuntu 14.04.4opencv版本 2.9.13配置过程：首先下载opencv安装包 ;过程不用多说 然后解压到根目录下解压之后记住需要安装一些工具基本命令：123sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 实际上只需要前面两行命令即可然后在opencv目录下新建一个临时目录 mkdir release然后进入临时目录1234cd releasecmake -D /usr/local ..makesudo make install 此后还有一步需要注意 如果直接编译运行文件 会提示找不到so文件所以需要添加一个路径链接：1sudo vim /etc/ld.so.conf 然后在其中加上一行：1/usr/local/lib 因为库文件都在这个lib文件夹中现在ok进入opencv目录下的sample文件夹下，继续进入：1cd ~/opencv-2.4.13/samples/c/ 然后编译;1./build_all.sh 最后跑个示例demo就知道可不可以用了：1./find_obj 如图所示： ok～]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三维建模中shape of silhouette 的简要理解]]></title>
    <url>%2Fposts%2Fdfc9d3fd%2F</url>
    <content type="text"><![CDATA[举例 一篇文章：shape silhouette fusion for image-based modeling文章作者Peng Song et al.[2010] 文章基本思想是由一些已标定图像得到其stereo和silhouette的信息（silhouette信息也是由stereo得到），然后融合两种有向点云 利用泊松表面重建算法（PSR）将有向点云转变成一个完整且精确地三角形网;模型(complete，accurate)微软的高质量fvv的论文使用其中方法[High-Quality Streamable Free-Viewpoint Video，2015] 主要用于产生silhouette的深度图方面： 产生visual hull 的八叉树 Mesh 八叉树 （方法：Marching Cubes） Project the mesh into with Z-buffered rasterization. Peng Song文中所述基本步骤: 计算一个visual hull 深度图估计 基于扩张的方法（expansion-based）返回一个3D点云（包含outliers以及冗余信息）；剔除outlier，降低scale，估计深度图的表面法向量，生成一个有向点云（来自stereo） 利用这个点云（来自stereo），雕刻其visual hull的八叉树结构，得到另一个有向点云（来自silhouette）；merge两种点云，利用泊松表面重建PSR算法将来自stereo和silhouette的有向点云转变成一个完整且精确的三角网;模型。 详细步骤:Visual hull 及计算方法计算一个3D边框（3D bounding box）从一组silhouette和投影矩阵计算3D边框，可以考虑计算每个silhouette的2D边框，并后向投影得到。物体的边框可以由一个优化算法计算[Song, P. 2009]（6个变量定义了一个bounding box，分别是x, y, z的最大;和最小;） Visual hull八叉树的建立开始于一个体素（voxel），即上一步中的3D边框。然后将voxel分为3类： 处于visual hull内； 在visual hull边界上； 在visual hull外部。 只有内部和边界的voxel才能细分，直到达到最大细分层数。 判断一个voxel类型的基本方法：使用gift wrapping算法（Jarvis, R.A.1973）计算voxel的8个顶点的投影的凸壳（convex hull），一旦在每张silhouette图上的精确投影计算完成，然后通过确定voxel的投影与所有silhouette的相对位置来判断voxel的类型。（Since the projection of the voxel is a convex polygon, our approach evaluates the relativeposition of the projection to the silhouette by a scan processor that tracks only the right and the left edges from the top to the bottom of the projection.）。 判断方法： 如果多边形内所有像素都在目标区域内部，则多边形在silhouette内部； 如果多边形内所有像素都在目标区域外部，则多边形在silhouette外部； 其他情况，多边形与silhouette相交。 于是提出了一个projection test算法判断： 其中，等;函数isosurface function表示3D点到visual hull表面的3D距离，关系：负→内，正→外。 该projection test算法利用voxel的8个顶点的isofunction的;来降低计算量:当8个顶点中的一部分在visual hull外部，则无必要将voxel投影到所有的silhouette image上去即已知其类型。 Visual hull mesh的提取方法：Marching Cubes算法。 至此，生成的visual hull 将有两个作用： 从multi-view stereo生成深度图 通过PCST（stereo点云）雕刻该visual hull 八叉树生成PCSL（silhouette点云） 在微软文中所述到marching cubes一步之后，用显卡渲染直接得到深度。 接下来介绍Song的其余部分: Shape信息（有向点云，来自stereo） 深度图估计（基于扩张方法） 首先将每张图片划分成许多小窗口，固定大小M*M 使用贪婪方法（greedy approach）计算窗中心像素的深度;如果发现一个深度;，其置信度高于一个门槛thres2，则将该深度;作为这个窗口的参考深度。 对一幅图的所有参考深度;使用median-rejection方法排除明显的outliers。由于选择的深度;都是置信度比较高的，因此很多窗口可能没有参考深度;，特别是一些没有或者很少纹理的表面。 对于无参考深度;的窗口，由其相邻3*3的窗口计算其参考深度。通常如果该窗口的相邻窗口数多于一个固定的数a（这里取得a=4），则用其相邻窗口的深度;计算其深度（中;）。该过程对所有的窗口迭代5次。 可以看到这一步之后点云明显稠密一些。 对扩展窗中的每个像素，从深度间隔（由参考深度定义）中以一个固定的长度d搜索其深度;（search the depth values for all the pixels in the window from a depth interval with fixed length d centered at the reference depth along the optical ray） 扩展窗大小M*M取决于输入图像序列的分辨率，thres2仅取决于纹理状况。D取决于重建物体和扩展窗的大小，通常在重建物体大小的1%到2%。 融合这些深度图，得到一个点云。对每个点云中的3D点，其置信度和视点方向均被存储。 具体算法过程如下： 点云的cleaning和downsamplingCleaning过程： 合并重建目标的visual hull，作为一个约束，来剔除out of visual hull的3D点。 从估计的点云中建立一个表决树，选择一个门槛thres3去排除不相关点。 对每个voxel，计算该voxel中的individual correlation scores之和，与门槛分数比较。 下采样过程： 主要是在每个voxel中提取置信度最高的一个点，达到下采样的目的。 表面法向估计 利用主成分分析PCA 选择两个参数定义一个给定点的领域，一个固定的半径R和点数目N，使用一个KD-Tree 有效计算k紧邻问题。 确定表面法向： 通过该点的视点方向 和表面法向 的点积进行选择：大于0，则表面法向的方向与相同；小于0 ，相反。 输出为一个有向点云：PCST。 使用PSR，问题：无纹理或者纹理很少的区域、非连接区域难以恢复。 Volumetric stereo and silhouette fusion 生成另一个visual hull上的有向点云，表示为PCSL。 方法：将visual hull 八叉树结构的voxel，根据其相对于PCST的点的相对位置分成三类： Type 1：该voxel包含一个或者一些PCST中的3D点 Type 2：该voxel位于PCST中的3D点和该点的参考图的光心的连线上 Type 3：所有剩余的voxel。事实上，大部分都是纹理很少的区域或闭塞表面区域。如下图所示（figrue9. a）在这些剩余的voxel中，提取visual mesh的顶点和法向来重建PCSL（figrue9. b）。 计算方法如下图所示： 联合来自stereo和silhouette的形状信息（通过融合PCSL和PCST两种点云），用PSR方法转变成一个三角网;模型。 在PCSL计算好后，加到PCST上，生成一个更完整的点云，表示为PCSTSL。再用PSR算法，将有向PCSTSL转化为一个三角网;模型。如下图所示 [附]关于文中greedy approach： 输入：一个已标定图像序列和目标的visual hull 对每个image，选择其k个相邻视点使用鲁棒的窗口匹配关联。 对中的每个像素p，从该物体的visual hull计算一个深度间隔（depth interval），即visual hull内p的后向投影（back-projected）光线 重投影该深度间隔到已选择的相邻视点，计算一个m*m的窗口（中心为p）与不同图像上的窗口（中心为p的投影）标准互相关;NCC（normalized cross-correlation）， 对于一个给定的深度间隔，其与在不同image上的投影相关，由极线约束（epipolar constraint），这样不同视点的所有相关曲线都可以关联到一个单独的坐标系统中。 一旦相关曲线被计算出来，则最优深度从中选择：在k个紧邻视点中，对于至少两个视点，其NCC;高于一些门槛。 注意：对中的每个像素p，最优候选深度从最大化NCC;的深度;中选择。若未发现有效深度，则无最优候选深度（none）。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>三维重建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记（一）]]></title>
    <url>%2Fposts%2F5f7ed589%2F</url>
    <content type="text"><![CDATA[初学JavaScript，不过之前已经学过很多语言了。刚看JavaScript的时候，感觉很多内容其实和python挺像的，只不过这里初始化时没有要求变量类型。没错，java和JavaScript的区别就是雷锋和雷峰塔的区别。感觉对于编程来说，时间长了，太容易自己为是了。以致于一个很简单的小问题最后可以烦死你，还死活看不出来。所以开始记下笔记，记下容易出错或者一些平时不大注意的细节，以后温故时候，也挺舒服的。大小写区别： JavaScript区分大小写，而HTML并不区分大小写（尽管XHTML区分大小写）。 关于换行： 在JavaScript中，如果各语句独占一行，通常可以省略语句之间的分号（程序结尾或者右花括号之前的分号也可以省略）。但在return、break和continue和随后的表达式直接不能有换行。如果添加了换行，程序只有在极特殊的情况下才会报错，而且程序的调试非常不方便。 例如： return true； JavaScript会解析成（本意是return true；） return； true； 还有一个例外是涉及&#43;&#43;和- -的时候，如果将其用作后缀表达式，它和表达式应当在同一行。否则，行尾将填补分号。 例如： x &#43;&#43; y 解析成“x； &#43;&#43;y” 关于数字： JavaScript中的非数字&#20540;有一点特殊：它和任何&#20540;都不相等，包括自身。因此，不能通过x==NaN来判断变量x是否是NaN，只能使用x!=x来判断：当且仅当x为NaN的时候，表达式的结果才是true。 JavaScript中的数字具有极高的精度，并可以极其近&#20284;于0.1。但是，数字不能精确的表述的确带来了一些问题。 例如： var x = .3 -.2; var y = .2 - .1 ; x == y //false：两&#20540;不相等！ 由于舍入误差，0.3和0.2之间的近&#20284;差&#20540;实际上并不等于0.2和0.1之间的近&#20284;差&#20540;。这个问题并不只在JavaScript中出现，理解这一点非常重要：在任何使用二进制浮点数的编程语言中都会有这个问题。 关于文本： 空字符串长度为0，JavaScript中并没有表示单个字符的“字符型”。 一个长度为2的JavaScript字符串（两个16位&#20540;）有可能表示一个Unicode字符： var p = &quot;π&quot; ; // π由16内码表示0x03c0 var e = &quot;e&quot; ; //e由17位内码表示0x1d452 p.length// 1 e.length// 2 包装对象： 存取字符串、数字或布尔&#20540;的属性时创建的临时对象称作包装对象，它只是偶尔用来区分字符串&#20540;和字符串对象、数字和数&#20540;对象以及布尔&#20540;和布尔对象。 关于对象： 对象的比较并非&#20540;的比较：即使两个包含同样的属性及相同的&#20540;，它们也是不相等的。各个索引元素完全相等的两个数组也不相等。 例如： var o = {x:1}, p={x:1}; o === p// false var a =[], b = []; a ===b//false 对象&#20540;都是引用，对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，他们才相等。 关于类型转换： 除了null和undefined之外的任何&#20540;都具有toString()方法，这个方法的挤过通常和String()方法的返回结果一致。 几个类型转换的惯用法： x &#43; &quot;&quot; // 等价于String(x) &#43;x //等价于Number(x)，也可以写成x-0 ！！x // 等价于Boolean(x) toFixed()根据小数点后的指定位数将数字转换为字符串，从不使用指数记数法。 toExponential()使用指数记数法将数字转换为指数形式的字符串，其中小数点前只有一位，小数点后的位数则有参数指定。 toPrecision()根据指定的有效数字位数将数字转换为字符串。如果有效数字的位数少于数字整数部分的位数，则转换为指数形式。 如果用Number()转换函数传入一个字符串，它会视图将其转换为一个整数或浮点数直接量，这个方法只能基于十进制数进行转换，并且不能出现非法的尾随字符。 parseInt()函数只解析整数，而parseFloat()则可以解析整数和浮点数。如果字符串前缀是“0x”或者“0X”，parseInt()将其解释为十六进制数，parseInt和parseFloat()都会跳过任意数量的前导空&#26684;，尽可能解释更多字符，并忽略后面的内容。如果第一个非空&#26684;字符是非法数字直接量，将最终返回NaN。 parseInt()可以接受第二个可选参数，这个参数指定数字转换的基数，合法的取&#20540;范围是2~36. 对象转换为原始&#20540;：所有的对象(包括数组和函数)都转换为true。 关于变量作用域： 在函数体内，局部变量的优先级高于同名的全局变量。 尽管在全局作用域编写代码时可以不写var语句，但声明局部变量时必须使用var语句。 关于函数作用域和声明提前： JavaScript中没有块级作用域，取而代之的使用了函数作用域：变量在声明它们的函数体以及这个函数体嵌套的任意函数内都是有定义的。这意味着变量在声明之前甚至已经可用。JavaScript的这个特性被非正式的称为声明提前，即JavaScript函数里声明的所有变量(但不涉及赋&#20540;)都被“提前”至函数体的顶部。 关于作为属性的变量： 使用var声明一个变量时，创建的这个属性时不可配置的，也就是说无法通过delete运算符删除。如果没有使用严&#26684;模式并给一个未声明的变量赋&#20540;的话，JavaScript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常可配置属性，并可以删除它们。 关于作用域链： 在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数函数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。 关于原始表达式: 在一个方法体内，this返回调用这个方法的对象。 关于属性访问表达式： 两种： expression . identifier expression [ expression ] .identifier的写法更加简单，但是这种方式只适用于要访问的属性名称是合法的标识符，并且需要知道访问的属性的名字。 关于方法调用： 执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内this的指向。 关于对象创建表达式： 如果一个对象创建表达式不需要传入任何参数给构造函数的话，那么这对空圆括号是可以省略掉的。 关于左&#20540;： 在JavaScript中，变量、对象属性和数组元素均是左&#20540;。ECMAScript规范允许内置函数返回一个左&#20540;，但自定义的函数则不能返回左&#20540;。 关于算术表达式： 一个很容易忽略的现象： 假设存在a=1，那么“b=(a&#43;&#43;)&#43;a”将如何计算结果呢？ 正确顺序： (1)计算b (2)计算a&#43;&#43;（假设&#20540;为c） (3)计算a (4)计算c&#43;a (5)将c&#43;a的结果赋&#20540;给b 按照“&#43;&#43;”的含义，第二步中a&#43;&#43;的结果依然是1，即c为1，随后a立即增1，因此在执行第三步时，a的&#20540;已经是2.所以b的结果为3. 求余运算符的操作数通常是整数，但也适用于浮点数，比如6.5%2.1结果是0.2 关于比较： 对于数字和字符串操作符来说，加号运算符和比较运算符的行为都有所不同，前者更偏爱字符串，如果它的其中一个操作数是字符串的话毛泽进行字符串连接操作。而比较运算符更偏爱数字，只有在两个操作数都是字符串的时候，才会进行字符串的比较。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop搭建之WordCount程序]]></title>
    <url>%2Fposts%2Fbfb99b1f%2F</url>
    <content type="text"><![CDATA[Hadoop环境需要实验一中已经搭好了hadoop，部署模式是完全分布式，一个namenode，三个datanode。之前已经用JPS查看进程，已经搭好，现在再检查下是否搭建成功：在浏览器中输入ma:50070，可以查看详细情况： 图中显示3个livenodes，说明三个datanode正常启动。 输入ma:50090可以查看辅助名称节点，不过这里没有配置。 输入ma:8088可以查看集群工作状况： 至此，hadoop环境一切正常，然后进行下一步的Wordcount实例，也是hadoop里的“Hello World” 在本机上新建一个文件夹/input简单命令sudo mkdir ~/input 然后新建一个文件 sudo touch~/input/Di_Liu.txt 添加以下内容到文本中：123456789101112131415161718192021222324252627------------------------------------------------------------DiLiuNewdeeHelloWorldHelloHadoop------------------------------------------------------------Yousay you love rain,butyou use an umbrella to walk under it.Yousay you love sun,butyou seek shade when it is shining.Yousay you love wind,butwhen it comes you close your window.Sothat's why I'm scared when you say you love me------------------------------------------------------------ 1sudo gedit ~/input/Di_liu.txt 上传先在集群上新建一个input文件夹1hadoop fs –mkdir /input 现在可以再ma:50070上看到已经创建的文件夹，刷新即可。 将本地文件上传至云端1hadoop fs –put ~/.input/Di_liu.txt/input 在网页上再次刷新，即可看到上传的文档 启动Wordcount1hadoopjar /usr/soft/hadoop-2.7.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.1.jarwordcount /input /output 查看结果运行完成后。再次刷新网页。可以发现多了两个文件夹 进入/output目录下，查看单词计数的结果： 点击part-r-00000，下载，打开即可。 至此，单词计数程序已经完成。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop搭建]]></title>
    <url>%2Fposts%2F4f23e727%2F</url>
    <content type="text"><![CDATA[这里以虚拟机为例，介绍Hadoop2.7.1的搭建过程 一、更新、升级、安装ssh服务更新：1sudo apt-get update (也可以先更改下软件源，在source.list里面，因为国内属网易163软件源最快，具体命令为sudo gedit/etc/apt/source.list) 升级：1sudo apt-get upgrade 安装SSH服务1$ sudo apt-get install ssh （如果安装不成功，可以打开hosts文件，删掉里面ipv6的地址，这个不是必要的，但是本次使用的虚拟机就是因为这个问题，原因尚不明确。虽然用的是虚拟机，但是也出现过很多bug） 查看是否安装好了SSH服务可以用命令：1which ssh 如下所示： 再用ssh localhost 查看是否可以运行。如上图所示，可以登陆本机，说明SSH安装成功。 二、安装JDK我这里是在官网下载的jdk-7u79-linux-x64.tar.gz，因为我用的是64版本Ubuntu，由于是虚拟机，可以先在一台机器上安装好SSH、hadoop、JDK，然后再克隆，可以节省很多时间。 将jdk复制到所要安装的目录下，为了方便区分，我这里在usr目录下新建一个soft文件夹：1sudo mkdir/usr/soft 然后解压：1sudo tar–zxvf jdk-7u79-linux-x64.tar.gz 然后添加环境变量： 这里的environment相当于Windows下的系统全局变量。 在里面添加JAVA的路径：1JAVA_HOME=/usr/soft/jdk1.7.0_79 PATH后面加上：和其路径1PATH=....:/usr/soft/jdk1.7.0_79/bin 先按ctrl O 保存，回车，然后按ctrlX退出编辑。 三、安装Hadoop安装Hadoop的原理和java一样，先将Hadoop压缩包复制到/usr/soft目录下，这里前面要加上sudo，然后解压 解压完成后可以看到： 添加环境变量： 同安装java-JDK一样，sudo nano /etc/environment 然后添加：12345HADOOP_INSTALL=/usr/soft/hadoop-2.7.1:/usr/soft/hadoop-2.7.1/bin:/usr/soft/hadoop-2.7.1/sbin 之所以添加bin和sbin目录，是因为用的2.7.1版本Hadoop，两个目录分别存放不同的执行文件，后面可以看到。 按ctrl O 保存，回车，然后按ctrlX退出编辑。 四、创建一个名为hadoop的用户和用户组，修改机器名（每台机器均要创建相同的用户名和密码）（可选，因为用的是虚拟机，只是用来装hadoop，所以没有必要再另外建一个用户，这里就用的本机用户，用户名为ma）1、用nano打开etc下的sudoers文件1$ sudo nano /etc/sudoers 在rootALL=(ALL)ALL 下面添加如下一行:1hadoopALL=(ALL) ALL 先按ctrl O 保存，回车，然后按ctrlX退出编辑。 此时可以通过命令java -version查看java是否安装成功 通过命令hadoop version查看hadoop是否安装成功（注意这里没有-） 如果没有也不用担心，重启一下就行了。 五、克隆虚拟机： 关闭虚拟机，选中虚拟机，邮件选择“管理”-“克隆”，然后选择完整克隆 一共克隆三台，比直接装虚拟机然后安装环境快多了。 六、修改机器名和/etc/hosts文件（每台机器都修改，hosts内容一样，所以只需要修改一台，然后复制粘贴）这里先查询每台机子的IP地址，可以用ifconfig命令： 然后记下每个机子的IP 1234567ma 192.168.255.133sla1 192.168.255.135sla2 192.168.255.134sla3 192.168.255.136 然后添加到hosts文件中： 命令：1sudo nano /etc/hosts 并删除里面的ipv6地址。 添加后先按ctrl O 保存，回车，然后按ctrlX退出编辑。 然后修改机器名：123$sudo nano /etc/hostname） 对每台都要改。添加后先按ctrl O 保存，回车，然后按ctrlX退出编辑。 七、配置每台电脑无密码访问 首先在每台电脑上生成密钥：1$ssh-keygen -t rsa –P ‘’ （生成RSA公钥,因为是无密码，注意这里是两个单引号） 注意：生成密钥的位置就在/home/ma/.ssh 这个文件夹下。.ssh是个隐藏文件夹，需要 ctrlh 才能看到。 然后在每台电脑上生成密钥文档authorized_keys123$ cd ~/.ssh$ cp id_rsa.pub authorized_keys （将RSA公钥id_rsa.pub存储为授权密钥文档authorized_keys） 然后将sla1 sla2 sla3的authorized_keys中的内容复制给ma： 可以先复制，再追加，也可以直接打开图形界面AltF7，再用鼠标复制粘贴即可。123scp authorized_keys ma:/tmp（sla完成）sudo cat /tmp/authorized_keys ~/.ssh/authorized_keys 最后cat一下是否都添加了 然后再通过scp命令复制给3个sla，命令不再赘述。 然后修改所有机器的authuorized_keys权限1$ chmod 644 authorized_keys （修改密钥权限） 之后测试一下登陆slave机器123$ ssh sla1 $ ssh sla2 第一次只需要按yes，之后直接无密码访问。 八、配置hadoop1、hadoop运行环境变量设置 先进入hadoop目录 1$ sudo nanohadoop-env.sh 在里面添加java的目录1export HADOOP_HOME= /usr/soft/jdk1.7.0_79 配置hadoop云计算系统设置文档直接用nano命令，如core-site.xml则是：sudo nano core-site.xml,最后按ctrl O 保存，回车，然后按ctrlX退出编辑。 配置core-site.xml123456789101112131415?xmlversion=1.0?!--core-site.xml --configurationpropertynamefs.defaultFS/namevaluehdfs://ma//value/property/configuration 配置HDFS分布式文档系统设置文档——hdfs-site.xml12345678910111213141516171819$ sudo nanohdfs-site.xml?xmlversion=1.0?!--hdfs-site.xml --configurationpropertynamedfs.replication/namevalue3/value/property/configuration 配置Map/Reduce程序设置文档­­——mapred-site.xml（这里没有mapred-site.xml文档，但是有mapred-site.xml.template，可以先复制一份，再改为mapred-site.xml）123456789101112131415161718192021222324252627282930313233343536373839$ sudo geditmapred-site.xmlconfigurationpropertynamemapreduce.framework.name/namevalueyarn/value/property/configuration配置yarn：?xmlversion=1.0?!--yarn-site.xml --configurationpropertynameyarn.resourcemanager.hostname/namevaluema/value/propertypropertynameyarn.nodemanager.aux-services/namevaluemapreduce_shuffle/value/property/configuration 4、复制hadoop安装文件12345$ scp –r/usr/soft/hadoop-2.7.1 sla1:/usr/soft/(复制到sla1的/soft文件夹下)$ scp –r/usr/soft/hadoop-2.7.1 sla2:/usr/soft/(复制到sla2的/soft文件夹下)$ scp –r/usr/soft/hadoop-2.7.1 sla3:/usr/soft/(复制到sla3的/soft文件夹下) 九、集群搭建完成、启动hadoop云计算系统设置到这里，就已经完成hadoop云计算平台系统的搭建工作了，现在可以直接启动这个拥有4个节点（master、slave1、slave2，slave3）的hadoop实验平台。 1、式化hadoop命令：hadoop namenode–format 2、启动ssh守护程序1$ start-all.sh 3、查看hadoop云计算系统运行状况可以通过jps命令查看运行状况： 由图可知：这里有一个名称节点namenode，三个数据节点datanode，由于未分配辅助名称节点，所以secondaryNamenode还在主机ma上，三个数据节点已经分配给sla1、sla2、sla3三个主机。 说明hadoop的namenode和datanode已经启动成功。 4、关闭hadoop云计算系统关闭只需要一条指令：1$ stop-all.sh 也可以分别关闭，只需要将all改成yarn或者namenode等。 以下是一些配置文件的内容及意义，未配置则选择默认配置。 注：Hadoop搭建主要步骤123456789101112131415161718192021安装jdk安装hadoop配置环境变量[/etc/environment]JAVA_HOME=/usr/soft/jdk1.7.0_79PATH=....:/usr/soft/jdk1.7.0_79/bin[/etc/environmnet]...HADOOP_INSTALL=/usr/soft/hadoop-2.7.1:/usr/soft/hadoop-2.7.1/bin:/usr/soft/hadoop-2.7.1/sbin 【可选】：{ 新建用户 修改权限拥有 } 安装ssh 配置ssh 修改host123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293ip取决于电脑IP:ma 192.168.255.133sla1 192.168.255.135sla2 192.168.255.134sla3 192.168.255.136名称自定无密码访问配置hadoop!-- core-site.xml --configurationpropertynamefs.defaultFS/namevaluehdfs://ma//value/property/configurationA typical hdfs-site.xml!-- hdfs-site.xml --configurationpropertynamedfs.replication/namevalue3/value/propertypropertynamedfs.secondary.http.address/namevaluema:50090/value/property/configurationmapreduce:configurationpropertynamemapreduce.framework.name/namevalueyarn/value/property/configurationA typical yarn-site.xml file?xml version=1.0?!-- yarn-site.xml --configurationpropertynameyarn.resourcemanager.hostname/namevaluema/value/propertypropertynameyarn.nodemanager.aux-services/namevaluemapreduce_shuffle/value/property/configuration 式化HDFS 启动 验证jps1source /etc/profile 单词计数 启动命令：1hadoop jar /usr/soft/hadoop-2.7.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.1.jar wordcount /input /output]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[送]]></title>
    <url>%2Fposts%2Ff84e19c0%2F</url>
    <content type="text"><![CDATA[记得那年，一连月的风，瘆人的声音嘶吼着夜。如你的笑容，曾经的泪水不留痕，你认真说着你的梦。路灯下，脸色如白骨。影子渐渐变长，消失在，送你回去的拐角路口。你突然答应我，继续陪你走。送别后，同时转身，不回头。还在幻想身后，有你的回眸。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剧闲词]]></title>
    <url>%2Fposts%2Fa0a14ae3%2F</url>
    <content type="text"><![CDATA[没有追剧的习惯，唯一算追过的就是海贼了，也是经常忘记，偶尔想起来才看看更新的几集。昨晚熬夜看完了《平凡的世界》。 记得刚开始是初中的时候，家里一本黄皮的破书，封面也皱得不行，写着路遥文集，后面还差了两页，不知道是被谁撕的。未尝精装的封面下，没见华丽的辞藻，没见跌宕的剧情， 只是写的两兄弟的生活，却反映了一个时代的变迁。那个年纪看书，一直期待着剧情的高潮，可是看完半本却丝毫没有感受到，而我却忘疲的看了下去，等回头再想到这个问题时，书已经看完了，却还一直肤浅地惦记着，那不见了的两页上面一定是大结局。而后来再接触到这本书的时候，已经是好多年了，我终于可以翻开后面看看结局如何，可是已经不再想看，生活就是这样。关于那本书，我只记得有几个农民日复一日的劳动着，平淡如水的日子一直没有多大变化，而剧情也都忘了。 前段时间刚复试完，还在北京的时候就开始看了，不过就看了几集，后来回到武汉，两三天看到了四十多集，坐等更新了。再后来来到这里，终于断断续续的抽了几天看完了。看完了也睡不着了，宁静的夜里，心也静如水。温润的气候，适宜人和蚊子生存，昨晚忘记关窗户，耳边也一直有几只嗡嗡的拍打着翅膀。好在这里的蚊子并不是什么大患，不到第二天早上，咬过的红包就消失得无影无踪了，所以也懒得管它们，静静的想着电视里的各个人物的一生，想着自己最悠闲的坐看白云翻滚的南化生活，想着过去了的最low的四个多月。 最近据说对这部剧吐槽较多，好像都是真了解路遥似的，都完全理解那本书似的，站在各种高度指指点点。路遥潦倒的一生所经历的苦难也鲜有人尝，看着别人的故事哪会有别人的感情。我也不期望能完全体会那个年代的人们的心情，但只是喜爱历经苦难折磨而对生活痴心不改的执着，只是喜爱平凡的那些人们的毫无修饰的感情。 不过不管怎样，还是挺喜欢这部剧的，喜欢初拍的感觉，里面的人物也都喜欢。不管是带领全村谋生活闹世事的孙少安，执着于追求生活的意义不顾旁人眼光的孙少平，还是近乎完美的女神化身田晓霞，还是勤勤恳恳的老实庄稼人孙玉厚，又或是每天想着投机倒把发横财，而年近四十一无所成的王满银，又或是整天无所事事，贪小便宜还喜欢空喊口号的孙玉亭，以及其他的一些未加浓墨重彩的角色，我都喜欢。 喜欢这样的角色，如同喜欢这部剧、这本书一样，让我感受最深的就是它没有强加于人的作者自己的观点，只是记录着这个平凡的世界。每一种人都是不可或缺的，每一种人生态度也是不可或缺的。不管是站在上层的伟人，还是躬耕在底层的小农，悲欢离合，生老病死，自始而终。很多时候生活都是看不到希望的，平静的如一潭死水，也是有人苟安于现实随波而行，也是有人顶着各种复杂的眼光走着自己的路。也的确有人靠自己的勤劳换来了成功，也的确有人用汗水也改不了悲惨的命运，对于不可获知的明天，都是最平凡的人，最平凡的生活。 来这过了几天悠闲的日子，感觉不太适应，怕安逸。老师布置的任务还没完成，就在这闲言碎语了。暂时就说这么多吧，泛起的涟漪终会消散，日子还得安安静静的过下去。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垂钓]]></title>
    <url>%2Fposts%2F526f0d1a%2F</url>
    <content type="text"><![CDATA[青春一场盛宴，往昔谁知真假？恰如长线抛钩，一边嬉说玩耍。却看天色已暮，露重霜寒无霞。我在河边苦等，你们抱鱼归家。没钱没势没权，收竿又能去哪？不如赚些鱼儿，市上卖个好价。身旁几株枯草，我能看见地下。上面黄叶成尘，泥里它在挣扎。春风铺满十里，春雨润湿万家。我等鱼儿上钩，它等破土成芽。]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[销岁一记]]></title>
    <url>%2Fposts%2Ff71e8f70%2F</url>
    <content type="text"><![CDATA[复暮合，复朝发。一载尘下，几日颜华。不安于泥白藕花，归土为家。俟春荣，俟冬枯。自顾而安，自怜而孤。独做山中远志草，无知更好。]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[昨日记梦]]></title>
    <url>%2Fposts%2F5a450135%2F</url>
    <content type="text"><![CDATA[昨日有梦，吾为人师。先是高中，教语数。但很多课不讲，结果被主任谈话多次，想着生计，应付形式，却有诸老师旁听。好像是讲苏轼词文的，书上有着几篇，索性一次讲了。先是最出名的赤壁赋，我说同学们先读一遍。于是读了。我说再读一遍石钟山记，于是读了。大江东去读一遍。。。我言之再三，半节课过了，还是再读。旁边的主任好像挺不给面子的，“哪里有得你这种教学方法，你好歹也给讲讲。”我说这种文章听比学有意思，主任数目示意，勉为其难。我说请同学们看看这几篇文章有没有什么关联。答曰苏东坡之作。问曰苏东坡何许人也，答曰文豪大家。我说，先看石钟山记，这货想说什么。答曰事不目见耳闻，而臆断其有无，可乎？问曰可乎？答曰不可。他先否定郦道元以声名之，否定敲完了山南山北的石头的李渤。和他儿子晚上在小船上玩，听到了声音，于是觉得这是石钟山得名之由。然后笑郦元简，笑李渤陋。山之来名，本就千奇百怪，人家好歹也是专门去探究的，李渤还是实地考察了的，自己则是送儿子的时候顺便玩玩，大半夜的，听到了点风声，就以为得名之由来。谁在臆断？再看其余的，大江东去。历史上偌大的战役，没有去关注黎民，没有关注战事，也没有关注历史进展，却把焦点聚焦在一个女人身上，小乔初嫁，所以雄姿英发，所以摇一摇破扇子，讲几句黄段子，仗就打赢了。诸葛早有黄牛庙，曰，乱石排空，惊涛拍岸。且不说剽窃，把赤鼻矶说成赤壁，指鹿为马，还引得一大批无聊文人追捧，所谓豪放。本贻笑之事，却被无聊文人追为美谈，还生出了个文赤壁。臆断其有无，可乎。呵呵。再看赤壁赋，前面大江东去里刚刚说了乱石穿空，惊涛拍岸。这才刚刚到水涨船高的七月既望，就清风徐来水波不兴了。除了写景的，其余的不是意淫，就是废话，大家读着好听就读读，考试什么的，自己看着办。还没讲完，教室里好像很安静，主任原来早就站起来了，貌似对我很尊敬。于是我被调到了初中。初中好像又是讲了一个类似的课了，好像是教历史，教政治，没让我教语数。因为评价人物，评价政治，从不按书上来。再就上课放他们去玩，跟他们一起玩，多是荒诞。所以领导又是多次谈话，我到了小学。小学好像安分了很多，我不必去给他们解释世界是什么样的，只需要教认字。有个孩子跑过来了，问，老师，为什么蜜蜂来了，花园里就充满生气了？答曰，蜜蜂干嘛的？答曰，采蜜的。答曰，别人偷了你家的酒，你生气不？未毕，梦醒。近日许久不见梦，稍憩即醒，荒诞如此，难得一次，难得如此清晰。阁子无光，不知时久。几上剩有半杯茶，已凉。]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时虽予之]]></title>
    <url>%2Fposts%2F41f33d57%2F</url>
    <content type="text"><![CDATA[时虽予之，不若取之。予之易失，取之难得。易得易失，不若难之。时虽予之，不若与之。予之不惜，与之弥珍。时珍于物，不若惜之。 注： 时间给你的东西，生来就有的东西，不如自己去争取。原来所有的东西很容易就失去了，自己争取可能很难得到，但容易得到的就容易失去，难得到的难失去，不如走一条艰难的路。 时间给你的东西，不如把时间给你，自己利用这些时间去努力争取。生来就有的东西不懂得珍惜，自己经过漫长的时间探索而来的却弥足珍贵。时间比所拥有的东西更重要，我宁愿用我当初用时间换来的成就去换回当初的时间，但已经不可能了，珍惜你所拥有的那些，不如去珍惜时间。]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四岁杂谈]]></title>
    <url>%2Fposts%2Fac01029d%2F</url>
    <content type="text"><![CDATA[四年大学生活，不知是四年羁旅奔波，挣扎奋斗，还是四年光阴误掷，乐在消遣。我真切的感受到毕业的时候，并不是拿到学位证毕业证的时候，不是毕业设计定稿上交的时候，不是各自收拾行李相互道别的时候，而是在学校到处流连，笑声淡淡，拍着毕业照的时候，一如大一时候的欢声笑语中。因为在此之前，很多人如人间蒸发一般，几乎开学以来不曾碰面，而我也开始堕落在寝室里打着游戏，随意的度着日子，当再次看到你们的笑脸，一种久违的感觉，才意识到毕业了。我并不是想说一些沉重的话题，也不是笑谈往日的忧散愁香，只是一些可能在梧桐树下面系鞋带的事，只是可能在桥上湖边突然萌生一个想法，如此之类。来到大学，遇到的一些事，大家都遇到过。有过的一些想法，大家也都有过。或是青葱岁月，踌躇满志。或是呐喊彷徨，朝花夕拾。也许诱惑太多，连自己也成了诱惑。或者从忍受孤独，成为了享受孤独。那些看似不可思议的，却大有它的道理。那些看似极度偶然的，却总是无法避免。当然，这不是在说教，我自认不是什么好榜样，多半只会是误人子弟，不值得学习的。只是写给过去，写给回忆，我唯一拥有的，直到这一刻，也只是回忆。所有的喜怒哀乐，也来自回忆。都说人不能活在回忆中，可是不活在回忆中，又怎能算是活着？这一刻你感受到了神经传来的疼痛，而等你感受到疼痛的时候，疼痛已然成了回忆。可是你不活在回忆中，下一秒你就忘了，不知道被针刺过的感觉，下一次也许还会被刺，但依然不去回忆。直到死，你都不知道自己来过这个世界。那样没有痛苦，也没有人生。 毕业前，班里每个人都说过一段话，说的是四年来的遗憾。说到遗憾，我说过了我不是个好榜样，我也不会再告诫谁要珍惜时间，时间怎么过的，都有它的价值，你所浪费的时间并不是真的浪费了，只是铺成了你自己的人生路，红泥砖不一定好过青石板，每天日夜劳累身心的生活也不见得会比整日醉生梦死，繁华充斥着视听的纸醉金迷的生活差。遗憾，只是来自于曾经的希望。那些没有的，可能在来的途中。而拥有的，却必定会失去，或迟或早，或是你失去它，或是它失去你，或者说已经失去的，你曾经拥有过。不用想着当时该怎么做，或者遗憾当时没怎么做，因为我相信，在整个人生看来，当时的选择一定是最好的。不用想着，如果回到过去，你便能弥补过失。也许你弥补了这个过失，却会引来更大的遗憾。如蝴蝶效应一样，牵一发而动全身，或许最好的解决办法是回到人生开始的地方重新选择，或者别来到这个世界。虽然，我并不觉得我能够拥有什么东西，什么东西都是它自己拥有着自己。也许我拥有思想，也许我就是思想。 当然，也有很多怀念的。不知道是否值得怀念，但只是怀念罢了。怀念曾经去坡上读英语的早晨，空气冷却清爽，气温低但心情舒畅。怀念和同学一起去机房蹭电脑玩时候遇到别的班开始上课，不好走开而足足听完了两节c语言，而真正学会编程爱上编程却是在那次课上。怀念上机实验的一起玩cs的时候，那时候第一次接触这种游戏，老师来了就立刻回到桌面。还有坐在实验室，突然两学妹过来跟我说她们是校报的，喊我老师给我报纸的时候，虽然无奈，但却提醒了我时间的流逝。还有大学物理实验前天照例的抄报告的晚上。还有考研时候发生的一些事。还有每次集体春秋游，还有一起去南京的实习生活。还有很多。还有。这些回忆很重要，因为回忆里有你们。而你们很重要。你们很重要，因为你们见证了这些回忆。而这些回忆很重要。 但我所能拥有的，仅仅只是那些回忆。我所能失去的，也仅仅只会是那些回忆。但我不是一个多愁善感的人，现在应该不是。曾经也有过空谈梦想的年纪，也会悲秋咏春，看白云翻滚，萧瑟天凉，看桂子荷花，烟树明月，也会叹世事无常，人生多变。而现在终于不会，我想，应该不会。我不需要梦想，只要知道我做了什么，接下来该做什么，接下来怎么做。世事也并不是无常，任何偶然也是必然的。时间的脚步也一直没有变宽。所以不必庆幸也不用悲伤，继续走着自己的路，继续犯着自己的错。愿你们的人生幸福。愿你们的回忆美满。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[临风添]]></title>
    <url>%2Fposts%2F1e8f285%2F</url>
    <content type="text"><![CDATA[1.11圈圈点点阴雨暗风寒露重兮风泠泠， 雨打窗兮夜茫茫。 浸渍久兮胶漆散， 三人言兮事已常。 我自顾兮我自忘， 我自笑兮我自伤。 花开半兮尽摇曳， 道不同兮梦不往。]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离忧]]></title>
    <url>%2Fposts%2Fb51bf43%2F</url>
    <content type="text"><![CDATA[这几年来，对学校一直没什么感觉，在这里住了三四年，原以为，等我毕业之后，学校对我而言就只是一个名字而已了。我实在不想承认这是一所大学，还是我成长的环境。 从大一到现在，被骗过几次钱了，当然，只是觉得那些利用别人同情心的人的确很可怜，比一个乞丐都穷，施舍点也没太大抱怨。但只是为什么要让我在我的大学校园里遇到他们？他们是来上课的么？我亲爱的学校，我将来是不是也会像他们一样呢？也许不该责难，忍一忍就没事了，要是这都忍不了，那岂不是，太对不起老祖宗了。学校不会为了少数人而浪费表情，但愿这也真的只是少数人。 一个人从一个熟悉得地方能带走的记忆多半不会是好的。泰塑，大舒村，还有我们学校那些食堂，那些喊起来不疼不痒的名字，那些极不情愿的留在记忆中的建筑，也许会让我在若干年后还能记起，我也曾经有过大学，或者更深刻一些。 我说我担心自己会变得像那些三教九流一样，我是真的担心。环境拥有让人不可遏制的作用力，在时间陪同下对你做功，改造一个人是很容易的。况且这里社会里的什么人都不缺，连小孩都学会了欺骗与盗窃，而且是在学校引以为傲的装了摄像头不让工人稍微多给点菜的貌似最干净却经常吃出东西来的食堂里。也许他们不是学校的人，哪一天，我成为了这样的人，学校也不会承认曾经来这里受教的我吧。当然，只是对学校，没什么太大的感觉，但映像总不会好的。不过对于老师们，还是很感激的，在这个冷淡冷漠的校园里，谁会对那些年复一年留在这里的草木舍不得呢？老师们的确很好，不需要太多赞词，的确很好。 最近可能压力相对大一些了，脾气也不好，到处不讨好。好不容易借了个位置安安静静准备学习，可是每天每夜，楼下都有一群人拿一个大音响，把音量开到最大。大概是为了运动会吧，不知道干什么，我只是佩服他们耳膜能承受的压力很大，还有天天下在面乱吼乱叫的些人，看起来喊一二一喊的真卖力，几个星期了，也是为了准备运动会吧。可是他们偏偏不去操场，非要在教学楼实验楼办公楼这儿弄，不知道是给谁看。还要弄得你没法安静学习，到晚上九十点钟才罢休，让你知道他们有多勤快。 从暑假教辅关门，到开学说好的教室被占，课程也被新来的乱排，后来的一桩桩，一件件，罄竹难书，擢发难数也许有点过，但如果就每一年的学生们，那些走出去的学长学姐和未来的学弟学妹们来说，这样来形容恰当不过了。改天那些实验楼教学楼，都会成为娱乐场所吧，大学里会充满欢乐，从此在不需要学习。那些把学校弄成这样并因此而笑的人，此刻做着什么样的美梦呢？ 我只当是逆境，来造就我，来毁灭我。]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新替]]></title>
    <url>%2Fposts%2F56ef94c8%2F</url>
    <content type="text"><![CDATA[突然有种风烛残年的感觉，像是要老去了。大四了么？ 桐花万里丹山路，雏凤清于老凤声。看到那些新生，不知说些什么，三年前和他们一样来到这片天地，也没有人对我说些什么。 我这样的啰嗦的人，却经常不知道要说什么，只是不知道何时我开始如此话多，也许是以前太寡言，也许是以后缄口不言。 但以前以后，不是现在，对于现在的我，这都不重要。 这些天发生了一些事，想说点什么。其实每天都有事发生，想想如此平常，似乎又没有说的必要了。但为了证明话多，还是写了。前几天重新看了下东周列国，从豫让如何生不易节，死不易主，到赵无恤如何使晋三分，韩魏赵并起，春秋五霸成战国七雄，再到魏文王如何励精图治，李悝吴起如何变法，到卫鞅，孙膑庞涓，以及后来的苏秦张仪，如何令山川易主，乾坤倒转。当时感于豫让的视名节胜于生命，感于吴起的做大恶之人，行大’善之事，感于商鞅为万民福祉，与自己为敌，与天下为敌……颇多的感触，现在再想，却只是这些苍白无力的文字而已。 我之所以坚持写下这些，只是因为现在我还能想到这些，也只能想到这些。 还是继续说说最近的事吧，说说开学不到一个月，停水将近二十天的泰塑么？没什么好说的，只是正常的学习受到了点小阻碍，这也正常，当你不想做一件事时，所有的条件都对你有利；而当你决定去做一件事时，所有的困难都会找上门。 当然，仅仅知道这些没什么用，每天这样胡思乱想，想的再多也成不了思想家。以前不知道在哪看到的那句“我思故我在”，当时很喜欢这句话，但后来觉得存在与思考完全是两回事，只有条件反射和应激性的不会思考的低等生物很多，便弃之如草芥。我并不否认思想的重要性，但最多只是内因，不能唯心的夸大其作用。决定事物发展的还是只能是实践，思想可以指导实践，但不能代替实践。——当然，就算只是知道这些，也没什么用。 想起今天九一八，明天中秋，两个稍微有点特殊的日子，又想起了五仁月饼，也许是因为最近在网络遭吐槽的原因。对这事没什么兴趣，只是我才发现小时候那五毛一包的广月就是五仁，可能现在的人们都习惯了软柿子似的月饼，而广月在我的印象中唯一与之不同的，也许是留恋儿时的乐趣。不好吃便不买，对于网上的吐槽，不管是无聊者的恶俗，还是商家的阴谋，我也不想问，也不想参与进去，刨根究底。 看着这些空洞无义的杂七杂八，只是担心有朝一日再不能想到这些，再不能对自己说这些，完完全全陷入了生活留下的死循环中。我常常希望我是两个人，说的那个，是我；听的那个，也是我。 对外面的事，我是不怎么关心的。这个阶段，我所需要的，只是一个无人的教室，和一个操场而已。天下，与我何干。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[豫让赋]]></title>
    <url>%2Fposts%2F795d092a%2F</url>
    <content type="text"><![CDATA[肃清枯叶过雁哀，瑟泠秋风临马嘶。死士袖外三尺剑，知己杯中一生誓。年年合欢抱枝卧，夜夜幽兰含泪眠。四姓分晋护范孤，三家破智忆主缘。未肯易节权势下，哪曾鞠躬车马前。非君不怜女儿泪，非卿未解孤臣心。共乡不识漆肤烂，同枕竟觉炭声喑。刺袍伏剑恩已酬，唯余黄土伴史留。至今桥下风声唳，二臣闻此应足羞。]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>怀古</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[借月章]]></title>
    <url>%2Fposts%2F179dffb0%2F</url>
    <content type="text"><![CDATA[曾记高梧暮池旁，荷下碎月潋光。 芙蕖现清水，莲子隐翠房。 不知年年佳期会，相许定几时？ 过尽帆鸿，笑叹海誓谁曾知。 春红残败秋风起，不问愁怨别离。 街醉人正欢，灯孤黄卷寂。 听得楼头枕边风，明朝君何能？ 天生吾徒，岂教空老负此生。]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[竹节记]]></title>
    <url>%2Fposts%2Fe091e5ba%2F</url>
    <content type="text"><![CDATA[有时候想说些什么，而真正说的时候又忘记了。今天就是，可能是没休息好的原因，也是困扰了很久的一个问题，当一个人的兴趣开始变的不合时宜的时候。 今天立秋。冷在三九，热在三伏，就是人们说的秋老虎。我对这里的秋天没太大感觉，热完了，就直接开始寒冷了，四季都是如此，这里似乎找不到过渡的季节。那些刮着下着连月不开的风和雨的叫春天，雨停了，就夏天了。我快忘了，粉黛桃花，落英缤纷如雨，梨树生雪，初生回眸，个个灿烂笑颜，随风招摆，幽香满园，引得蜂蝶争慕。那些梧桐树叶开始凋零的叫秋天，落光了，就冬天了。不曾想过，枫叶满山，霜红浸透层林，风高气爽，苍苍凉凉，摇摆着一望无际的金色麦野。只是阴雨绵绵的日子还是一样寒冷，梧桐一叶落的今天还是一样炙热。说到过渡的季节，这里似乎一天都可以完成。 我开始感叹这天气，我对天气并没太多抱怨，只是最近变的浮躁了。还是今天没休息好，还是那个困扰我的却一直无法解决的问题。 有时候不管学什么东西，开始的时候，觉得学习只是一种工具，于是你努力的学习，学着学着，最后你发现，自己成为了工具。 一件事能变成兴趣的确不容易，可是当初你拿它来消遣，成为爱好后，欲罢不能，不知不觉，最后成为了它的傀儡。 变的不合时宜了，但骑虎难下，放弃比学习难。于是每晚都入眠太晚，睡眠时间不够了，精神自然不好，脾气不好，各方面都不好。今天居然到了凌晨三四点才睡，于是懒得上去了，就在寝室地铺，可惜三台风扇全升级成了电吹风，我亲眼看着天空由黑变灰变白。 今天一天效率太低，大部分时间是睡过去的。穷则变，变则通，我当然不得不改变，感谢今天“大夫”的建议。 不知觉，现在又是一天了，这里楼顶上的天空依旧是为数不多的一些星星吊在那里，周围的人都睡了，目似瞑，意遐甚。来到这个八月，似乎我也困了。 竹子上面有很多竹节，而没有竹节的竹子是长不高的。且学青竹君做个节，不致让今天再影响了明天。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑呓]]></title>
    <url>%2Fposts%2F41e08ba2%2F</url>
    <content type="text"><![CDATA[前几天回去了一趟，跟同学一起的。ta是回去办身份证，我是回去拿个起子。很牵强的理由，但有时候对于漫无目的的事，找到一个说服自己的理由真是难于登天。我说是食堂关门了没饭吃，但的确还有红房子；我说回去把电脑封印，但我最终还是带回来了；我说回去吃好吃的，但一回去就口腔溃疡，几乎每天都是豆腐；我说回去养病，但之前身体好得很；我说了回去拿起子，修电扇，但我还是没拿，外面随便买一个都可以了。在家有个习惯就是晚饭后散步，望不尽的绿野青禾，路两旁稻飞虱穿来穿去，火烧云一片，暑气既已全消，夕晒尚有余温，现在完全看不到一个人在田里，大家都很闲，播种的季节早过了。门口来往的人多半是去牌场消遣的，再就吆喝着八毛钱一斤的西瓜的手扶拖拉机。所说要忙，就是几家喝酒了，但与我无关，我是不操心也不愿去的。家里时间过得太快，看完了岳飞看看龙门镖局，都没缓过神来，我要走了。口腔溃疡好的快，一支西瓜霜就解决了。好了过了一天，我还是决定要回来的。家里没有学习的习惯，我还是无法心安理得的享受在家里衣来伸手，饭来张口的生活，在家比在学校压力大。现在不是收获和享受的季节，我是准备回来了。天气热的原因，下午两点才出发，到了仙桃车站，然后凭直觉步行到花源酒店。我敢说，这是我第一次在仙桃独自一个人走这条路，我对仙桃的路很不熟悉，原谅我长在那里。然后坐车到了天门火车站，在那临时买票，只剩一张了，一等座，贵四块钱，三点钟买的票，三点过七分的票，然后立马跑到了上车的位置。一等座，第一次，看我位置上有个袋子，我礼貌的问那位置有人没，旁边的乘客就看着我。我拿出了我的票，然后她就笑了。我说我该感谢她的朋友。她和她朋友一起买的票，结果她朋友身份证消磁了，没办法回去改签了，他说刚刚改签的，我就上来了，坐了他的位置。然后，地铁，公交，就在寝室了。我该说些什么呢？或许这次口腔溃疡是因为我话太多了，该扎扎实实做点事了。我来，看看能改变什么。]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习日志8]]></title>
    <url>%2Fposts%2F37928299%2F</url>
    <content type="text"><![CDATA[上午实习老师完成任务的讲了下硝酸的制造工艺，下午就是放假了，没啥，就睡了半天，合着马上就要走了，大家也都开始做着离开的准备了。 上课太困了，天气开始变热，再加上沟通比较困难的方言，上课就很容易走神了。天马行空，毫不搭调。 不知不觉已经过了这么长时间了，学习也荒废了不少，人也变得慵懒了，想改变点什么，也只能想想。而对于无奈，能做的似乎只有等待。但是该有点期冀吧？ 随着年岁的增长，听说越来越多的人不会笑了，还有人做过科学统计，成年人通常每天笑10到15次，而孩子每天能笑400次，也不知是真是假，但我还是宁愿相信。都希望天天快乐，笑口常开，但实在笑不出来。且不说笑，哭只怕更少。或许是成长的代价，小时候对生活的太多幻想，像一个个彩色的气泡，再斑斓，依旧是在生活的大气中，一个个破灭，消失的无影无踪，连回忆里恐怕也很难找到它们的影子了。 最怕的还是没了希望，当然，没了希望的生活，也不会再有什么害怕的了。 暮暮又朝朝，月月复年年，在世事的艰难中逐渐变得冷漠的我们，虽身在闹市中却觉得孤寂无比，甚至落寞绝望。我很担心会变得麻木，人一旦没有了期冀，就容易变的麻木。而人一旦麻木，便忘记了生存，陷入了为生活挣扎的死循环。而通常让人从麻木中清醒的，只能是痛苦。 还是那句话，我无法说哪种生活更好，就算没有目标，就算生活中到处是挫折，人生的路上满是泥泞，你依然对明天抱有希望，就算你没有目标，没有梦想，可你却能真真实实地体会到自己还活着，而那些酸甜苦辣掺杂进回忆里之后，发酵成的名词，叫幸福。 你冷漠的对待生活，对人世的悲欢离合不再有着那些喜怒哀乐，虽然不会幸福，但也没有痛苦，你把自己关在一间小黑屋里，然后关上了仅存的一扇天窗。你来到了这个世界，就好像没来过，留下的是会动的躯壳，回忆也是一片苍白，你的心跳终于赶不上时钟的频率了，最好彻底被遗忘，你这样想着。 想到这里也下课了，落笔至此，略嫌啰嗦。 那些没有说完的，永远说不完的，终于永远不用说了。 2013年7月2日 晴，热，微风。]]></content>
      <categories>
        <category>实习日记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>实习日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习日志7]]></title>
    <url>%2Fposts%2Fa72d9f08%2F</url>
    <content type="text"><![CDATA[今天有点不同，今天太无聊了，上午讲课，下午还是讲课。 无聊，除了这个词，感觉就是一片空白了。上课随手拿着粉笔在桌子上勾勒几笔，不知不觉，发现了一个美女，然后惺忪的睡眼立马激活，各种描绘，然后配上几句诗，可惜桌子太光滑，实在不好写，字也歪歪斜斜，煞了风景。 这无聊估计是因为生活太舒服了，我还是希望像前两天一样可以累的趴下，在麦当劳睡得像猪，或像军训时候，帽子往下一拉，站着就可以睡着了。 生于忧患，死于安乐。这里条件太优越，的确很不适应。高楼百丈里，昼夜歌舞中，可以让人们享受人生，也可以消磨人的意志。茅檐陋室清，伴与流萤眠，虽然清贫了一些，但却激励着自己，去实现人生的价值。青春，是人生的春天。春天，是播种的季节。 来这里这么些天，突然有点想回去了，像成奂生上城里的那句：此地虽好，但不是久留之所。我还有自己的事，考试完后的放松也差不多了，还是负重的生活好，过着舒服，踏实。 还剩着几天，写日记也写过来了，也许是乱扯过来的，都是没有感觉，为了坚持下来这个习惯而写的，觉着也是浪费时间，写的不咋样也没关系，小学老师讲怎么写日记的时候，我不知道有没有上过那节课，如果上了，那肯定是没听的。不过还有几天，过了就好了。突然想到了今天回去考试的同学，希望你能及时赶上考试，再大的坑，掉进去了也要爬出来。 没有路的时候，记得回头。回头的时候，不应该有遗憾。 昨天更新的海贼王还没看，嗯，回头了，这是个遗憾。 2013年7月1日晴，热，微风。]]></content>
      <categories>
        <category>实习日记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>实习日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习日志6]]></title>
    <url>%2Fposts%2Fd02aaf9e%2F</url>
    <content type="text"><![CDATA[早上，五点，行程继续。 起这么早是有原因的，记得昨天前半夜还在玄武湖睡，后来风大到里面了，结果在里面睡觉被虫子咬的不行，后半夜还是辗转麦当劳了，他们打牌，我就趴着了，似睡非睡，也许是睡了的。只是苦了那些女生们，网吧的一夜真不该是她们过的。 最大的感觉还是累，这两天不知道走了几十公里了，与其说是旅游，不如说是体验生活的，真的是怀着这种心情。谁会享受呢？这次的苦主们，看你们一个个回来时的样子，垂头丧气，无精打采，如被霜打了一般的青菜，萎了，蔫了。 今天真是走够了，从早上五点，到十一点，基本上都是走的，玄武湖饶了一小圈，其实也不算一圈，有些位置还没去。看了玄武门，失望的发现那个只是朱元璋迁都南京时修的，不是李世民确定地位的那一战里的那个玄武门。高高的城墙颇有点气质，但也就那个城墙。但大家似乎都快走不动了，加上昨晚没睡好，早上没吃好，已经没有了拍照的心情，手机也没电了。有点穷途末路，弹尽粮绝的味道，但我们一路上还是走着，说着，笑着。 体力真的是很重要，昨天在东南大学没吃舒服，早上昂贵的隔夜粥，就吃了几颗米，难闻的气味，老板娘恶劣的态度都没能影响我们的心情。用英语发泄了几句之后又开心的边走路边聊天了，由此看来，学一门外语还是有点用处的。 今天逛的地点几乎都是在玄武湖公园里，其实风景很不错，里面的人也很好，和一位老奶奶聊了会，然后就继续赶路了，从早上五点到将近十一点，就是在走着，走着，走着。 所幸的是，在不停的研究地图和问路的情况，终于摸着摸着，摸到乘车点了，上车就睡了，下车的时候，血量已经回复了百分之三十。然后十二点多吧，吃了两大盘子饭，舒服。回去洗澡，睡觉。 下午不知道要写些什么，因为醒来时就五点半了，而且还是被吵醒的，不过没关系，现在血量回复了百分之七十，精神很好了。出来吃饭时，看到我们班那99分的身体，疲倦的身影，憔悴的神形。 两天，走过了大半个南京，怎一个累字说的清？但是我们心情好，像昨天说的没有遗憾，没有后悔。外人看来一群屌丝，一路欢声笑语不绝于耳。回来一觉，累了之后才体会到舒服。 这次还是有准备的来的，虽说压根没准备什么。但世事无常本是这个世界的常理，无法预料，生活中的困难，难道会因为你一句没准备好而放慢它的脚步，而你就等着有人来帮你么？ 其实没有那么多感慨，只是觉得，不管在什么路上，不停的走，就行了。 2013年6月30日 晴，热，有风。]]></content>
      <categories>
        <category>实习日记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>实习日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习日志5]]></title>
    <url>%2Fposts%2F4923fe24%2F</url>
    <content type="text"><![CDATA[有时候题目与文章没一点关系，今天就是。仅仅因为发生在实习期间。 南京站，玄武湖，中山陵，明孝陵，总统府，中南大学，夫子庙，水游城，三山街，张府园，南京站。今天比实习累，现在在地铁上。 早上九十点钟出发，一天之内走过这么些地儿，是需要点毅力的。不过也基本上只是玩玩，免费的进去逛逛，收票的在外面逛一圈。不过更有毅力的事，就是现在地铁上继续日记。现在地铁里没有了白天的喧嚣嘈杂熙熙攘攘的人流声，安静，幽静，寂静。 一段时间，已经下了地铁，刚刚到了玄武湖旁。白天与晚上，玄武湖完全是两种不同的感觉，褪去了炙热，天阶夜色凉如水，想泡泡脚，可惜台子高了点。人在囧途的感觉，有种想把今天写成传奇的冲动。 我要说点什么，但是只是些零碎的片段，以我现在的状态，很难将它们连缀成一句话。 从南京站说起吧，做了一两小时到了南京站，准备买四号五号的车票，结果居然最多只能买到三号的票，我这么多天的准备。南京真有意思。 而后，去了中山陵，里面百分之九十以上是卖东西的，价格翻一倍。瞻仰了一下国父遗风。 云山苍苍，江水泱泱，先生之风，山高水长。不知道怎么就想到了这几句，忘了是谁说的。革命尚未成功，同志仍需努力，斯世同仁，无不疾首缅怀。那里还遗留着一些收门票的机器，不知他如果知道，自己百年之后，坟冢成为了商业工具，会做何感想。 后来到了明孝陵，收门票，没进，后来听出来的人说没意思，也不遗憾。今天只是多见识点东西，不是怀着旅游的心情。 之后就是总统府，门口逛了一圈，拍照，这地方算来过了。 然后到了南京外国语学院，之后又到了中南大学，解决了晚饭问题不过感觉有点坑，但也没啥，只是印象不好。 之后就是夫子庙了，琴鼓笙歌夜如昼，花街璀璨灯火流。只是，有这么一群屌丝，徒步走过了夫子庙之后又三四个站，只是为了找一家麦当劳睡一夜。可是，夫子庙里的麦当劳居然晚上关门，没办法，走了两三个小时，就在找那个24小时营业的麦当劳。 去麦当劳的决定不是一时冲动，是在受不了网吧烟味和嘈乱，在看不起附近旅馆的天价房间之下而做出的。只是一路来，居然没有看到一个麦当劳，而且也摸不清身在哪个确切的位置了。可以说是迷路了，也不能这样说，只是懒得管了，毫无目的的走着，当然，也不是毫无目的，目的是麦当劳。 但最终还是放弃了，不得不清醒，找站牌，坐地铁，因为想起了火车站的麦当劳。 现在，到了。不过没去麦当劳，就在玄武湖旁找了快地，躺下了。屌丝气，小强命。 现在没有任何抱怨，没有任何遗憾，席地被天，满怀期待，就等明天到来。 2013年6月29日 晴，热，有风。]]></content>
      <categories>
        <category>实习日记</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>实习日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习日志4]]></title>
    <url>%2Fposts%2F3e24ceb2%2F</url>
    <content type="text"><![CDATA[日记真的是每天都要写的么？又是无聊之中的胡思乱想。 我记得小学一二年级的日记，都是爸妈代写的。由于我们俩从幼儿园到初二，一直在一个班里，小学日记当然是一样了。我记得有次写得好，全班第一，老师念了我们俩的日记。对于几乎从来不写家庭作业的我来说，无疑是个天大的喜讯。那天早上本来不肯上学的，因为老师说先交日记再进教室。我们俩都没做，胆子小，不肯来上学，然后那天早上起床了，爸爸在旁边念，我们俩写。虽然不喜欢一样的，但关键时候，没办法。 然后老师念了：“今天，我们起床了，好冷啊，接着，下起了小雪。。。。。。（后面的不记得了）”念完一个,老师说什么开门见山，直抒胸臆，情感丰富什么的，然后班里鼓掌。然后念另外一个的，“今天，我们起床了，好冷……”然后班里一阵唏嘘，老师为我们圆场，说实际情况是这样的，他们的一天是一样的。 小学时候很少受表扬，一年级等于没读，考试也没让我们俩考，在老师眼里，从来没有奢望过我们有能力回答他上课提出的任何一个哪怕是全班都认为很简单的一个问题。那时不记事，没什么感觉。成绩单上没有好话，我是个标准的最差生，以至于一篇日记，都能让我记这么多年。现在想起来，那时的幸福，这么简单。 再说说今天的日程吧，上午无聊的讲课，当然，说这课无聊应该不只是我一个人的感觉，我说的不是其他同学，而是实习老师，完成任务的态度都看的出来。然后回来睡觉，然后我们五个人去吃饭了，点了四个菜，dy和我有点激动，吃的稍微多了点，不知道他们有没有吃好，我想以后我会文明点的。下午，闻得是硝基氯苯，邻硝，伤肝，喝过酒的不能进，感冒的不能进，一天之内也不能喝酒。所以今天打完球就直接吃饭了，喝的饮料。去的时候回来的时候都逛了下太子山公园，里面几乎都是老人和小孩，一种静谧和谐的感觉，就是“落霞与孤鹜齐飞，秋水共长天一色”的那种意境，旁边一个小女孩扶着她奶奶散步，从我们身边走过，很随意的一个场景，却莫名的有些感动，我们都在感叹那小女孩的懂事。 该懂事的年纪，是从什么时候开始呢？也许是生活的选择，过了我命由我不由天，意气风生的年纪，有的人选择了服从，他追求的是安定的生活；有的人依然不屈不挠的披荆斩棘，他想要的只是一个过程，奋斗。 懵懂不知时光转，生活面前，会如何选择呢？ 听说今天有同学来，暂且搁笔。 也是找个借口，不想写了。 2013年6月28日 多云转晴，有风。]]></content>
      <categories>
        <category>实习日记</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>实习日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习日志3]]></title>
    <url>%2Fposts%2Fa0405b11%2F</url>
    <content type="text"><![CDATA[如果不是兴趣，坚持本身都会是一件无聊乏味而又痛苦的事，正如今天的日记，第三天，实习，继续。 上午讲的离子膜，老师准备了课件，却不料只有黑板，看她那样子，估计之前找教室都费了不少劲。 也是随便讲讲，都是高中化学里的。然后很快完了，就和我们聊天了。当然，与其说是聊天，不如还是说教育，只是现在说的是上班之后该怎么做与不该怎么做了。无聊的时候，玩了下同学的手机，不经意看到了几张艳照——当然是玩笑，你们不会介意。 下午是实习了，昨天闻的苯，今天就是氯气了。好在苯可以致癌，氯气就权当消毒水了。只是对那个女老师有点疑惑，25岁，常州大学，在这工作了十年，不明白她是怎么做，怎么做到的。今天天气不错，由于兴奋，中午yz把裤子穿反了，下午dy把褂子穿反了，不过都及时地在发现之后改过来了。完后屁颠屁颠地都跑过去打球了，包括我，因为，实在，太无聊了。 嗯，的确，很无聊，比我的啰嗦更无聊。如孤村荒林，或者那种人迹罕至的深山老林里晌午聒噪的蝉鸣，更像枯冷的冬夜里的几声乌鸦叫，把林子把夜叫的更显安静了。这安静，叫人厌烦。 看不到大漠，却有孤烟直，几处高耸入云，或黑或白，染得天空如水墨。化工厂随处可见，安静的烟囱，可以看出没有风。 写了前一半，一起打球，一起吃饭，喝酒。再写下一半时，已经忘了要写什么了，可见想做的事还是及早做的好。我的话多，我明白很少有人能忍受，除了我。但现在，真的不知道说什么了。 我也曾幻想过闲云野鹤的那些不切实际的生活，一种精神慰藉，是对某些早已厌倦了，却不得不继续面对的事，这是一个人最累的时候。然后睡一觉，忘了，继续生活。 风吹过外面的树梢，沙沙的响，看不出昨晚下过一场雨，日子继续过着。 2013年6月27日 小雨转阴，阴转晴。]]></content>
      <categories>
        <category>实习日记</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>实习日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习日志2]]></title>
    <url>%2Fposts%2Fd7476b87%2F</url>
    <content type="text"><![CDATA[今天还是讲的氯碱工业和氯苯制取，不过换了个老师。从苯的干燥氯化到尾气处理，无聊的要紧。很快讲完了，然后不自觉的问了我们一句啥专业的，那惊讶的表情就出来了。 没有写日记的习惯，不知不觉就会记流水账了。 现在每天应该都是这样，上午讲课，下午进厂，晚上写写日记，吃饭，玩手机看电视睡觉。继续下一个循环。 今天没怎么下雨，偶尔有点毛毛小雨，皮厚的还感觉不到，太阳有时候从云后面出来下看看这一群，长袖长裤安全帽，不仔细就一群搬砖工人。下午进厂的时候，一直闻到一种气味，可能有苯的成分，就是难闻。说好了不准带手机，但还是让拍照了。看了那些设备，很大的东西就一个很简单的用处，还有很多浪费的。也许，中国的技术不行，这个昨天也听实习老师提起过，外国的工程师，带的工具和我们一模一样，但工艺好，技术精，就连一个焊接都能让你瞠目结舌。 再说到浪费，突然想起了以前不知道在哪看到的一个煮蛋的故事。日本人煮鸡蛋和中国人不同，他们是把器皿弄成10厘米左右的正方型。一个器皿里可以分开好几区域，这样把鸡蛋放进去的时候就能用最少的水而煮最多的鸡蛋。而中国人就直接是一锅煮。我不知道，是煮蛋还是煮水。虽然说的是要煮鸡蛋，可我们常常为了煮一个蛋，煮了一锅的水。 我还是不想下什么结论，也许人生是为了煮水，偶尔加进几个蛋，却也无关紧要。我并不希望我的人生的结果是去煮一个蛋，我全部的记忆，都是那锅水。当然，我并不知道人生的结果，也与我永远都不会知道。 这里虽然人少比较偏远，但随处可看几辆奔驰宝马凯迪拉克，都安静的生活着。我没法评价，只能说每天为了完成任务打发时间，这当然是不去上网不出去最好的选择。 还有你们的那些安全帽，自己过来拿。 2013年6月26日 阴转晴转阴转晴，偶尔夹杂点毛毛雨。]]></content>
      <categories>
        <category>实习日记</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>实习日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习日志1]]></title>
    <url>%2Fposts%2F4e4e3a3d%2F</url>
    <content type="text"><![CDATA[初至南京，记得来之前老师说每天一篇实习日记，也算是完成任务，也算是刚刚结束六级与期末的放松，也算是啰嗦几句。 离题万里若等闲。 昨天没有见到天气预报里的大雨，来的一路上愉悦心情，D3082，四个时辰，从汉口至黄山至合肥至南京南。虽然只坐过两次动车，但感觉火车上的人，除了卖东西的都很好，那些买站票的农民工，两鬓已被牙齿染色，却依然笑着，笑着为生活奋斗奔波。他们会毫无顾忌的与你聊天说地，或者自己一个人拿着已经过时几年，看起来都像是上世纪的国产机，放着歌，声音开到最大音量了吧。如果这是某个学生，我肯定会鄙弃加以憎恶反感的，而且往往这种歌多半是为了显示自己的潮，大多数人只能默默的厌恶，或者奔腾过几只草泥马，毫无素养，毫无美感可言。但是对于农民工，却没有，他们听的事我未曾听过的属于他们年代的歌曲，他们或许不懂流行，但那些歌曲却让我分明感到的是他们多年简单的心酸，奋斗的泪水。与他们的交谈中，我为自己的历史常识捉襟见肘而羞愧，他一直聊着解放时代，抗战时期的事，自豪的给我们讲着哪位哪位将军，哪位哪位元帅，我只能静静的听着，戴着耳机，但我早就关了歌曲。 昨晚到了南京，大家的最大反应不是天气预报不准，而是这里的妹纸少，质量低。而关于这个问题，在宿舍我也说过喜欢美女，鸭子说，容颜都会变，年纪都会来。这话我听过很多遍，但昨天第一次有不一样的感觉，说不清什么感觉，但的确不一样了。昨晚分的宿舍，空调热水大床厚被子，晚上看看电视聊聊天，可能价格有点高，但与一些现象相比，我很感激。 今天是实习的第一天，理所当然是安全教育课，氯碱工业，有机如苯的反应制氯苯等。各种有毒有害，易燃易爆。对于这个南化，我本是不曾了解的，但却听到了一个很熟悉也很钦佩的一个名字，侯德榜——第一任厂长兼总工程师。 今天刚进入梅雨季节。梅雨，霉雨。本来很愉快的以为，不管外面或是烈日当空，或是酷暑难耐，有了空调就好了。淫雨霏霏。连月不开。外面的温度开始比宿舍的温度低，听实习老师叫我们不要在这买东西，说着那些骗着外地人的丑恶嘴脸，说着这六朝遗留下来的文化，被污染的体无完肤。 2013年6月25日 中雨转大雨转中雨转小雨，晚上停。]]></content>
      <categories>
        <category>实习日记</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>实习日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等]]></title>
    <url>%2Fposts%2Fdc21e617%2F</url>
    <content type="text"><![CDATA[不知道我在等什么。 展厅里的一束花，等待的是众人艳羡的目光？ 可是路边的野百合依旧怡然自得的展露他的芬芳，沐浴着微醺的令人意醉神迷的阵阵暖风，似乎从没羡慕过任何可以用美来形容的世间万物。她们得意地花枝招展，宁其一生孤芳自赏，不愿融入这个纷繁芜杂的尘嚣之中。 在写这篇文章时犹豫了很久，不知道是否有写下去的必要，直到数十天之后，再次从尘封的草稿箱中捡出当时兴起而未成的无稽且荒唐的话题。当然，如果我有时间，我愿意把以前脑中闪过的每一个想法都写下来，用那些涉世不深的文笔，虽然在以前这对我是种折磨————任何高雅的兴趣，一旦与考试联系起来，都会成为折磨人的低俗习惯，变的无味，甚至惹人厌恶鄙弃。 而且我也宁愿固执地去相信，这绝不会只是我一个人的感受。 显然并不是所有时候都适合等，我的实验报告等不了。老师第一次没有收，然后它就没了。 可是依然等着。 过了一天，它又回来了。 在此期间，一个同学因为幸灾乐祸，也弄丢了报告，可是他没有等，他重抄了一份，虽然他的那份后来也找到了，我也笑了他，但这并不是什么可喜的事，打心眼里没觉得高兴。 举这个例子我没觉得有什么必要，但是我还是举了，当时的冲动罢，也就放在那里了。 所以，不管发生什么事，悲伤或是快乐都为时尚早，最起码你无法预测如果你继续活下去会发生什么平凡的或是不可思议的事。当你在弥留之际如果还能回忆起你人生中种种曾经让你笑让你泪的那些事那些人，或许无法去评价你的人生是喜是悲，或许已经不再会有感觉了。你曾经后悔过的事你不再后悔，无法挽回的事没有遗憾，你要走了。周围的人可能不想让你离去，但他们早就做好了送你的准备，你可能会想哭，但你已经没有泪水。 我写文章从来都不知道自己的中心在哪————这跟我说话一样，大部分时间是侃侃以活跃气氛的适合闲聊的话题。连小时候的作文也是，除了中心要突出，我不记得以前的语文老师还教过我什么，除了把那作文指导书或是教案上的要求给我们念一遍，好像不记得什么新颖的做法了————当然，这在当时的他们看来或许是比较高明的，而且足以应付教学需求，足以应付什么都不懂的学生们。我一直觉得自己运气好，或许我遇到了不一样的老师，他没有应付什么都不懂的我，但我还是什么都不懂。虽然他应付与不应付看起来没差别，但我宁愿他没有应付，我希望没学好只是我自己的责任。我说这话没别的意思，只是不愿让我这文章的中心停留这一个已经老掉牙却依然流行问题上。 但是文章没有中心是我唯一没有为自己觉得遗憾的，甚至为自己没有再遵守以前作文课的时候的应试作文的这个要求而沾沾自喜，不必被那些分数束缚。我甚至连一句结论性的话都不想写，因为这本该是读者的工作。手中紧攥的风筝的线的另一头应该不是风筝，只是一只麻木的飞鸟。日复一日的被牵引着，使它不敢飞得再高。就像被一群苏格兰牧羊犬围追堵截的惊慌失措的那群绵羊们，不得越雷池半步，偶尔有个把不听话的绵羊跑了出来，身手敏捷的牧羊犬马上跳出来将他咬死。终于，为了上等的羊毛，牧羊人们培养出来了一群听话的被阉割了的绵羊。这不残忍，它们已经感觉不到残忍与悲哀，这是生活，是绝大多数只在城里生活的人不会了解的现实。我庆幸自己终于离开了作文课堂，许是上了年纪的好处（当然，这话不敢随便乱说，我这里用括号括起来）。文章如生活，人的一生每一个阶段可能应该或许有一个中心，但是人生的中心是什么？活着的时候你不去想你为什么而活着，因为这个只有活下去才知道答案。快要撒手于世的时候，你想通了吗？或许那时候你已经想不到这个问题了。 我一直固执地认为，人生不需要中心，因为需要太多中心。我不希望我被理解，因为理解了就会有人来规劝你，来说服你。我是很乐意与人争辩的，但不想将时间浪费在这个上面，看了觉得有错的也不要来规劝我，这是徒劳的，我不会领情。我从来不奢望自己能写出什么样的水平，让你笑了，我无可奈何；让你哭了，我也无可奈何。至于在深夜，你深有感触地说：这他妈不是当时的我么？然后看着，笑着，泪着。这当然是我莫大的荣幸。但人生的阅历还不够如此。 再换一个话题，我是不是很矫情？我想，矫情总比做作要好的多。每个人都应该有感性和理性的一面，这是毋庸置疑的。至于为什么男人要可以隐藏其感性的一面，我就不理解了。或许是我涉世未深，或许这是生存的法则，那我又该庆幸，庆幸年纪小的好处。我不必掩饰什么，尽管有人会对此嗤之以鼻，然后把他的感情永远的锁在自己的小天地里，不跟任何人提起，运气不好的话就带进了棺材，而留给人的是本来不是他的他。大一的时候写的那些诗，当时终于鼓起勇气写了出来，我依然是庆幸，要不我现在就很可能还是一个循规蹈矩的好学生了，还好我不是。 写了这么多好像文不对题，那就暂时回到题目上来。文章我也不喜欢写题目，一旦写了就容易限制作者的思维，同时也限制了读者的思维————他们本该有不同的感受的，这也是我看文章最大的乐趣，没有陷于千篇一律的中心论点里。也就是说，我本来不打算写题目的。但是发表不了，所以便一字以蔽之。但我终究还是要说说这个话题的。我一直觉得自己在等着什么，或有什么在等待着自己，我也宁愿相信不止一个人有这种感受。知识，爱情，和对人类苦难的同情心，是人类所具有的三种永远不会过时的美。我所觉得的悲剧，就是这三种美最终被世俗打得支离破碎的时候，或是被尘嚣湮没不复存在的时候。也许那时不会意识到这丑恶不堪，当美感失去的时候。 我和你们一样，在自己的耕地里播种，施肥，浇水。顶着炎炎烈日，解救那干涸的土地，不辞劳苦，没有怨恨。只是希望那些小生命茁壮成长，定期除虫撒药除杂草，我希望都是自己的努力，不需老天的眷顾。最后到了收获的季节，你们的稻田里颗颗穗粒饱满，善良而富有的邻人为我惋惜。而看着那些 干瘪的稻子，我发疯似的大笑，我的付出不比他们少 ，得到的自然不会少。他们的怜悯只会让自己变得可怜。 你在黑夜里等待着光明，而太阳出来的时候，你倍感欢欣，太阳走的时候，你却寂寞了。你回到了你刚开始的状态，却不习惯属于你的黑暗。如果不曾遇到光明，你不会发觉自己生了一双眼睛，当你习惯用眼睛看世界的时候，你又回到了黑暗。太阳本来不是属于你的，布泽万物，你应该感激，可你终究没有，你甚至心怀怨恨，你开始诅咒，既然最终要戴上桎梏，何必需要曾经的自由？生活中，我们是一个人出生，一个人死亡，为何中途非要两个人生活？这是我安慰人的一句不高明的话，我知道，除了古代的和尚尼姑和教士神父们，有这种想法都是不合时宜的，我也不能免俗。也许两个人更好，我只是想说，一个人，也可以生活。 我还是等待着，我无法避免说是在等死，这是每个生灵不可逃避的宿命。但我们等待的却真的不会是死亡，既已知道结果的必然性，便没有等的必要了。尽管我还无法保证，我也宁愿固执地相信，有什么在等着我。不管我的脚步朝着什么方向，终究会遇到的。 野百合等待着他的命运，放在毫无生机的展厅里，或是在她生长的野地与百花争艳斗姿。我说不上哪种生活她会喜欢，人类无法了解植物的情感，也许万物是有灵性的，但人类目前无法了解，你不知道花的感受，花开堪折直须折，莫待无花空折枝？或是宁可枝头抱香死，何曾吹落北风中？人类给她加上自己的情感，它便有了情感。这篇不知道写什么的文章也是，希望赋予它情感的不是作者，而是读者。而这也将会是我莫大的荣幸。 你在等待着什么呢？]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周郎忆]]></title>
    <url>%2Fposts%2F3e23e45%2F</url>
    <content type="text"><![CDATA[三爵之后断琴声，意气风生美名卓。昔时协策定江东，年少志酬明君佐。胸中万千兵家计，胜负不待明日晨。虎帐临军且谈笑，一炬四海定三分。阿满徒笑袁表无，不知公瑾在岸东。弹指万千樯橹尽，赤壁如昼火如龙。山高月小连天幕，水湍浪急奏凯师。奇谋险兵仁退挫，豪情一掷千金诺。杏花烟浓蹉跎尽，天下大事不敢忘。九霄琴音英姿飒，红雨国色袖添香。尊前琴女竞相思，宁误一曲换郎顾。只叹未尽天伦情，音书从此随尔无。风流天下才情调，左右婉转皆娥眉。忆君青冢门前土，埋了多少英雄泪！]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>怀古</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你]]></title>
    <url>%2Fposts%2Fd617d273%2F</url>
    <content type="text"><![CDATA[你，我似乎很熟悉。对你有一种亲切，与生俱来；对你有一种陌生，恍若隔世。我笑，你笑；我哭，你哭。我痛恨，自己总是无法超越你；我欣喜，倒霉的时候也有你陪着。再努力，还是无法超越你，却有一种快乐的心酸；再荒唐，你也一起堕落了，分明感到了狂喜的痛苦。也许我们一直在一起，所以我不该觉得孤独；也许本来在两个世界，所以我才摸不清你的情绪。再善于伪装，却逃不过你的眼睛。做的再多，你也只是过而不问。我们总是做着同样的事，是你的主意，还是我的决定？我们总是犯着同样的错误，是你的责任，还是我的过失？以前我们都惯于沉默，以后或许也只能用沉默来回忆现在的沉默了。终于，我忍不住了，我说我们一起奋斗吧！你还是静静不语。那我当你默认了啊！可是我还是不认识你啊！不算真的认识。可你一定认识我的，你也一定了解我的，你到底在哪呢？直到有一天，早上起床，我拿着杯子。在镜子里，蓦然瞥见了，那个睡眼惺忪的你。你是否也曾和我有过一样的感觉呢？你，我似乎不曾了解。]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒之岁碎言]]></title>
    <url>%2Fposts%2F1f4b713c%2F</url>
    <content type="text"><![CDATA[俺没有写东西的习惯，在以前写作文都是煎熬。但现在突然觉得，有些辉煌，你不留下来，你就会后悔遗失；有些经典，你不记下来，你就会后悔忘却。临晚照对晴空，这难得的好天气；无来鸿无去雁，却也无防碍，本不愿附庸风雅，况这大寒天气，俺自以为身体要紧，哪有这闲情逸致怀古伤今。只是不小心想到了一些人，一些事。怕说了无益，又怕不说就忘了，也许是在家闲着无聊。 罗嗦，俺性格。 突然想到了周朝。周朝，是的，我国最早有明确记年方式的朝代。自文王演易经八卦，武王伐纣，姜太公渭水垂钓，算来周朝历近三百年。印象深刻的是直到第十一代周王静暴毙，太子宫涅即位，开始了昏乱的统治。 不听忠言，不遵周礼，还将劝谏的褒大夫割舌囚之三年有余。后其子为救父亲，效仿当初苏护出狱的故事，然后褒姒登场了。只是那费仲尤浑换成了虢石父，那妲己成了如今的褒姒，那商纣成了如今的幽王。却同是荒淫无道，同是佞贼满朝，同是黄钟毁弃，瓦釜雷鸣。只是换了个时间，换了个地点，历史被重演而已。 为其一笑而狼烟起，因其一颦而信义失。及至犬戎进犯，身死骊山。 当然，带着神秘色彩的褒姒也不知所踪，关于其说法有很多，但这不是重点。而人们大多得出的结论是红颜祸水。 红颜祸水似乎在历史上屡见不鲜，而似乎也屡试不爽。从之前的苏妲己到后来的褒姒，再到西施，到玉环、飞燕，皆为尘土。在男权的社会里，也许太美就是种罪。有功都是男人的，有罪都往女人身上推。昏庸的周幽王，没有褒姒就不会灭？呵，鱼儿上钩，皆责鱼儿贪，却无人怪钓者。 自周天子划地分疆，各诸侯们的故事可谓精彩绝伦。当然，俺想说的要从周平王开始，此时周朝已逐渐衰微。居然与自己的臣国郑交换太子互为人质，可见郑国的实力之强大。郑国君寤生，是在其母其弟的反对陷害下继位的。 寤者，逆也。 在杀了谋反的弟公子段之后，又发誓与其母不到黄泉，决不相见。这当然是人之常情。说到庄公寤生，不得不说下颖考叔，古今论孝道，考叔是楷模，但关于他的故事我就不多说了，有兴趣可以百一下，因为俺的罗嗦是有限度的。话说考叔是带着一只猫头鹰去见庄公，言此鸟最该吃。为什么呢？因为此鸟幼时母喂其食，长大后却反啄其母。寤生这一听就明白了，后悔了，便派人去接他母亲回来。但其母怕其违誓，遭神灵处罚，不肯回去。这时又是考叔献计，上演了一出凿泉见母的感人场面。 敢正面与周天子作对，并在战争中取胜，这在诸侯中是第一人。最后周天子不得不承认他的地位，庄公于是便成为后世诸侯之楷模。可是，霸业未成，抱憾而终。 这又让我们想起了公子小白。俺想起小白是有原因的，待会再说。 小白原不是按理即位的，当初贝丘山离宫一场大火，前任齐王诸儿被杀。齐国陷入内乱。诸儿一直喜欢自己的妹妹文姜，可早已许配给鲁国，于是便设计杀害鲁候。方是时，齐国靡乱之风日盛。小白和他的哥哥纠分别在鲍叔牙和管仲的带领下逃亡异国。待内乱既平，随之便又是王位之争。管仲欲让公子纠即位，便一箭射中小白，管子神射当时天下皆知。只见那小白口吐鲜血，倒于车上，管子这才放心而去。后小白醒，说是怕他再射一箭，便咬破舌头佯死。而后先入为主成了齐王。随后公子纠又被鲁国国君处死。正当管仲临刑，却不料被齐所救。齐国之要活管仲，不要死公子。什么意思，想必众人皆知。小白原想报射钩之仇，却不料拜他做了相国。后来管鲍之交，鲍叔牙举贤不避亲，小白纳才不避敌成千古美谈。 而后，小白有和郑庄公一样的雄心，称霸天下。在管子辅佐下，九合诸侯，一匡天下。尊王攘夷，霸业既成。 小白帮寤生走完了他想走的路，要是寤生知道了小白的结局，还会抱憾而终么？霸业未成，奋斗一生也许更好。 出师未捷身先死，还可以换得天下英雄为之惋惜。月满则亏，水满则溢。到达了人生的顶点，后面的就是下坡路了。 这一生戎马，挥戈天下，抱称霸之心，却留称霸之憾的人生，若能完成霸业，似乎就没有一点瑕疵了。可夺城易，守城难，小白一世英豪，天下诸侯景仰，尊王有德，攘夷有力，实力就摆在那里，无与争锋。多少王室的梦想，无数先王的遗憾，他终于完成了。可是结局却是被自己信任的宦官囚于王宫，无吃无喝，死后六十几日都没人发现。这是王室里罕见的悲剧，前面倒有一例，是纣王。 说到这里，突然想笑一下，然后什么都不说了。 桓公和纣王，一以仁义治天下，一依暴虐施于民；一雄心凌云，志在天下诸侯，一目光短浅，只图朝夕安乐；一任用贤才，“举贤不避亲，纳才不避敌”成千古佳话，乃后治世之楷模；一则酒池肉林，摘星楼奢华之极，整日歌舞不减，醉生梦死，为一己之私欲，残害忠良，佞贼当朝，鸡犬升天，成汤天下，毁于一旦，徒留万世之骂名。 两个相反的人生却有般这相似的结局，也许是物极必反。想到这里，俺不知道小白是否会觉得自己比寤生好，有了梦想就去努力实现，就算为之而死也没关系。可你带着天下人的目光，完成了梦想，你达到了时代的顶点，达到了人生的顶点，自以为可以开始享受自己曾经的付出，然而管、隰之死，鲍辞官，贤臣良将都离之而去。你明知道他们是小人，却还是不愿离开他们，苦果既结，苦酒自酿矣。 你坐上了春秋霸主的第一把交椅，以实力征服天下，俺觉得要是能在管鲍离开之前寿终正寝就好了。这一来，你这一生便没有什么遗憾了，你也老了，打也打不动了，但你的功绩前无古人。二来，你在他们之前挂了，他们会帮你选好新任齐王，你就不必担心王位之争，便无后顾之忧了。 说来，俺得出一个结论，不管是什么问题，你都可以归结为时间的问题。俺觉得寤生的遗憾是时间不够了，小白的悲剧是寿命太长了。 呵呵，俺这估计是放假无聊胡乱扯的，上不得大雅之堂，不过这个结论俺倒是觉得还适用。考试没考好，是复习时间不够；任务没完成，是给的时间太少；精神不好是睡觉时间不够… 不过从另一方面说不出太阳是因为阴雨时间不够，不成功就是因为失败的时间不够，寂寞的时间不够。成功是失败之后没有放弃的配拥有，成功只为耐得住寂寞的人买单。说说俺还觉得励志了，呵呵，可是找不回当初的热情了。 说着突然发现，最近喜欢用俺自称了。主要原因，是最近经常想到悟空的那句“妖怪，吃俺老孙一棒”。每每想到，便忍俊不禁。突然觉得这字喊起来别有一番味道。比如曹操说“宁叫俺负天下人，休叫天下人负俺”，说这又想笑了，这奸雄形象却显得有些滑稽，多萌几分了。只恨那阿满不会这方言。或者又有“俺住长江头，君住长江尾，日日思君不见君，共饮长江水”，或者“俺寄愁心与明月，随风直到夜郎西”，或者“人若犯俺，俺必犯人”，不知道你们读的时候有啥感觉，俺反正就是想笑，不知不觉这字俺就顺口了…罪过—— 俺用的这水货砖头，一次只能写几百字，还不会分段。虽然不怎么方便，但俺也没啥不满，砖头能打电话发短信，关键时候还能防身，够用了。俺这文章写的不咋样，但还是首尾照应的，最起码等你们读到结尾时，你们会发现这照应了前面一句“罗嗦，俺性格”。。。 到这里，不罗嗦了。 水货手机，害得老子写了几次，拖了几天，不知道的还以为俺在找妹子聊天，老子的节操啊…… ——记于大寒时节的罗嗦…对了，俺是不觉得红颜祸水的，来的越多越好，哈哈！]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停调中秋吟]]></title>
    <url>%2Fposts%2F6d156558%2F</url>
    <content type="text"><![CDATA[晓月多寒岚雾重， 几回相思几回空？ 五处风光五处尽， 一夜乡心一夜同。 叶落雁归周复始， 残梦易醒万事空。 银光伴客与愁眠， 灯火百家随月圆。 只字难慰心中苦， 锦瑟又知几回重？ 且吟且唱怨离合， 难舍难归忆亲容。 聚首不待多时日， 浮云低徊起伏中。 几时银辉重如今， 借月把觞一醉纵！]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悼亡词]]></title>
    <url>%2Fposts%2F66fca25e%2F</url>
    <content type="text"><![CDATA[寒暑流年易霜鬓，荏苒岁月半世灰。春来春去任劬劳，又是春时大梦归。茫茫天地再不见，泪尽眼枯唤不回。东风无力挽落晖，悲怀沾襟日渐垂。秋至兰蕙谢枯丛，今夕三月复吐芳；今夕三月魂归天，奈何此生永销亡！未等曲终已先断，泪逝徒留存者伤。人到七十古时稀，今本百岁可有余。不等儿孙来奉孝，人鬟何处话凄凉？常期命比南山石，星月轮回固恒长。谁料人生祸不单，一朝幽隔天人墙！痛怨费词已无用，唯愿安好黄泉上！ ——3.24]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[粘蝇板]]></title>
    <url>%2Fposts%2F61fb1399%2F</url>
    <content type="text"><![CDATA[一只苍蝇飞到另一只身边，开始一段时间，生活比蜜甜，而后，他们可以相濡以沫，这当然是件很温馨的事。可是时间长了，他们发现自己还是在粘在上面，失去了最初的自由，留给它们的，便是等不完的绝望。或许，等到某天，粘蝇板上的胶老化了，其中一个力量较大的挣脱了它的束缚，飞走了。临走前，他说∶我一定会回来的！剩下的一只会相信这句话么？或许，她不想在绝望中度过自己的余生。但是绝望就是绝望，她不相信，她也不敢相信，可是他明知道这里有粘蝇板，还可能回来么？他们都知道，回来那他不如不走，走了干嘛还回来。于是，头也不回，或许是怕暴露自己此刻的欣喜。他看到了另一只苍蝇，便飞过去，拿自己的不幸去引来一些同情，拿自己丰富的人生阅历去引来一些羡慕的目光，他开始满足了。那些走进过别人的世界的人似乎总是显得很有生活经验，显得很有历史，尤其是那些总在别人世界里进进出出的人，在别人的世界里刻下几道伤痕，便有了引人羡艳的谈资。他总是认为那些从没离开过粘蝇板的苍蝇总是好骗的。所以很快，他们就在一起了，他很开心，为自己满足。她们开始了一段快乐的时间，而后，他觉得好久飞了，想出去看一下。突然发现，自己脚下还是一张粘蝇纸。他开始挣扎，却越陷越深。此后，他又开始了渴望自由的生活，每天试图摆脱她周围的粘蝇纸。他会逃脱么？或许，某一天跑了，然后到了下一个苍蝇旁边，最后发现，又是一张粘蝇纸。但这已不是重点。因为粘蝇板留给他的教训是永远无法吸取的，到处都是粘蝇板。那只最初被抛弃的苍蝇或许又等到了另一只苍蝇。在他自豪的夸耀自己的过去时，她觉得很无聊，但还是假装出一副羡慕的样子，给他一点满足感，好让他留下来，因为她永远无法习惯这孤单。每只苍蝇脚下都有一个粘蝇板，她终于离开了第一只苍蝇脚下的粘蝇板，站到他这边来了。或许她运气不会总这么差，等他们发现失去自由之后，他便绝望了，不再想着挣脱这束缚，或许也是因为看清了，他们俩就这样可以一直过下去。他们长了一双翅膀，可见，自由是一件天生就很重要的事。可是，他们却总感觉一身桎梏。所以，总有一些苍蝇，为了自由，他们不停的飞，再累也得坚持，他们永远都是孤单的，因为不想被束缚，可他们有时也无法忍受这些孤独。只能自言自语，只能对影而酌。他们没有走进别的粘蝇板上，别的苍蝇也无法进入他们的世界。他们拥有了令所有苍蝇都羡慕的自由和飞行的能力，却永远只能活在自己的世界里。孤独不是他们的习惯，他们的习惯是去习惯孤独，如感冒病毒一样，总无法免疫。—这就是生活。]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不属于自己的高三]]></title>
    <url>%2Fposts%2F5f159f2c%2F</url>
    <content type="text"><![CDATA[桌上的一大堆书完全可以挡住老师的视线，让睡觉在其盲区内进行。 也不知道自己拿着什么作业在做，做着做着就睡了，睡着睡着就醒了。发现周围的同学还在埋头写着，我的试卷上多了一滩口水，便檫干了继续做。多想找个时光机把我送到未来好好的睡一觉再回来。然而产生这种想法的时刻便注定了绝望。没有时间再去想这些虚妄的事了，得继续做作业。可是身体却感到特别疲惫。但周围同学的专注的眼神，让我不由自主的紧张，而眼睛却懒得睁开。本想转移下注意力，换本书，却依然看不进去。也许离目标的差距就在这里吧！我胡思乱想着，勉强着让视线回到试卷。刚只做了一题，看大家的样子是快做完了。可以抄吗？但既然有精力抄，那为什么没有精力自己做呢？想着想着，也懒得抄了。手中的笔还没掉，不过也没握着，看样子也过不了几分钟就会滑下去，可手也懒得动一下。 老师突然进来了，我强迫自己坐好，握好笔，费力的去看题目。可是老师开始收卷了！题目还是一个也看不进去, 老师的脚步还在临近。最后问同学答案，可突然发现老师就在我们旁边，收了他的卷子，看着我。不知道那是什么眼神，可那透过厚厚的镜片折射出得光线分明让人感到不安。他开始收我的卷子，我却紧紧的按着，不想交给他。然后他就更用力的拉，我也更紧地按着。最后，他把我的手挪开，看了看那张白卷，又看了看我。感觉到脸颊在发烫，但还是迷迷糊糊的，分不清这又是什么眼神了。白色的灯光下，两只大手举着一张卷子，然后，用力一撕———- 醒了。 突然想起自己在自习室的桌子上睡着了。也不知道自己睡了多长时间，周围的人也都不在了，大概是去吃饭了吧。一个梦而已，好像我高三并未经历过，但好真实。 算了，不想了，马上就要考试了，开始复习了。]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[忆韩生]]></title>
    <url>%2Fposts%2Ff9f66023%2F</url>
    <content type="text"><![CDATA[风满楼，月满楼，小调难抒一丝愁，未觉泪先流。 成也何，败也何,一生戎马为君戈，钟室良弓折。]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>怀古</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子夜]]></title>
    <url>%2Fposts%2F5e4725d8%2F</url>
    <content type="text"><![CDATA[冷月无风秋自憔， 万籁暗寞旧梦凋。 又是落叶离别时， 去年烟雨花多娇。天意不怜离枝苦， 人间风雨几时休？ 一朝卷入黄土中， 曾经枝头入云霄。 二十一日，夜深，万籁皆寂，月落，过半墙，银光寒。此刻，一个人最容易发现自己的心。这个安静的时刻，并不适合休息。不如盛一壶月光，留进梦里，让回忆带走。]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命的意义]]></title>
    <url>%2Fposts%2F9e3b7d7e%2F</url>
    <content type="text"><![CDATA[人活着到底是为了什么？初中时我会说：为了更好的活着而活着。这似乎太朦胧了，有投机取巧的嫌疑，和没回答一样。高中后会说：对知识的渴望，对爱情的追求，和对人类苦难无法扼制的同情心，这三种感情支配着我的一生。可是，九个亿万富翁相继自杀的事件，让我不得不重新考虑这个问题。如果人生只是为了追求的话，那么当你拥有了一切的时候是否就是人生的终点？人生只是一个过程，只是从我们不存在的时刻开始到另一个我们将要不存在的时刻。没有生命是永恒的，也就是说，一个人生命没有结果。而在这个只重视结果的年代，一个人的生命又有什么意义呢？如果只发生一次的事便没有什么意义的话，那么我们的生命又有什么价值呢？生命没有意义？没有价值？可是不存在对时间的函数为什么会是间断的，而不是连续的？连续的话便没有生命了，也就是说生命为什么会存在？存在也是一种意义，因为它有存在的意义。可是一个生命对时间的函数的定义域的长度是有限的。对一个人来说，无穷大定义域的只能是不存在函数。而这个函数的间断是为了说明间断前后的表达式不一样么？也就是生命前后的不存在已经有所不同了。[br]（无聊的时候喜欢思考人生，而由于以后还会无聊，故此未完待续）不同的表达式表达着不同性质的生命。把生命微分，微分到一分一秒，这一分这一秒过去了就不存在了，如果没有了连续的下一分下一秒，你能做成什么？或许连后悔都来不及完成；把生命积分，积分到整个历史，这里面那些形形色色的生命都只是画过一些单值曲线，也许在同一时刻有着许多不同的曲线。但是，我在想，生命的横轴是时间轴，积分变量也是时间，那么纵轴代表着什么？积分的意义又在哪里？对于生命，人们往往关心的便是长度与宽度。宽度也可以说是高度，生命只是二维的。我不是什么什么家，但请允许我擅自定义这纵轴代表生命的高度，那么积分的意义便是这生命的意义了。那么，一条短线，在一有限区间里的积分，也就是短线下时间轴上区间内的那部分面积，便是生命的意义。〈手机限制，未完待续〉]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无调自吟]]></title>
    <url>%2Fposts%2Fe3091d2%2F</url>
    <content type="text"><![CDATA[春来东风瘦，夏至烈日骄。残阳下小楼，红霞野火烧。犹记伤心无限事，挥泪难话路迢迢。不知远处路如何，空自向人道沧桑。一声弹指若隔世，十年书山梦一场。风雨消磨，韶华暗逝，却嫌岁月长。回首成非，还忆当时书生气；来日不见，世事依旧两茫茫。素不善工诗恨难已，而天涯也无际，找不到，埋愁地！]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻涯临雪]]></title>
    <url>%2Fposts%2F6ad13995%2F</url>
    <content type="text"><![CDATA[岁岁纷零雪，处处染白头。徒自凭空意乱舞，都作瞬息不识愁。江山远，天地空，素衣掩住千尺楼。踏雪寻涯若无忧，赚得此生似水流。 暮暮北天寒，迟迟晚风干。谁把流年暗偷换，俯仰陈迹再见难。布衾冷，人未还，每临清夜离魂乱。被酒忽忆故乡好，半载只向梦中看。]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伤逝]]></title>
    <url>%2Fposts%2F38270fed%2F</url>
    <content type="text"><![CDATA[冷风瑟瑟枯木摇，落叶纷纷百草凋。日光已经不觉暖，雾锁清秋透骨寒。一年光景黯淡处，雁字早去客犹在，否极，泰不来，那堪哀？ 曾经蹉跎厌时长，回首半载已成霜。飞蓬无心随风逐浮萍却要独海航。夜深始觉布衾冷，晚风易止恨难罢，梦觉，愁未醒，伤无涯。]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清辉孤月伴我行]]></title>
    <url>%2Fposts%2F4521ac31%2F</url>
    <content type="text"><![CDATA[似曾懒慢倦疏狂，只看闲云流水长。饱食碌碌不终日，茫然不知所为何。月已再度几盈缺？苦恨半载徒虚晃。提笔长作无病吟，逢人道忙却是茫。光阴恰如风吹走，掠过半生不留痕。低吟愁思万缕长，未曾间断费思量。持觞绝断愁中愁，临风添酒伤更伤。去日尽是苦与忧，泪湿睫毛与双袖。凉风吹得心意冷，前途黯黯无月明。岁月何能如此殇？唯留烦懑与时增。仰身只把双臂枕，清夜怅望独伤神。然却今日仍少年，风吹两鬓黑如油。还忆当日踌躇志，苦也罢，愁也罢，纵使波浪兼天涌，起帆当把长风驾。]]></content>
      <categories>
        <category>乱体诗</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>心情</tag>
      </tags>
  </entry>
</search>
